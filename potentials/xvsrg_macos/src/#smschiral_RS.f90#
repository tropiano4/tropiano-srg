!**************************************************************************************************
!**************************************************************************************************
!**************************************************************************************************
!****                                                                                          ****
!****      This library containes subroutines to generate semilocal momentum-space-regularized ****
!****      chiral NN potentials (sms-chiral) up to N4LO+.                                      ****
!****                                                                                          ****
!****      To generate momentum-space partial-wave matrix elements use the routine:            ****
!****                                                                                          ****
!****      - CHIRALMOMPWD(OSTAT,FORCE,PPUN1,PPUN2,JMOM,CUTNUMQ,POTEN)                          ****
!****        It generates < p',l',s,j | V | p,l,s,j > for given values of the magnitude of the ****
!****        incomung and outgoing momenta p=PPUN2 and p'=PPUN1, [real double precision],      ****
!****        which should be given in GeV, and a fixed value of j=JMOM [integer]. These        ****
!****        parameters should be provided as input. The output vector POTEN(6) [real double   ****
!****        precision] contains MEs for all possible combinations of l, l' and s using the    ****
!****        following notation:                                                               ****
!****          POTEN(1):       s=0, l'=l=j                                                     ****
!****          POTEN(2):       s=1, l'=l=j                                                     ****
!****          POTEN(3):       s=1, l'=l=j-1                                                   ****
!****          POTEN(4):       s=1, l'=j-1, l=j+1                                              ****
!****          POTEN(5):       s=1, l'=j+1, l=j-1                                              ****
!****          POTEN(6):       s=1, l'=l=j+1                                                   ****
!****        Matrix elements POTEN(i) are generated in units of GeV^(-2). Partial-wave MEs     ****
!****        have the standard normalization (CHECK YOUR CONVENTION FOR THE SIGN OF THE        ****
!****        OFF-DIAGONAL MEs) and are to be substituted into the Lippmann-Schwinger equation  ****
!****        without any prefactors, i.e. T = V + integral[k^2 dk V G_0 T].                    ****
!****        NOTICE: this is a DIFFERENT convention compared to the one adopted in the         ****
!****        nonlocal n3lo chiral subroutine "chiral_n3lo.f90" of 2004, where all momenta and  ****
!****        potential MEs were given in units MeV and MeV**(-2) and a different normalization ****
!****        of the LS equation was assumed. In order to bring the PWD MEs of this routine     ****
!****        into the convention of "chiral_n3lo.f90", multiply POTEN(i) by the factor of      ****
!****        PI/2D0/1000000D0.                                                                 ****
!****                                                                                          ****
!****        The remaining input parameters are:                                               ****
!****          OSTAT [integer]:   0,1,2,3,4,5 stays for LO, NLO, N2LO, N3LO, N4LO and N4LO+    ****
!****                             (N4LO+: takes into account the 3F3,1F3,3F3,3F4 contacts)     ****
!****          FORCE [character,len=2]: type of the interaction ('nn', 'pp' or 'np')           ****
!****          CUTNUMQ [integer]: 1, 2, 3, 4 stays for the momentum-space cutoff               ****
!****                             Lambda = 400, 450, 500 and 550 MeV.                          ****
!****                                                                                          ****
!****      Notice:                                                                             ****
!****                                                                                          ****
!****      1. The usage of the new routine is the same as of the "ichiral.f90" one. One only   ****
!****         needs to replace "USE ICHIRAL" by "USE SMSCHIRAL" in the application code.       ****
!****         All conventions are unchanged.                                                   ****
!****                                                                                          ****
!****      2. Due to a local regularization of long-range interactions, the potential          ****
!****         decreases with momenta much slower than the (nonlocal) ones generated by the     ****
!****         old routine "chiral_n3lo.f90". Therefore, integrations over momenta when         ****
!****         solving the Lippmann-Schwinger equation should go up to about 6...7 GeV.         ****
!****                                                                                          ****
!****      3. The potentials at all chiral orders are designed for the standard                ****
!****         non-relativistic-like Lippmann-Schwinger equation with the relativistic          ****
!****         relation between the cms energy and momentum. Also for the deuteron BE one       ****
!****         should use relativistic kinematics.                                              ****
!****                                                                                          ****
!****      4. Always do first initialize the potential for all required momenta and partial    ****
!****         for fixed values of OSTAT and CUTNUMQ. Doing this in a different way will result ****
!****         in a very poor performance of the subroutine.                                    ****
!****                                                                                          ****
!****      5. The potentials for Lambda = 550 MeV are strongly nonperturbative, and one        ****
!****         starts seeing unnaturally large LECs (especially at N3LO). This may affect       ****
!****         reliability of predictions...                                                    ****
!****                                                                                          ****
!****      E.Epelbaum, 23.11.2017                                                              ****
!**************************************************************************************************
!**************************************************************************************************
!**************************************************************************************************
MODULE SMSCHIRAL
IMPLICIT NONE
SAVE
PRIVATE
PUBLIC CHIRALMOMPWD
INTEGER                    ::NISO,NSPIN
REAL(KIND(0.0D0))          ::PI
PARAMETER                   (PI=3.1415926535897932385D0,&
                             NISO=4,&
                             NSPIN=4)
INTEGER                    ::NGRID
REAL(KIND(0.0D0))          ::TYPMOMSCALE,POWER

PARAMETER                   (NGRID=200,&
                             TYPMOMSCALE=0.5D0,POWER=1D0)
REAL(KIND(0.0D0))          ::QGRID(NGRID),LAMGRID,&
                             SPL2(4,NISO*NSPIN,NGRID),&
                             POTMOMGRID(NGRID,NSPIN,NISO)
PARAMETER                   (LAMGRID=15D0)

INTEGER                    ::NMU
PARAMETER                   (NMU=128)
REAL(KIND(0.0D0))          ::LAMMU1,LAMMU2,LAMMU3,MUP(NMU),MUW(NMU)
PARAMETER                   (LAMMU1=0.2D0,LAMMU2=0.5D0,LAMMU3=2.5D0)
REAL(KIND(0.0D0))          ::ETACQ2(NMU),RHOSQ2(NMU),&
                             RHOCQ3(NMU),ETASQ3(NMU),&
                             RHOCQ4(NMU),ETACQ4(NMU),RHOSQ4(NMU),ETASQ4(NMU),RHOCQ4REL(NMU),ETACQ4REL(NMU),&
                             RHOSQ4REL(NMU),ETASQ4REL(NMU),RHOSLQ4REL(NMU),ETASLQ4REL(NMU),&
                             RHOCQ5(NMU),ETACQ5(NMU),RHOSQ5(NMU),ETASQ5(NMU),RHOCQ5REL(NMU),ETACQ5REL(NMU),&
                             RHOSQ5REL(NMU),ETASQ5REL(NMU),RHOSLQ5REL(NMU),ETASLQ5REL(NMU)

INTEGER                    ::NXP
REAL(KIND(0.0D0))          ::LAMXP1,LAMXP2,LAMXP3
PARAMETER                   (NXP=64,LAMXP1=0.01D0,LAMXP2=0.1D0,LAMXP3=1D0)
REAL(KIND(0.0D0))          ::XP(NXP),XW(NXP)

INTEGER                    ::NCUTQ
PARAMETER                   (NCUTQ=4)
REAL(KIND(0.0D0))          ::CUTQ(NCUTQ),CLO(4,NCUTQ),CNLODR(11,NCUTQ),D1S0OFF,D3S1OFF,DE1OFF,&
                             CN2LODR(11,NCUTQ),CN3LODR(23,NCUTQ),CN4LODR(24,NCUTQ),&
                             CN4LOPLUSDR(24,NCUTQ),CFDR(4,NCUTQ)
REAL(KIND(0.0D0))          ::GA,C1N2LO,C3N2LO,C4N2LO,C1N3LO,C2N3LO,C3N3LO,C4N3LO,&
                             D1PD2N3LO,D3N3LO,D5N3LO,D14MD15N3LO,MPI,MPIN,MPIC,FPI,M,&
                             C1N4LO,C2N4LO,C3N4LO,C4N4LO,D1PD2N4LO,D3N4LO,D5N4LO,D14MD15N4LO,&
                             E14N4LO,E17N4LO,E19N4LO,E21N4LO,E22N4LO,MPROT,MNEUT
PARAMETER                   (GA=1.29D0,&
                             MPI=0.13803D0,MPIN=0.13498D0,MPIC=0.139570D0,FPI=0.0924D0,&
                             MPROT=0.9382720D0,MNEUT=0.9395653D0,&
                             M=2.0D0*MPROT*MNEUT/(MPROT+MNEUT),&
                             C1N2LO=-0.74D0,C3N2LO=-3.61D0,C4N2LO=2.44D0,&
                             C1N3LO=-1.07D0,C2N3LO=3.20D0,C3N3LO=-5.32D0,C4N3LO=3.56D0,&
                             D1PD2N3LO=1.04D0,D3N3LO=-0.48D0,D5N3LO=0.14D0,D14MD15N3LO=-1.90D0,&
                             C1N4LO=-1.10D0,C2N4LO=3.57D0,C3N4LO=-5.54D0,C4N4LO=4.17D0,&
                             D1PD2N4LO=6.18D0,D3N4LO=-8.91D0,D5N4LO=0.86D0,D14MD15N4LO=-12.18D0,&
                             E14N4LO=1.18D0,E17N4LO=-0.18D0,E19N4LO=0D0,E21N4LO=0D0,E22N4LO=0D0,&
                             D1S0OFF=0D0,D3S1OFF=0D0,DE1OFF=0D0,&
                             CUTQ=  (/ 0.78931188D0, 0.45D0, 0.50D0, 0.55D0 /))
! Changes made here by AT: Set CUTQ(0) to correspond to cutoffs of 3.0,4.0,9.0 fm^-1
! and changed CLO(2,1) such that LO potential gives the binding energy of deuteron = -2.2 MeV
! Lambda = 3.0 fm^-1 -> CUTQ(0) = 0.59198391 GeV and CLO(2,1) = -0.03215
! Lambda = 4.0 fm^-1 -> CUTQ(0) = 0.78931188 GeV and CLO(2,1) = 0.03881
! Lambda = 9.0 fm^-1 -> CUTQ(0) = 1.77595173 GeV and CLO(2,1) = -0.083215
!==================================================================================================
 DATA            CLO    /&                                                                       !=
-0.85634359D-01,0.03881D+00,-0.84338518D-01,-0.84934262D-01,&                                    !=
-0.75582368D-01,-0.84735749D-01,-0.74671445D-01,-0.75392874D-01,&                                !=
-0.67666109D-01,-0.63981157D-01,-0.67032018D-01,-0.67814779D-01,&                                !=
-0.61282313D-01,-0.45688492D-01,-0.60851133D-01,-0.61657848D-01/                                 !=
 DATA           CNLODR  /&                                                                       !=
-0.92499336D-01, 0.42794024D+00, 0.66686487D+00,-0.12912642D+00, 0.25080490D+00, 0.23443508D+00,&!=
 0.14728615D-01, 0.35312873D+00,-0.40140154D+00,-0.90563737D-01,-0.90131014D-01,&                !=
-0.77951731D-01, 0.49504753D+00, 0.64283050D+00,-0.12512287D+00, 0.36644791D+00, 0.12622750D+00,&!=
 0.11076140D+00, 0.28080255D+00,-0.33922815D+00,-0.76166134D-01,-0.75581111D-01,&                !=
-0.55372598D-01, 0.56198384D+00, 0.65793103D+00,-0.12396844D+00, 0.44512767D+00, 0.40705619D-01,&!=
 0.17423390D+00, 0.23157947D+00,-0.29200080D+00,-0.53567068D-01,-0.52752786D-01,&                !=
-0.88539181D-02, 0.67050888D+00, 0.71566255D+00,-0.12416793D+00, 0.52339571D+00,-0.36377562D-01,&!=
 0.22194603D+00, 0.19512614D+00,-0.25453031D+00,-0.67390263D-02,-0.55421401D-02/                 !=
 DATA           CN2LODR  /&                                                                      !=
-0.39058363D-01, 0.23207929D+00, 0.48831841D+00,-0.71205312D-01, 0.10627438D+00, 0.38635777D+00,&!=
 0.33564742D+00, 0.69660680D+00,-0.17278277D+00,-0.37072629D-01,-0.36556812D-01,&                !=
 0.73397676D-02, 0.19929759D+00, 0.37800315D+00,-0.31011433D-01, 0.18967143D+00, 0.31858953D+00,&!=
 0.53947907D+00, 0.76391000D+00,-0.44320900D-01, 0.91787885D-02, 0.98452680D-02,&                !=
 0.68724958D-01, 0.12440056D+00, 0.29593152D+00, 0.25817431D-01, 0.22314933D+00, 0.28587664D+00,&!=
 0.76356568D+00, 0.90894175D+00, 0.72206786D-01, 0.70552954D-01, 0.71418946D-01,&                !=
 0.14734184D+00, 0.12648867D-01, 0.23032591D+00, 0.11719022D+00, 0.25685547D+00, 0.28547801D+00,&!=
 0.11061816D+01, 0.11783909D+01, 0.18344635D+00, 0.14931557D+00, 0.15045761D+00/                 !=
 DATA           CN3LODR  /&                                                                      !=
-0.12704393D-01,-0.11376914D-01, 0.47061728D+01, 0.77192095D+00, 0.18637499D+01, 0.42298911D+00,&!=
-0.23879495D-01,-0.17159090D+00, 0.51472953D+01, 0.57117797D+00,-0.52331363D+00, 0.19369204D+01,&!=
 0.47679594D+00, 0.17682787D+01, 0.93898717D+00, 0.61100260D+00, 0.11788958D+00,-0.81161292D+00,&!=
-0.35634914D+00,-0.72500480D+00,-0.24015390D+00,-0.10761154D-01,-0.10341426D-01,&                !=
 0.49432384D-01,-0.67808954D-01, 0.35109761D+01, 0.87507332D+00, 0.18187270D-01, 0.95631094D+00,&!=
 0.34679639D-01,-0.17424511D+00, 0.52894715D+01, 0.41432438D+00,-0.21828084D-01, 0.16743445D+01,&!=
 0.82837493D+00, 0.51713244D+00, 0.11389636D+01,-0.24756430D+00, 0.33556905D+00,-0.77175056D+00,&!=
-0.18197227D+00, 0.50520685D+00,-0.88405241D-01, 0.51207575D-01, 0.51762821D-01,&                !=
 0.13300370D+00,-0.20308264D+00, 0.30727027D+01, 0.10023328D+01,-0.82273135D+00, 0.13574248D+01,&!=
 0.11070098D+00,-0.23218981D+00, 0.70437041D+01, 0.32681890D+00, 0.66658636D+00, 0.16962709D+01,&!=
 0.11288330D+01,-0.52856266D+00, 0.13438681D+01,-0.13288343D+01, 0.56809661D+00,-0.90712990D+00,&!=
-0.90885165D-01, 0.12011629D+01, 0.13230714D+00, 0.13469579D+00, 0.13538956D+00,&                !=
 0.23914427D+00,-0.41355503D+00, 0.30284999D+01, 0.11171829D+01,-0.15827854D+01, 0.17289078D+01,&!=
 0.20743267D+00,-0.34459627D+00, 0.22698475D+02, 0.28290158D+00, 0.25564652D+01, 0.18920709D+01,&!=
 0.13769038D+01,-0.15980049D+01, 0.15808596D+01,-0.21631800D+01, 0.81724937D+00,-0.11308977D+01,&!=
-0.46191511D-01, 0.17475662D+01, 0.28508493D+00, 0.24075541D+00, 0.24152660D+00/                 !=
 DATA           CN4LODR  /&                                                                      !=
-0.29777535D-01, 0.64668926D-01, 0.46179592D+01, 0.68803476D+00, 0.15252036D+01,-0.11724866D+00,&!=
-0.37899078D-01,-0.59140881D-01, 0.35542026D+01, 0.53656578D+00,-0.25243900D+00, 0.20046946D+01,&!=
 0.35089557D+00, 0.20793113D+01, 0.77677554D+00, 0.11631647D+01, 0.64796200D-02,-0.67566714D+00,&!=
-0.35779930D+00,-0.86291097D+00,-0.34044265D+00,-0.28518056D-01,-0.28121082D-01, 0.82683372D-01,&!=
 0.10586665D-01, 0.90811142D-01, 0.29621649D+01, 0.75189364D+00,-0.57205301D-01, 0.22491970D+00,&!=
 0.82061159D-02,-0.87921045D-02, 0.28463147D+01, 0.37693550D+00, 0.11891658D-02, 0.13006966D+01,&!=
 0.60500484D+00, 0.10800383D+01, 0.85077882D+00, 0.35195185D+00, 0.12554429D+00,-0.44149218D+00,&!=
-0.16108692D+00, 0.22067969D+00,-0.15749496D+00, 0.11522844D-01, 0.12065520D-01, 0.12629689D+00,&!=
 0.55714720D-01, 0.98511185D-01, 0.20522862D+01, 0.79597479D+00,-0.78098080D+00, 0.37300775D+00,&!=
 0.61144182D-01,-0.94942583D-02, 0.26298471D+01, 0.26928103D+00, 0.19661550D+00, 0.91001296D+00,&!=
 0.78825882D+00, 0.27852770D+00, 0.89011149D+00,-0.25822666D+00, 0.22235475D+00,-0.38214092D+00,&!=
-0.62416008D-01, 0.72996642D+00,-0.26363433D-01, 0.57610092D-01, 0.58300702D-01, 0.13223150D+00,&!=
 0.10201420D+00, 0.10774530D+00, 0.15305548D+01, 0.82437437D+00,-0.11690665D+01, 0.40137554D+00,&!=
 0.11702287D+00,-0.13212797D-01, 0.29773670D+01, 0.19111119D+00, 0.44402861D+00, 0.71060460D+00,&!=
 0.87524830D+00,-0.39985800D+00, 0.87900313D+00,-0.68549076D+00, 0.28640804D+00,-0.37138884D+00,&!=
-0.10234232D-01, 0.99792211D+00, 0.29487273D-01, 0.10524672D+00, 0.10608927D+00, 0.13538524D+00/ !=
 DATA           CN4LOPLUSDR  /&                                                                  !=
-0.31094581D-01, 0.10558726D+00, 0.40434267D+01, 0.69203130D+00, 0.14741403D+01,-0.15306829D+00,&!=
-0.36963369D-01,-0.63179434D-01, 0.35309270D+01, 0.55045285D+00,-0.34587772D+00, 0.21713179D+01,&!=
 0.35002510D+00, 0.18293060D+01, 0.76735542D+00, 0.11109645D+01, 0.84591562D-02,-0.68270461D+00,&!=
-0.42377898D+00,-0.85739352D+00,-0.79803032D-01,-0.28923385D-01,-0.28510780D-01, 0.99231916D-01,&!=
 0.99134696D-02, 0.12102702D+00, 0.25789121D+01, 0.75382855D+00,-0.55941959D-01, 0.21823488D+00,&!=
 0.11446483D-01,-0.24605693D-01, 0.26696399D+01, 0.41033007D+00,-0.33080275D+00, 0.15244458D+01,&!=
 0.59082565D+00, 0.81335654D+00, 0.82773493D+00, 0.21607000D+00, 0.12726477D+00,-0.44843024D+00,&!=
-0.21865661D+00, 0.18703201D+00, 0.14069321D+00, 0.11436026D-01, 0.11985900D-01, 0.13258471D+00,&!=
 0.55808705D-01, 0.11957635D+00, 0.17221240D+01, 0.79416140D+00,-0.73340715D+00, 0.37674545D+00,&!=
 0.66851833D-01,-0.44851777D-01, 0.23511662D+01, 0.31176506D+00,-0.27289239D+00, 0.11391054D+01,&!=
 0.75613098D+00, 0.97573521D-02, 0.85565622D+00,-0.38344156D+00, 0.22370914D+00,-0.38628694D+00,&!=
-0.11847507D+00, 0.68026164D+00, 0.25730249D+00, 0.57605191D-01, 0.58297938D-01, 0.13087387D+00,&!=
 0.10286049D+00, 0.11886678D+00, 0.11816859D+01, 0.81917214D+00,-0.10914079D+01, 0.40951192D+00,&!=
 0.12441957D+00,-0.83730478D-01, 0.24731980D+01, 0.23301982D+00,-0.18570016D+00, 0.90246344D+00,&!=
 0.83340321D+00,-0.62629102D+00, 0.84356134D+00,-0.77073317D+00, 0.28752356D+00,-0.37318984D+00,&!=
-0.67167918D-01, 0.94134430D+00, 0.28256550D+00, 0.10485193D+00, 0.10569218D+00, 0.12360749D+00/ !=
 DATA           CFDR  /&                                                                         !=
 0.24884484D+01, 0.15231376D+01, 0.17693482D+01,-0.22135663D+00,&                                !=
 0.22893304D+01, 0.21620180D+01, 0.13187641D+01, 0.27749987D+00,&                                !=
 0.21375695D+01, 0.23476104D+01, 0.10218937D+01, 0.42772636D+00,&                                !=
 0.20178878D+01, 0.24833807D+01, 0.83551915D+00, 0.42467420D+00/                                 !=
!==================================================================================================
INTEGER                    ::CUTNUMQFIR,OSTATFIR
LOGICAL                    ::FIRST1,FIRST2
DATA                       FIRST1/.FALSE./
DATA                       FIRST2/.FALSE./
INTEGER                    ::NZPUN
PARAMETER                   (NZPUN=64)
REAL(KIND(0.0D0))          ::ZPUN(NZPUN),ZWEI(NZPUN),PL(NZPUN),PLP(NZPUN),PLM(NZPUN)
!***************************************************************************************************
CONTAINS





!***************************************************************************************************
SUBROUTINE CHIRALMOMPWD(OSTAT,FORCE,PPUN1,PPUN2,JMOM,CUTNUMQ,POTEN)
IMPLICIT NONE
INTEGER                    ::I,J,OSTAT,JMOM,CUTNUMQ
REAL(KIND(0.0D0))          ::PPUN1,PPUN2,POTEN(6),POTENOPERATOR(NSPIN,NISO),Q,&
                             V1T(NZPUN),V2T(NZPUN),V3T(NZPUN),V4T(NZPUN),&
                             W1T(NZPUN),W2T(NZPUN),W3T(NZPUN),W4T(NZPUN),&
                             VR1T(6),VR2T(6),VR3T(6),VR4T(6),&
                             WR1T(6),WR2T(6),WR3T(6),WR4T(6),&
                             POTISOT(6),POTISOS(6),POTENCONT(6)
CHARACTER(len=2)           ::FORCE

IF (JMOM .GE. NZPUN/2-5) THEN
  WRITE(*,*)'Increase the number of angular integration points NZPUN'
  STOP
ELSE
  IF (JMOM .LT. 0) THEN
    WRITE(*,*)'Wrong value of JMOM'
    STOP
  END IF
END IF

IF (.NOT. FIRST2) THEN
  CALL GAULEGCH(-1D0,1D0,ZPUN,ZWEI,NZPUN)
  FIRST2=.TRUE.
END IF
DO I=1,NZPUN
  PL(I)=PLFF(ZPUN(I),JMOM)
  PLP(I)=PLFF(ZPUN(I),JMOM+1)
  IF (JMOM .GE. 1) THEN
    PLM(I)=PLFF(ZPUN(I),JMOM-1)
  END IF
END DO

SELECT CASE (FORCE)
CASE ('nn')
  DO I=1,NZPUN
    Q=SQRT(PPUN1**2+PPUN2**2-2D0*PPUN1*PPUN2*ZPUN(I))
    CALL CHIRALMOMLR(OSTAT,Q,CUTNUMQ,POTENOPERATOR)
    IF (OSTAT .GE. 3) THEN
      POTENOPERATOR=POTENOPERATOR*(MNEUT/SQRT(MNEUT**2+PPUN1**2)/2D0+MNEUT/SQRT(MNEUT**2+PPUN2**2)/2D0)
    END IF
    V1T(I)=POTENOPERATOR(1,1)+POTENOPERATOR(1,2)+1D0/4D0*POTENOPERATOR(1,3)-POTENOPERATOR(1,4)
    V2T(I)=POTENOPERATOR(2,1)+POTENOPERATOR(2,2)+1D0/4D0*POTENOPERATOR(2,3)-POTENOPERATOR(2,4)
    V3T(I)=POTENOPERATOR(3,1)+POTENOPERATOR(3,2)+1D0/4D0*POTENOPERATOR(3,3)-POTENOPERATOR(3,4)
    V4T(I)=POTENOPERATOR(4,1)+POTENOPERATOR(4,2)+1D0/4D0*POTENOPERATOR(4,3)-POTENOPERATOR(4,4)
  END DO
  CALL PARCCH(VR1T,V1T,JMOM)
  CALL PARSIGCH(VR2T,V2T,JMOM)
  CALL PARSIGDCH(VR3T,V3T,JMOM,PPUN1,PPUN2)
  CALL PARSLCH(VR4T,V4T,JMOM,PPUN1,PPUN2)
  DO J=1,6
    POTISOT(J)=VR1T(J)+VR2T(J)+VR3T(J)+VR4T(J)
    POTISOS(J)=0D0
  END DO
CASE ('pp')
  DO I=1,NZPUN
    Q=SQRT(PPUN1**2+PPUN2**2-2D0*PPUN1*PPUN2*ZPUN(I))
    CALL CHIRALMOMLR(OSTAT,Q,CUTNUMQ,POTENOPERATOR)
    IF (OSTAT .GE. 3) THEN
      POTENOPERATOR=POTENOPERATOR*(MPROT/SQRT(MPROT**2+PPUN1**2)/2D0+MPROT/SQRT(MPROT**2+PPUN2**2)/2D0)
    END IF
    V1T(I)=POTENOPERATOR(1,1)+POTENOPERATOR(1,2)+1D0/4D0*POTENOPERATOR(1,3)+POTENOPERATOR(1,4)
    V2T(I)=POTENOPERATOR(2,1)+POTENOPERATOR(2,2)+1D0/4D0*POTENOPERATOR(2,3)+POTENOPERATOR(2,4)
    V3T(I)=POTENOPERATOR(3,1)+POTENOPERATOR(3,2)+1D0/4D0*POTENOPERATOR(3,3)+POTENOPERATOR(3,4)
    V4T(I)=POTENOPERATOR(4,1)+POTENOPERATOR(4,2)+1D0/4D0*POTENOPERATOR(4,3)+POTENOPERATOR(4,4)
  END DO
  CALL PARCCH(VR1T,V1T,JMOM)
  CALL PARSIGCH(VR2T,V2T,JMOM)
  CALL PARSIGDCH(VR3T,V3T,JMOM,PPUN1,PPUN2)
  CALL PARSLCH(VR4T,V4T,JMOM,PPUN1,PPUN2)
  DO J=1,6
    POTISOT(J)=VR1T(J)+VR2T(J)+VR3T(J)+VR4T(J)
    POTISOS(J)=0D0
  END DO
CASE ('np')
  DO I=1,NZPUN
    Q=SQRT(PPUN1**2+PPUN2**2-2D0*PPUN1*PPUN2*ZPUN(I))
    CALL CHIRALMOMLR(OSTAT,Q,CUTNUMQ,POTENOPERATOR)
    IF (OSTAT .GE. 3) THEN
      POTENOPERATOR=POTENOPERATOR*(M/SQRT(M**2+PPUN1**2)/2D0+M/SQRT(M**2+PPUN2**2)/2D0)
    END IF
    V1T(I)=POTENOPERATOR(1,1)+POTENOPERATOR(1,2)-1D0/4D0*POTENOPERATOR(1,3)
    V2T(I)=POTENOPERATOR(2,1)+POTENOPERATOR(2,2)-1D0/4D0*POTENOPERATOR(2,3)
    V3T(I)=POTENOPERATOR(3,1)+POTENOPERATOR(3,2)-1D0/4D0*POTENOPERATOR(3,3)
    V4T(I)=POTENOPERATOR(4,1)+POTENOPERATOR(4,2)-1D0/4D0*POTENOPERATOR(4,3)
    W1T(I)=POTENOPERATOR(1,1)-3D0*POTENOPERATOR(1,2)-1D0/4D0*POTENOPERATOR(1,3)
    W2T(I)=POTENOPERATOR(2,1)-3D0*POTENOPERATOR(2,2)-1D0/4D0*POTENOPERATOR(2,3)
    W3T(I)=POTENOPERATOR(3,1)-3D0*POTENOPERATOR(3,2)-1D0/4D0*POTENOPERATOR(3,3)
    W4T(I)=POTENOPERATOR(4,1)-3D0*POTENOPERATOR(4,2)-1D0/4D0*POTENOPERATOR(4,3)
  END DO
  CALL PARCCH(VR1T,V1T,JMOM)
  CALL PARCCH(WR1T,W1T,JMOM)
  CALL PARSIGCH(VR2T,V2T,JMOM)
  CALL PARSIGCH(WR2T,W2T,JMOM)
  CALL PARSIGDCH(VR3T,V3T,JMOM,PPUN1,PPUN2)
  CALL PARSIGDCH(WR3T,W3T,JMOM,PPUN1,PPUN2)
  CALL PARSLCH(VR4T,V4T,JMOM,PPUN1,PPUN2)
  CALL PARSLCH(WR4T,W4T,JMOM,PPUN1,PPUN2)
  DO J=1,6
    POTISOT(J)=VR1T(J)+VR2T(J)+VR3T(J)+VR4T(J)
    POTISOS(J)=WR1T(J)+WR2T(J)+WR3T(J)+WR4T(J)
  END DO
CASE DEFAULT
   WRITE(*,*)'wrong value of FORCE'
   STOP
END SELECT

IF ((JMOM/2)*2 .NE. JMOM) THEN
  POTEN(1)=POTISOS(1)
  POTEN(2)=POTISOT(2)
  POTEN(3)=POTISOS(4)
  POTEN(4)=POTISOS(6)
  POTEN(5)=POTISOS(5)
  POTEN(6)=POTISOS(3)
ELSE
  POTEN(1)=POTISOT(1)
  POTEN(2)=POTISOS(2)
  POTEN(3)=POTISOT(4)
  POTEN(4)=POTISOT(6)
  POTEN(5)=POTISOT(5)
  POTEN(6)=POTISOT(3)
END IF

CALL INITCONTACTS(OSTAT,FORCE,PPUN1,PPUN2,JMOM,CUTNUMQ,POTENCONT)
DO I=1,6
  POTEN(I)=POTEN(I)+POTENCONT(I)
  IF (ABS(POTEN(I)) .LE. 1D-6) THEN
    POTEN(I)=1D-15
  END IF
END DO

END SUBROUTINE CHIRALMOMPWD
!***************************************************************************************************





!***************************************************************************************************
SUBROUTINE CHIRALMOMLR(OSTAT,QPUN,CUTNUMQ,POTMOM)
IMPLICIT NONE
INTEGER                    ::I,OSTAT,CUTNUMQ
REAL(KIND(0.0D0))          ::QPUN,POTMOM(NSPIN,NISO),RES(NISO*NSPIN)

IF (FIRST1) THEN
  IF (OSTAT .NE. OSTATFIR) THEN
    FIRST1=.FALSE.
  END IF
  IF (CUTNUMQ .NE. CUTNUMQFIR) THEN
    FIRST1=.FALSE.
  END IF
END IF

IF (.NOT. FIRST1) THEN
  CALL INFO(OSTAT,CUTNUMQ)
  OSTATFIR=OSTAT
  CUTNUMQFIR=CUTNUMQ
  CALL TRNSCH(NXP/2,NXP/2,NXP,LAMXP1,LAMXP2,LAMXP3,XP,XW)
  CALL TRNSCH(NMU/2,NMU-NMU/2,NMU,LAMMU1,LAMMU2,LAMMU3,MUP,MUW)
  DO I=1,NMU
     MUP(I)=MUP(I)+2D0*MPI
  END DO
  CALL INITMOMGRID()
  CALL INITSPECTRAL2PI(OSTAT)
  CALL INITPOTMOMGRID(OSTAT,CUTNUMQ)
  CALL CreateCubicSpline(SPL2,QGRID,reshape(POTMOMGRID,(/NGRID,NISO*NSPIN/)),NGRID,NISO*NSPIN)
  FIRST1=.TRUE.
END IF

IF (QPUN .LE. QGRID(1)) THEN
  QPUN=QGRID(1)
END IF
IF (QPUN .GE. LAMGRID) THEN
  POTMOM=0D0
  RETURN
END IF

CALL SplineInterpolation(RES, QPUN, QGRID, SPL2, NGRID, NISO*NSPIN)
POTMOM = reshape(RES, (/NSPIN,NISO/))

END SUBROUTINE CHIRALMOMLR
!***************************************************************************************************




!***************************************************************************************************
SUBROUTINE INITCONTACTS(OSTAT,FORCE,PPUN1,PPUN2,JMOM,CUTNUMQ,POTENCONT)
IMPLICIT NONE
INTEGER                    ::I,OSTAT,CUTNUMQ,JMOM
REAL(KIND(0.0D0))          ::PPUN1,PPUN2,POTENCONT(6),LAMBDANL,FAKT,CC(26),C1S0Q2NNPP,&
                             CCF(5)
CHARACTER(len=2)           ::FORCE

POTENCONT=0D0
LAMBDANL=CUTQ(CUTNUMQ)
FAKT=EXP(-(PPUN1**2+PPUN2**2)/LAMBDANL**2)

SELECT CASE (OSTAT)
CASE (0)
  DO I=1,4
    CC(I)=CLO(I,CUTNUMQ)*FAKT
  END DO
  SELECT CASE (JMOM)
  CASE (0)
    SELECT CASE (FORCE)
    CASE ('np')
      POTENCONT(1)=CC(1)
    CASE ('nn')
      POTENCONT(1)=CC(3)
    CASE ('pp')
      POTENCONT(1)=CC(4)
    END SELECT
  CASE (1)
    POTENCONT(3)=CC(2)
  END SELECT
CASE (1, 2)
  IF (OSTAT .EQ. 1) THEN
    DO I=1,11
      CC(I)=CNLODR(I,CUTNUMQ)*FAKT
    END DO
  ELSE
    DO I=1,11
      CC(I)=CN2LODR(I,CUTNUMQ)*FAKT
    END DO
  END IF
  SELECT CASE (JMOM)
  CASE (0)
    POTENCONT(6)=CC(7)*PPUN1*PPUN2
    SELECT CASE (FORCE)
    CASE ('np')
      POTENCONT(1)=CC(1)+CC(2)*(PPUN1**2+PPUN2**2)
    CASE ('nn')
      POTENCONT(1)=CC(10)+CC(2)*(PPUN1**2+PPUN2**2)
    CASE ('pp')
      POTENCONT(1)=CC(11)+CC(2)*(PPUN1**2+PPUN2**2)
    END SELECT
  CASE (1)
    SELECT CASE (FORCE)
    CASE  ('np')
      POTENCONT(1)=CC(3)*PPUN1*PPUN2
      POTENCONT(2)=CC(8)*PPUN1*PPUN2
      POTENCONT(3)=CC(4)+CC(5)*(PPUN1**2+PPUN2**2)
      POTENCONT(4)=CC(6)*PPUN2**2
      POTENCONT(5)=CC(6)*PPUN1**2
    CASE ('nn', 'pp')
      POTENCONT(2)=CC(8)*PPUN1*PPUN2
    END SELECT
  CASE (2)
    POTENCONT(3)=CC(9)*PPUN1*PPUN2
  END SELECT
CASE (3, 4)
  IF (OSTAT .EQ. 3) THEN
    CC(1)=CN3LODR(1,CUTNUMQ)*FAKT
    CC(2)=CN3LODR(2,CUTNUMQ)*FAKT
    CC(3)=(-2D0*D1S0OFF+CN3LODR(3,CUTNUMQ))*FAKT
    CC(4)=D1S0OFF*FAKT
    DO I=5,9
      CC(I)=CN3LODR(I-1,CUTNUMQ)*FAKT
    END DO
    CC(10)=(-2D0*D3S1OFF+CN3LODR(9,CUTNUMQ))*FAKT
    CC(11)=D3S1OFF*FAKT
    CC(12)=CN3LODR(10,CUTNUMQ)*FAKT
    CC(13)=(DE1OFF+CN3LODR(11,CUTNUMQ))*FAKT
    CC(14)=-DE1OFF*FAKT
    DO I=15,26
      CC(I)=CN3LODR(I-3,CUTNUMQ)*FAKT
    END DO
    C1S0Q2NNPP=CC(2)
  ELSE
    CC(1)=CN4LODR(1,CUTNUMQ)*FAKT
    CC(2)=CN4LODR(2,CUTNUMQ)*FAKT
    CC(3)=(-2D0*D1S0OFF+CN4LODR(3,CUTNUMQ))*FAKT
    CC(4)=D1S0OFF*FAKT
    DO I=5,9
      CC(I)=CN4LODR(I-1,CUTNUMQ)*FAKT
    END DO
    CC(10)=(-2D0*D3S1OFF+CN4LODR(9,CUTNUMQ))*FAKT
    CC(11)=D3S1OFF*FAKT
    CC(12)=CN4LODR(10,CUTNUMQ)*FAKT
    CC(13)=(DE1OFF+CN4LODR(11,CUTNUMQ))*FAKT
    CC(14)=-DE1OFF*FAKT
    DO I=15,26
      CC(I)=CN4LODR(I-3,CUTNUMQ)*FAKT
    END DO
    C1S0Q2NNPP=CN4LODR(24,CUTNUMQ)*FAKT
  END IF
  SELECT CASE (JMOM)
  CASE (0)
    POTENCONT(6)=CC(16)*PPUN1*PPUN2&
                +CC(17)*PPUN1*PPUN2*(PPUN1**2+PPUN2**2)
    SELECT CASE (FORCE)
    CASE ('np')
      POTENCONT(1)=CC(1)+CC(2)*(PPUN1**2+PPUN2**2)&
                  +CC(3)*PPUN1**2*PPUN2**2+CC(4)*(PPUN1**4+PPUN2**4)
    CASE ('nn')
      POTENCONT(1)=CC(25)+C1S0Q2NNPP*(PPUN1**2+PPUN2**2)&
                  +CC(3)*PPUN1**2*PPUN2**2+CC(4)*(PPUN1**4+PPUN2**4)
    CASE ('pp')
      POTENCONT(1)=CC(26)+C1S0Q2NNPP*(PPUN1**2+PPUN2**2)&
                  +CC(3)*PPUN1**2*PPUN2**2+CC(4)*(PPUN1**4+PPUN2**4)
    END SELECT
  CASE (1)
    SELECT CASE (FORCE)
    CASE  ('np')
      POTENCONT(1)=CC(5)*PPUN1*PPUN2&
                  +CC(6)*PPUN1*PPUN2*(PPUN1**2+PPUN2**2)
      POTENCONT(2)=CC(18)*PPUN1*PPUN2&
                  +CC(19)*PPUN1*PPUN2*(PPUN1**2+PPUN2**2)
      POTENCONT(3)=CC(8)+CC(9)*(PPUN1**2+PPUN2**2)&
                  +CC(10)*PPUN1**2*PPUN2**2+CC(11)*(PPUN1**4+PPUN2**4)
      POTENCONT(4)=CC(12)*PPUN2**2&
                  +CC(13)*PPUN1**2*PPUN2**2+CC(14)*PPUN2**4
      POTENCONT(5)=CC(12)*PPUN1**2&
                  +CC(13)*PPUN1**2*PPUN2**2+CC(14)*PPUN1**4
      POTENCONT(6)=CC(15)*PPUN1**2*PPUN2**2
    CASE ('nn', 'pp')
      POTENCONT(2)=CC(18)*PPUN1*PPUN2&
                  +CC(19)*PPUN1*PPUN2*(PPUN1**2+PPUN2**2)
    END SELECT
  CASE (2)
    SELECT CASE (FORCE)
    CASE  ('np')
      POTENCONT(1)=CC(7)*PPUN1**2*PPUN2**2
      POTENCONT(2)=CC(23)*PPUN1**2*PPUN2**2
      POTENCONT(3)=CC(20)*PPUN1*PPUN2&
                  +CC(21)*PPUN1*PPUN2*(PPUN1**2+PPUN2**2)
      POTENCONT(4)=CC(22)*PPUN1*PPUN2**3
      POTENCONT(5)=CC(22)*PPUN1**3*PPUN2
    CASE ('nn', 'pp')
      POTENCONT(1)=CC(7)*PPUN1**2*PPUN2**2
      POTENCONT(3)=CC(20)*PPUN1*PPUN2&
                  +CC(21)*PPUN1*PPUN2*(PPUN1**2+PPUN2**2)
      POTENCONT(4)=CC(22)*PPUN1*PPUN2**3
      POTENCONT(5)=CC(22)*PPUN1**3*PPUN2
    END SELECT
  CASE (3)
    SELECT CASE (FORCE)
    CASE  ('np')
      POTENCONT(3)=CC(24)*PPUN1**2*PPUN2**2
    END SELECT
  END SELECT
CASE (5)
  CC(1)=CN4LOPLUSDR(1,CUTNUMQ)*FAKT
  CC(2)=CN4LOPLUSDR(2,CUTNUMQ)*FAKT
  CC(3)=(-2D0*D1S0OFF+CN4LOPLUSDR(3,CUTNUMQ))*FAKT
  CC(4)=D1S0OFF*FAKT
  DO I=5,9
    CC(I)=CN4LOPLUSDR(I-1,CUTNUMQ)*FAKT
  END DO
  CC(10)=(-2D0*D3S1OFF+CN4LOPLUSDR(9,CUTNUMQ))*FAKT
  CC(11)=D3S1OFF*FAKT
  CC(12)=CN4LOPLUSDR(10,CUTNUMQ)*FAKT
  CC(13)=(DE1OFF+CN4LOPLUSDR(11,CUTNUMQ))*FAKT
  CC(14)=-DE1OFF*FAKT
  DO I=15,26
    CC(I)=CN4LOPLUSDR(I-3,CUTNUMQ)*FAKT
  END DO
  C1S0Q2NNPP=CN4LOPLUSDR(24,CUTNUMQ)*FAKT
  CCF(1)=CFDR(1,CUTNUMQ)*FAKT
  CCF(2)=CFDR(2,CUTNUMQ)*FAKT
  CCF(3)=CFDR(3,CUTNUMQ)*FAKT
  CCF(4)=0D0
  CCF(5)=CFDR(4,CUTNUMQ)*FAKT
  SELECT CASE (JMOM)
  CASE (0)
    POTENCONT(6)=CC(16)*PPUN1*PPUN2&
                +CC(17)*PPUN1*PPUN2*(PPUN1**2+PPUN2**2)
    SELECT CASE (FORCE)
    CASE ('np')
      POTENCONT(1)=CC(1)+CC(2)*(PPUN1**2+PPUN2**2)&
                  +CC(3)*PPUN1**2*PPUN2**2+CC(4)*(PPUN1**4+PPUN2**4)
    CASE ('nn')
      POTENCONT(1)=CC(25)+C1S0Q2NNPP*(PPUN1**2+PPUN2**2)&
                  +CC(3)*PPUN1**2*PPUN2**2+CC(4)*(PPUN1**4+PPUN2**4)
    CASE ('pp')
      POTENCONT(1)=CC(26)+C1S0Q2NNPP*(PPUN1**2+PPUN2**2)&
                  +CC(3)*PPUN1**2*PPUN2**2+CC(4)*(PPUN1**4+PPUN2**4)
    END SELECT
  CASE (1)
    SELECT CASE (FORCE)
    CASE  ('np')
      POTENCONT(1)=CC(5)*PPUN1*PPUN2&
                  +CC(6)*PPUN1*PPUN2*(PPUN1**2+PPUN2**2)
      POTENCONT(2)=CC(18)*PPUN1*PPUN2&
                  +CC(19)*PPUN1*PPUN2*(PPUN1**2+PPUN2**2)
      POTENCONT(3)=CC(8)+CC(9)*(PPUN1**2+PPUN2**2)&
                  +CC(10)*PPUN1**2*PPUN2**2+CC(11)*(PPUN1**4+PPUN2**4)
      POTENCONT(4)=CC(12)*PPUN2**2&
                  +CC(13)*PPUN1**2*PPUN2**2+CC(14)*PPUN2**4
      POTENCONT(5)=CC(12)*PPUN1**2&
                  +CC(13)*PPUN1**2*PPUN2**2+CC(14)*PPUN1**4
      POTENCONT(6)=CC(15)*PPUN1**2*PPUN2**2
    CASE ('nn', 'pp')
      POTENCONT(2)=CC(18)*PPUN1*PPUN2&
                  +CC(19)*PPUN1*PPUN2*(PPUN1**2+PPUN2**2)
    END SELECT
  CASE (2)
    SELECT CASE (FORCE)
    CASE  ('np')
      POTENCONT(1)=CC(7)*PPUN1**2*PPUN2**2
      POTENCONT(2)=CC(23)*PPUN1**2*PPUN2**2
      POTENCONT(3)=CC(20)*PPUN1*PPUN2&
                  +CC(21)*PPUN1*PPUN2*(PPUN1**2+PPUN2**2)
      POTENCONT(4)=CC(22)*PPUN1*PPUN2**3
      POTENCONT(5)=CC(22)*PPUN1**3*PPUN2
      POTENCONT(6)=CCF(1)*PPUN1**3*PPUN2**3
    CASE ('nn', 'pp')
      POTENCONT(1)=CC(7)*PPUN1**2*PPUN2**2
      POTENCONT(3)=CC(20)*PPUN1*PPUN2&
                  +CC(21)*PPUN1*PPUN2*(PPUN1**2+PPUN2**2)
      POTENCONT(4)=CC(22)*PPUN1*PPUN2**3
      POTENCONT(5)=CC(22)*PPUN1**3*PPUN2
      POTENCONT(6)=CCF(1)*PPUN1**3*PPUN2**3
    END SELECT
  CASE (3)
    SELECT CASE (FORCE)
    CASE  ('np')
      POTENCONT(1)=CCF(2)*PPUN1**3*PPUN2**3
      POTENCONT(2)=CCF(3)*PPUN1**3*PPUN2**3
      POTENCONT(3)=CC(24)*PPUN1**2*PPUN2**2
      POTENCONT(4)=CCF(4)*PPUN1**2*PPUN2**4
      POTENCONT(5)=CCF(4)*PPUN1**4*PPUN2**2
    CASE  ('nn', 'pp')
      POTENCONT(2)=CCF(3)*PPUN1**3*PPUN2**3
    END SELECT
  CASE (4)
    POTENCONT(3)=CCF(5)*PPUN1**3*PPUN2**3
  END SELECT
END SELECT

POTENCONT=POTENCONT*10000D0/(2D0*PI)**3

END SUBROUTINE INITCONTACTS
!***************************************************************************************************





!***************************************************************************************************
SUBROUTINE INITPOTMOMGRID(OSTAT,CUTNUMQ)
IMPLICIT NONE
INTEGER                    ::I,J,OSTAT,CUTNUMQ
REAL(KIND(0.0D0))          ::QPUN,QPUNQ,FAKTCONVNORB,PROPC,PROPN,CS0C,CS0N,ERRORF,&
                             ALPHA,ERRORFC,ERRORFN,MU,MUQ,REG,CC0,CC2,CT2,CS0,CS2,CC4,CT4,CS4,CSL2,&
                             CSL4,LAMGEV,LAMGEV1

POTMOMGRID=0D0
FAKTCONVNORB=-2D0
LAMGEV1=CUTQ(CUTNUMQ)
DO J=1,NGRID
   LAMGEV=LAMGEV1*SQRT(2D0)
   QPUN=QGRID(J)
   QPUNQ=QPUN**2
   IF (OSTAT .GE. 1) THEN
      DO I=1,NMU
         MU=MUP(I)
         MUQ=MU**2
         REG=EXP(-(QPUNQ+MUP(I)**2)/LAMGEV**2)
         ERRORF=ERRORFCOM(MU/LAMGEV)
         CC0=(Mu**2*(LamGev**5 - 4D0*LamGev**3*Mu**2 - 2D0*LamGev*Mu**4 +&
             EXP(Mu**2/LamGev**2)*ErrorF*Mu**3*(5D0*LamGev**2 + 2D0*Mu**2)*Sqrt(Pi)))/LamGev**5
         CC2=(-3D0*LamGev**7 + 4D0*LamGev**3*Mu**4 + 4D0*LamGev*Mu**6 - &
              2D0*EXP(Mu**2/LamGev**2)*ErrorF*Mu**5*(3D0*LamGev**2 + 2D0*Mu**2)*Sqrt(Pi))/(3D0*LamGev**7)
         CT2=-(15D0*LamGev**7 - 6D0*LamGev**5*Mu**2 + 4D0*LamGev**3*Mu**4 - 8D0*LamGev*Mu**6 + &
              8D0*EXP(Mu**2/LamGev**2)*ErrorF*Mu**7*Sqrt(Pi))/(15D0*LamGev**7)
         CS0=(2D0*Mu**2*(LamGev**5 - 4D0*LamGev**3*Mu**2 - 2D0*LamGev*Mu**4 +&
             EXP(Mu**2/LamGev**2)*ErrorF*Mu**3*(5D0*LamGev**2 + 2D0*Mu**2)*Sqrt(Pi)))/(3D0*LamGev**5)
         CS2=(-15D0*LamGev**7 + 2D0*LamGev**5*Mu**2 + 12D0*LamGev**3*Mu**4 + 16D0*LamGev*Mu**6 -&
              4D0*EXP(Mu**2/LamGev**2)*ErrorF*Mu**5*(5D0*LamGev**2 + 4D0*Mu**2)*Sqrt(Pi))/(15D0*LamGev**7)
         POTMOMGRID(J,1,2)=POTMOMGRID(J,1,2)+2D0/PI*MUW(I)*ETACQ2(I)/MUP(I)**3*&
              (QPUN**4/(QPUNQ+MUQ)+CC0+CC2*QPUNQ)*REG
         POTMOMGRID(J,2,1)=POTMOMGRID(J,2,1)+2D0/PI*MUW(I)*RHOSQ2(I)/MUP(I)**3*&
              (QPUN**4/(QPUNQ+MUQ)+CS0+CS2*QPUNQ)*REG
         POTMOMGRID(J,3,1)=POTMOMGRID(J,3,1)-2D0/PI*MUW(I)*RHOSQ2(I)/MUP(I)**3*&
              (QPUN**2/(QPUNQ+MUQ)+CT2)*REG
         IF (OSTAT .GE. 2) THEN
            POTMOMGRID(J,1,1)=POTMOMGRID(J,1,1)+2D0/PI*MUW(I)*RHOCQ3(I)/MUP(I)**3*&
                 (QPUN**4/(QPUNQ+MUQ)+CC0+CC2*QPUNQ)*REG
            POTMOMGRID(J,2,2)=POTMOMGRID(J,2,2)+2D0/PI*MUW(I)*ETASQ3(I)/MUP(I)**3*&
                 (QPUN**4/(QPUNQ+MUQ)+CS0+CS2*QPUNQ)*REG
            POTMOMGRID(J,3,2)=POTMOMGRID(J,3,2)-2D0/PI*MUW(I)*ETASQ3(I)/MUP(I)**3*&
                 (QPUN**2/(QPUNQ+MUQ)+CT2)*REG
            IF (OSTAT .GE. 3) THEN
               ERRORF=ERRORFCOM(MU/LAMGEV)
               CC0=(Mu**2*(LamGev**5 - 4D0*LamGev**3*Mu**2 - 2D0*LamGev*Mu**4 +&
                   EXP(Mu**2/LamGev**2)*ErrorF*Mu**3*(5D0*LamGev**2 + 2D0*Mu**2)*Sqrt(Pi)))/LamGev**5
               CC2=(-3D0*LamGev**7 + 4D0*LamGev**3*Mu**4 + 4D0*LamGev*Mu**6 - &
                    2D0*EXP(Mu**2/LamGev**2)*ErrorF*Mu**5*(3D0*LamGev**2 + 2D0*Mu**2)*Sqrt(Pi))/(3D0*LamGev**7)
               CT2=-(15D0*LamGev**7 - 6D0*LamGev**5*Mu**2 + 4D0*LamGev**3*Mu**4 - 8D0*LamGev*Mu**6 + &
                    8D0*EXP(Mu**2/LamGev**2)*ErrorF*Mu**7*Sqrt(Pi))/(15D0*LamGev**7)
               CS0=(2D0*Mu**2*(LamGev**5 - 4D0*LamGev**3*Mu**2 - 2D0*LamGev*Mu**4 +&
                   EXP(Mu**2/LamGev**2)*ErrorF*Mu**3*(5D0*LamGev**2 + 2D0*Mu**2)*Sqrt(Pi)))/(3D0*LamGev**5)
               CS2=(-15D0*LamGev**7 + 2D0*LamGev**5*Mu**2 + 12D0*LamGev**3*Mu**4 + 16D0*LamGev*Mu**6 -&
                    4D0*EXP(Mu**2/LamGev**2)*ErrorF*Mu**5*(5D0*LamGev**2 + 4D0*Mu**2)*Sqrt(Pi))/(15D0*LamGev**7)
               CSL2=(-3D0*LamGev**5 + 2D0*LamGev**3*Mu**2 - 4D0*LamGev*Mu**4 + 4D0*EXP(Mu**2/LamGev**2)*&
                    ErrorF*Mu**5*Sqrt(Pi))/(3D0*LamGev**5)
               POTMOMGRID(J,1,1)=POTMOMGRID(J,1,1)+2D0/PI*MUW(I)*RHOCQ4REL(I)/MUP(I)**3*&
                    (QPUN**4/(QPUNQ+MUQ)+CC0+CC2*QPUNQ)*REG
               POTMOMGRID(J,2,1)=POTMOMGRID(J,2,1)+2D0/PI*MUW(I)*RHOSQ4REL(I)/MUP(I)**3*&
                    (QPUN**4/(QPUNQ+MUQ)+CS0+CS2*QPUNQ)*REG
               POTMOMGRID(J,3,1)=POTMOMGRID(J,3,1)-2D0/PI*MUW(I)*RHOSQ4REL(I)/MUP(I)**3*&
                    (QPUN**2/(QPUNQ+MUQ)+CT2)*REG
               POTMOMGRID(J,1,2)=POTMOMGRID(J,1,2)+2D0/PI*MUW(I)*ETACQ4REL(I)/MUP(I)**3*&
                    (QPUN**4/(QPUNQ+MUQ)+CC0+CC2*QPUNQ)*REG
               POTMOMGRID(J,2,2)=POTMOMGRID(J,2,2)+2D0/PI*MUW(I)*ETASQ4REL(I)/MUP(I)**3*&
                    (QPUN**4/(QPUNQ+MUQ)+CS0+CS2*QPUNQ)*REG
               POTMOMGRID(J,3,2)=POTMOMGRID(J,3,2)-2D0/PI*MUW(I)*ETASQ4REL(I)/MUP(I)**3*&
                    (QPUN**2/(QPUNQ+MUQ)+CT2)*REG
               POTMOMGRID(J,4,1)=POTMOMGRID(J,4,1)-2D0/PI*MUW(I)*RHOSLQ4REL(I)/MUP(I)*&
                                (QPUN**2/(QPUNQ+MUQ)+CSL2)*REG*FAKTCONVNORB
               POTMOMGRID(J,4,2)=POTMOMGRID(J,4,2)-2D0/PI*MUW(I)*ETASLQ4REL(I)/MUP(I)*&
                                (QPUN**2/(QPUNQ+MUQ)+CSL2)*REG*FAKTCONVNORB
               CC0=-(Mu**4*(4D0*LamGev**7 - 24D0*LamGev**5*Mu**2 - 26D0*LamGev**3*Mu**4 - 4D0*LamGev*Mu**6 +&
                   EXP(Mu**2/LamGev**2)*ErrorF*Mu**3*(35D0*LamGev**4 + 28D0*LamGev**2*Mu**2 + 4D0*Mu**4)*Sqrt(Pi)))/&
                   (4D0*LamGev**7)
               CC2=(Mu**2*(3D0*LamGev**9 - 12D0*LamGev**5*Mu**4 - 22D0*LamGev**3*Mu**6 - 4D0*LamGev*Mu**8 +&
                   EXP(Mu**2/LamGev**2)*ErrorF*Mu**5*(21D0*LamGev**4 + 24D0*LamGev**2*Mu**2 + 4D0*Mu**4)*Sqrt(Pi)))/&
                   (3D0*LamGev**9)
               CC4=(-15D0*LamGev**11 + 8D0*LamGev**5*Mu**6 + 18D0*LamGev**3*Mu**8 + 4D0*LamGev*Mu**10 -&
                   EXP(Mu**2/LamGev**2)*ErrorF*Mu**7*(15D0*LamGev**4 + 20D0*LamGev**2*Mu**2 + 4D0*Mu**4)*Sqrt(Pi))/&
                   (15D0*LamGev**11)
               CT2=(Mu**2*(15D0*LamGev**9 - 12D0*LamGev**7*Mu**2 + 12D0*LamGev**5*Mu**4 - 32D0*LamGev**3*Mu**6 -&
                    8D0*LamGev*Mu**8 + 4D0*EXP(Mu**2/LamGev**2)*ErrorF*Mu**7*(9D0*LamGev**2 + 2D0*Mu**2)*&
                    Sqrt(Pi)))/(15D0*LamGev**9)
               CT4=(-105D0*LamGev**11 + 12D0*LamGev**7*Mu**4 - 16D0*LamGev**5*Mu**6 + 48D0*LamGev**3*Mu**8 +&
                    16D0*LamGev*Mu**10 - 8D0*EXP(Mu**2/LamGev**2)*ErrorF*Mu**9*(7D0*LamGev**2 + 2D0*Mu**2)*&
                    Sqrt(Pi))/(105D0*LamGev**11)
               CS0=-(Mu**4*(4D0*LamGev**7 - 24D0*LamGev**5*Mu**2 - 26D0*LamGev**3*Mu**4 - 4D0*LamGev*Mu**6 +&
                    EXP(Mu**2/LamGev**2)*ErrorF*Mu**3*(35D0*LamGev**4 + 28D0*LamGev**2*Mu**2 + 4D0*Mu**4)*Sqrt(Pi)))/&
                    (6D0*LamGev**7)
               CS2=(Mu**2*(15D0*LamGev**9 - 4D0*LamGev**7*Mu**2 - 36D0*LamGev**5*Mu**4 - 84D0*LamGev**3*Mu**6 - &
                    16D0*LamGev*Mu**8 + 2D0*EXP(Mu**2/LamGev**2)*ErrorF*Mu**5*(35D0*LamGev**4 + 46D0*LamGev**2*Mu**2 +&
                    8D0*Mu**4)*Sqrt(Pi)))/(15D0*LamGev**9)
               CS4=(-105D0*LamGev**11 + 4D0*LamGev**7*Mu**4 + 32D0*LamGev**5*Mu**6 + 100D0*LamGev**3*Mu**8 + &
                    24D0*LamGev*Mu**10 - 2D0*EXP(Mu**2/LamGev**2)*ErrorF*Mu**7*(35D0*LamGev**4 + 56D0*LamGev**2*Mu**2 +&
                    12D0*Mu**4)*Sqrt(Pi))/(105D0*LamGev**11)
               CSL2=(3D0*LamGev**7*Mu**2 - 4D0*LamGev**5*Mu**4 + 12D0*LamGev**3*Mu**6 + 4D0*LamGev*Mu**8 -&
                    2D0*EXP(Mu**2/LamGev**2)*ErrorF*Mu**7*(7D0*LamGev**2 + 2D0*Mu**2)*Sqrt(Pi))/(3D0*LamGev**7)
               CSL4=(-15D0*LamGev**9 + 4D0*LamGev**5*Mu**4 - 16D0*LamGev**3*Mu**6 - 8D0*LamGev*Mu**8 + &
                    4D0*EXP(Mu**2/LamGev**2)*ErrorF*Mu**7*(5D0*LamGev**2 + 2D0*Mu**2)*Sqrt(Pi))/(15D0*LamGev**9)
               POTMOMGRID(J,1,1)=POTMOMGRID(J,1,1)-2D0/PI*MUW(I)*RHOCQ4(I)/MUP(I)**5*&
                    (QPUN**6/(QPUNQ+MUQ)+CC0+CC2*QPUNQ+CC4*QPUNQ**2)*REG
               POTMOMGRID(J,2,1)=POTMOMGRID(J,2,1)-2D0/PI*MUW(I)*RHOSQ4(I)/MUP(I)**5*&
                    (QPUN**6/(QPUNQ+MUQ)+CS0+CS2*QPUNQ+CS4*QPUNQ**2)*REG
               POTMOMGRID(J,3,1)=POTMOMGRID(J,3,1)+2D0/PI*MUW(I)*RHOSQ4(I)/MUP(I)**5*&
                    (QPUN**4/(QPUNQ+MUQ)+CT2+CT4*QPUNQ)*REG
               POTMOMGRID(J,1,2)=POTMOMGRID(J,1,2)-2D0/PI*MUW(I)*ETACQ4(I)/MUP(I)**5*&
                    (QPUN**6/(QPUNQ+MUQ)+CC0+CC2*QPUNQ+CC4*QPUNQ**2)*REG
               POTMOMGRID(J,2,2)=POTMOMGRID(J,2,2)-2D0/PI*MUW(I)*ETASQ4(I)/MUP(I)**5*&
                    (QPUN**6/(QPUNQ+MUQ)+CS0+CS2*QPUNQ+CS4*QPUNQ**2)*REG
               POTMOMGRID(J,3,2)=POTMOMGRID(J,3,2)+2D0/PI*MUW(I)*ETASQ4(I)/MUP(I)**5*&
                    (QPUN**4/(QPUNQ+MUQ)+CT2+CT4*QPUNQ)*REG
                  POTMOMGRID(J,1,1)=POTMOMGRID(J,1,1)-2D0/PI*MUW(I)*RHOCQ5REL(I)/MUP(I)**5*&
                       (QPUN**6/(QPUNQ+MUQ)+CC0+CC2*QPUNQ+CC4*QPUNQ**2)*REG
                  POTMOMGRID(J,2,1)=POTMOMGRID(J,2,1)-2D0/PI*MUW(I)*RHOSQ5REL(I)/MUP(I)**5*&
                       (QPUN**6/(QPUNQ+MUQ)+CS0+CS2*QPUNQ+CS4*QPUNQ**2)*REG
                  POTMOMGRID(J,3,1)=POTMOMGRID(J,3,1)+2D0/PI*MUW(I)*RHOSQ5REL(I)/MUP(I)**5*&
                       (QPUN**4/(QPUNQ+MUQ)+CT2+CT4*QPUNQ)*REG
                  POTMOMGRID(J,1,2)=POTMOMGRID(J,1,2)-2D0/PI*MUW(I)*ETACQ5REL(I)/MUP(I)**5*&
                       (QPUN**6/(QPUNQ+MUQ)+CC0+CC2*QPUNQ+CC4*QPUNQ**2)*REG
                  POTMOMGRID(J,2,2)=POTMOMGRID(J,2,2)-2D0/PI*MUW(I)*ETASQ5REL(I)/MUP(I)**5*&
                       (QPUN**6/(QPUNQ+MUQ)+CS0+CS2*QPUNQ+CS4*QPUNQ**2)*REG
                  POTMOMGRID(J,3,2)=POTMOMGRID(J,3,2)+2D0/PI*MUW(I)*ETASQ5REL(I)/MUP(I)**5*&
                       (QPUN**4/(QPUNQ+MUQ)+CT2+CT4*QPUNQ)*REG
                  POTMOMGRID(J,4,1)=POTMOMGRID(J,4,1)+2D0/PI*MUW(I)*RHOSLQ5REL(I)/MUP(I)**3*&
                       (QPUN**4/(QPUNQ+MUQ)+CSL2+CSL4*QPUNQ)*REG*FAKTCONVNORB
                  POTMOMGRID(J,4,2)=POTMOMGRID(J,4,2)+2D0/PI*MUW(I)*ETASLQ5REL(I)/MUP(I)**3*&
                       (QPUN**4/(QPUNQ+MUQ)+CSL2+CSL4*QPUNQ)*REG*FAKTCONVNORB
               IF (OSTAT .GE. 4) THEN
                  POTMOMGRID(J,1,1)=POTMOMGRID(J,1,1)-2D0/PI*MUW(I)*RHOCQ5(I)/MUP(I)**5*&
                       (QPUN**6/(QPUNQ+MUQ)+CC0+CC2*QPUNQ+CC4*QPUNQ**2)*REG
                  POTMOMGRID(J,2,1)=POTMOMGRID(J,2,1)-2D0/PI*MUW(I)*RHOSQ5(I)/MUP(I)**5*&
                       (QPUN**6/(QPUNQ+MUQ)+CS0+CS2*QPUNQ+CS4*QPUNQ**2)*REG
                  POTMOMGRID(J,3,1)=POTMOMGRID(J,3,1)+2D0/PI*MUW(I)*RHOSQ5(I)/MUP(I)**5*&
                       (QPUN**4/(QPUNQ+MUQ)+CT2+CT4*QPUNQ)*REG
                  POTMOMGRID(J,1,2)=POTMOMGRID(J,1,2)-2D0/PI*MUW(I)*ETACQ5(I)/MUP(I)**5*&
                       (QPUN**6/(QPUNQ+MUQ)+CC0+CC2*QPUNQ+CC4*QPUNQ**2)*REG
                  POTMOMGRID(J,2,2)=POTMOMGRID(J,2,2)-2D0/PI*MUW(I)*ETASQ5(I)/MUP(I)**5*&
                       (QPUN**6/(QPUNQ+MUQ)+CS0+CS2*QPUNQ+CS4*QPUNQ**2)*REG
                  POTMOMGRID(J,3,2)=POTMOMGRID(J,3,2)+2D0/PI*MUW(I)*ETASQ5(I)/MUP(I)**5*&
                       (QPUN**4/(QPUNQ+MUQ)+CT2+CT4*QPUNQ)*REG
               END IF
            END IF
         END IF
      END DO
   END IF
   IF (OSTAT .GE. 3) THEN
      ERRORF=ERRORFCOM(2D0*MPI/LAMGEV)
      ALPHA=3D0*GA**4/(512D0*PI*M*FPI**4)*2D0*MPI**5
      CC0=(2D0*Alpha*((-2D0*LamGev*(LamGev**2 + 2D0*Mpi**2))/EXP((4D0*Mpi**2)/LamGev**2) +&
           ErrorF*Mpi*(5D0*LamGev**2 + 8D0*Mpi**2)*Sqrt(Pi)))/LamGev**5
      CC2=(4D0*Alpha*((LamGev*(LamGev**2 + 4D0*Mpi**2))/EXP((4D0*Mpi**2)/LamGev**2) -&
           ErrorF*Mpi*(3D0*LamGev**2 + 8D0*Mpi**2)*Sqrt(Pi)))/(3D0*LamGev**7)
      POTMOMGRID(J,1,1)=POTMOMGRID(J,1,1)+ALPHA/(QPUNQ+4D0*MPI**2)*&
           EXP(-(QPUNQ+4D0*MPI**2)/LAMGEV**2)+(CC0+CC2*QPUNQ)*EXP(-QPUNQ/LAMGEV**2)
      ALPHA=GA**2/(128D0*PI*M*FPI**4)*3D0*GA**2*MPI**5
      CC0=(2D0*Alpha*((-2D0*LamGev*(LamGev**2 + 2D0*Mpi**2))/EXP((4D0*Mpi**2)/LamGev**2) +&
           ErrorF*Mpi*(5D0*LamGev**2 + 8D0*Mpi**2)*Sqrt(Pi)))/LamGev**5
      CC2=(4D0*Alpha*((LamGev*(LamGev**2 + 4D0*Mpi**2))/EXP((4D0*Mpi**2)/LamGev**2) -&
           ErrorF*Mpi*(3D0*LamGev**2 + 8D0*Mpi**2)*Sqrt(Pi)))/(3D0*LamGev**7)
      POTMOMGRID(J,1,2)=POTMOMGRID(J,1,2)+ALPHA/(QPUNQ+4D0*MPI**2)*&
           EXP(-(QPUNQ+4D0*MPI**2)/LAMGEV**2)+(CC0+CC2*QPUNQ)*EXP(-QPUNQ/LAMGEV**2)
   END IF
   LAMGEV=LAMGEV1
   PROPC=EXP(-(QPUNQ+MPIC**2)/LAMGEV**2)/(MPIC**2+QPUNQ)
   PROPN=EXP(-(QPUNQ+MPIN**2)/LAMGEV**2)/(MPIN**2+QPUNQ)
   ALPHA=-(GA/(2D0*FPI))**2
   POTMOMGRID(J,3,2)=POTMOMGRID(J,3,2)+ALPHA*PROPC
   POTMOMGRID(J,3,3)=POTMOMGRID(J,3,3)+4D0*(ALPHA*PROPN-ALPHA*PROPC)
   ERRORFN=ERRORFCOM(MPIN/LAMGEV)
   ERRORFC=ERRORFCOM(MPIC/LAMGEV)
   CS0N=(Alpha*(-((LamGev*(LamGev**2 - 2*MpiN**2))/EXP(MpiN**2/LamGev**2)) - 2D0*ErrorFN*MpiN**3*Sqrt(Pi)))/(3D0*LamGev**3)
   CS0C=(Alpha*(-((LamGev*(LamGev**2 - 2*MpiC**2))/EXP(MpiC**2/LamGev**2)) - 2D0*ErrorFC*MpiC**3*Sqrt(Pi)))/(3D0*LamGev**3)
   POTMOMGRID(J,2,2)=POTMOMGRID(J,2,2)+CS0C*EXP(-QPUNQ/LAMGEV**2)
   POTMOMGRID(J,2,3)=POTMOMGRID(J,2,3)+4D0*(CS0N-CS0C)*EXP(-QPUNQ/LAMGEV**2)
END DO

POTMOMGRID=POTMOMGRID/(2D0*PI)**3


END SUBROUTINE INITPOTMOMGRID
!***************************************************************************************************





!***************************************************************************************************
SUBROUTINE INITMOMGRID()
IMPLICIT NONE
INTEGER                    ::I
REAL(KIND(0.0D0))          ::YI,YF,Y
YI=1D0/(TYPMOMSCALE+0.001D0)**POWER
YF=1D0/(TYPMOMSCALE+LAMGRID)**POWER
DO I=1,NGRID
  Y=YI+(YF-YI)*REAL(I-1,KIND(0.0D0))/REAL(NGRID-1,KIND(0.0D0))
  QGRID(I)=1D0/Y**(1D0/POWER)-TYPMOMSCALE
END DO
END SUBROUTINE INITMOMGRID
!***************************************************************************************************





!***************************************************************************************************
SUBROUTINE INITSPECTRAL2PI(OSTAT)
IMPLICIT NONE
INTEGER                    ::OSTAT,I
REAL(KIND(0.0D0))          ::MU,MUQ,RHOA,RHOL,&
                             MPIQ,OMQ,RR,TQ,&
                             C1,C2,C3,C4,D1PD2,D3,D5,D14MD15,E14,E17,E19,E21,E22

ETACQ2=0D0
RHOSQ2=0D0
RHOCQ3=0D0
ETASQ3=0D0
RHOCQ4=0D0
ETACQ4=0D0
RHOSQ4=0D0
ETASQ4=0D0
RHOCQ4REL=0D0
ETACQ4REL=0D0
RHOSQ4REL=0D0
ETASQ4REL=0D0
RHOSLQ4REL=0D0
ETASLQ4REL=0D0
RHOCQ5=0D0
ETACQ5=0D0
RHOSQ5=0D0
ETASQ5=0D0
RHOCQ5REL=0D0
ETACQ5REL=0D0
RHOSQ5REL=0D0
ETASQ5REL=0D0
RHOSLQ5REL=0D0
ETASLQ5REL=0D0

MPIQ=MPI**2
IF (OSTAT .EQ. 2) THEN
  C1=C1N2LO
  C3=C3N2LO
  C4=C4N2LO
ELSE
  IF (OSTAT .EQ. 3) THEN
    C1=C1N3LO
    C2=C2N3LO
    C3=C3N3LO
    C4=C4N3LO
    D1PD2=D1PD2N3LO
    D3=D3N3LO
    D5=D5N3LO
    D14MD15=D14MD15N3LO
  ELSE
    IF (OSTAT .GE. 4) THEN
      C1=C1N4LO
      C2=C2N4LO
      C3=C3N4LO
      C4=C4N4LO
      D1PD2=D1PD2N4LO
      D3=D3N4LO
      D5=D5N4LO
      D14MD15=D14MD15N4LO
      E14=E14N4LO
      E17=E17N4LO
      E19=E19N4LO
      E21=E21N4LO
      E22=E22N4LO
    END IF
  END IF
END IF

IF (OSTAT .GE. 1) THEN
   DO I=1,NMU
      MU=MUP(I)
      MUQ=MU**2
      RHOL=-PI/(2D0*MU)*SQRT(MU**2-4D0*MPI**2)
      ETACQ2(I)=-RHOL/(384D0*PI**2*FPI**4)*(4D0*MPIQ*(5D0*GA**4-4D0*GA**2-1D0)-MUQ*&
          (23D0*GA**4-10D0*GA**2-1D0)+48D0*GA**4*MPI**4/(4D0*MPIQ-MUQ))
      RHOSQ2(I)=-MUQ*3D0*GA**4/(64D0*PI**2*FPI**4)*RHOL
   END DO
   IF (OSTAT .GE. 2) THEN
      DO I=1,NMU
         MU=MUP(I)
         MUQ=MU**2
         RHOA=PI/(4D0*MU)
         RHOCQ3(I)=-3D0*GA**2/(16D0*PI*FPI**4)*(2D0*MPIQ*&
               (2D0*C1-C3)+MUQ*C3)*(2D0*MPIQ-MUQ)*RHOA
         ETASQ3(I)=-MUQ*GA**2/(32D0*PI*FPI**4)*C4*(4D0*MPIQ-MUQ)*RHOA
      END DO
      IF (OSTAT .GE. 3) THEN
    DO I=1,NMU
      MU=MUP(I)
      MUQ=MU**2
      OMQ=-MU**2+4D0*MPI**2
      RHOA=PI/(4D0*MU)
      RHOL=-PI/(2D0*MU)*SQRT(MU**2-4D0*MPI**2)
      RR=0.5D0*SQRT(MUQ-4D0*MPIQ)
      TQ=MUQ-2D0*MPIQ
      RHOCQ4(I)=3D0/(16D0*PI**2*FPI**4)*RHOL*((C2/6D0*OMQ+C3*(2*MPIQ-MUQ)-4D0*C1*MPIQ)**2+C2**2/(45D0)*OMQ**2)&
               -3D0*GA**4*(MUQ-2D0*MPIQ)/(PI*MU*(4D0*FPI)**6)*((MPIQ-2D0*MUQ)*(2D0*MPI+(2D0*MPIQ-MUQ)/(2D0*MU)&
                                                               *LOG((MU+2D0*MPI)/(MU-2D0*MPI)))+4D0*GA**2*MPI*(2D0*MPIQ-MUQ))
      ETASQ4(I)=(C4**2/(96D0*PI**2*FPI**4)*OMQ*RHOL&
           -GA**4*(MUQ-4D0*MPIQ)/(MUQ*PI*(4D0*FPI)**6)*((MPIQ-MUQ/4)*LOG((MU+2D0*MPI)/(MU-2D0*MPI))+(1D0+2D0*GA**2)*MU*MPI))&
           *MUQ
      RHOSQ4(I)=-(GA**2*RR**3*MU/(8D0*FPI**4*PI)*D14MD15-2D0*GA**6*MU*RR**3/(8D0*PI*FPI**2)**3*(1D0/9D0-J1(MU)+J2(MU)))
      ETACQ4(I)=RR*TQ/(24D0*FPI**4*MU*PI)*(2D0*(GA**2-1D0)*RR**2-3D0*GA**2*TQ)*D1PD2&
               +RR**3/(60D0*FPI**4*MU*PI)*(6D0*(GA**2-1D0)*RR**2-5D0*GA**2*TQ)*D3&
               -RR*MPIQ/(6D0*FPI**4*MU*PI)*(2D0*(GA**2-1D0)*RR**2-3D0*GA**2*TQ)*D5&
               -1D0/(92160D0*FPI**6*MUQ*PI**3)*(-320D0*(1D0+2D0*GA**2)**2*MPI**6+240D0*(1D0+6D0*GA**2+8D0*GA**4)*MPI**4*MUQ&
                                                -60D0*GA**2*(8D0+15D0*GA**2)*MPIQ*MU**4&
                                                +(-4D0+29D0*GA**2+122D0*GA**4+3D0*GA**6)*MU**6)*LOG((2D0*RR+MU)/(2D0*MPI))&
               -RR/(2700D0*MU*(8D0*PI*FPI**2)**3)*(-16D0*(171D0+2D0*GA**2*(1D0+GA**2)*(327D0+49D0*GA**2))*MPI**4&
                                                   +4D0*(-73D0+1748D0*GA**2+2549D0*GA**4+726D0*GA**6)*MPIQ*MUQ&
                                                   -(-64D0+389D0*GA**2+1782D0*GA**4+1093D0*GA**6)*MU**4)&
               +2D0*RR/(3D0*MU*(8D0*PI*FPI**2)**3)*(GA**6*TQ**2*J1(MU)-2D0*GA**4*(2D0*GA**2-1D0)*RR**2*TQ*J2(MU))
      RHOCQ4REL(I)=3D0*GA**4/(512D0*PI*M*FPI**4)*(-3D0*(4D0*MPI**4-MU**4)*RHOA)
      ETACQ4REL(I)=GA**2/(128D0*PI*M*FPI**4)*(&
                   -(4D0*MPIQ-2D0*MUQ-GA**2*(7D0*MPIQ-4.5D0*MUQ))*(2D0*MPIQ-MUQ)*RHOA)
      RHOSQ4REL(I)=(9D0*GA**4/(512D0*PI*M*FPI**4)*(4D0*MPIQ-1.5D0*MUQ)*RHOA)*MUQ
      ETASQ4REL(I)=(-GA**2/(256D0*PI*M*FPI**4)*(8D0*MPIQ-2D0*MUQ-GA**2*(4D0*MPIQ-1.5D0*MUQ))*RHOA)*MUQ
      RHOSLQ4REL(I)=-3D0*GA**4/(64D0*PI*M*FPI**4)*(2D0*MPIQ-MUQ)*RHOA
      ETASLQ4REL(I)=-GA**2*(1D0-GA**2)/(64D0*PI*M*FPI**4)*(4D0*MPIQ-MUQ)*RHOA
      RHOCQ4REL(I)=RHOCQ4REL(I)+3D0*GA**4/(512D0*PI*M*FPI**4)*(2D0*MPI**2-MU**2)**2*RHOA
      ETACQ4REL(I)=ETACQ4REL(I)-GA**4/(256D0*PI*M*FPI**4)*(2D0*MPI**2-MU**2)**2*RHOA
      RHOSQ4REL(I)=RHOSQ4REL(I)-(3D0*GA**4/(1024D0*PI*M*FPI**4)*(4D0*MPI**2-MU**2)*RHOA)*MUQ
      ETASQ4REL(I)=ETASQ4REL(I)+(GA**4/(512D0*PI*M*FPI**4)*(4D0*MPI**2-MU**2)*RHOA)*MUQ
      RHOCQ5REL(I)=-GA**2*RHOL/(32D0*PI**2*M*FPI**4)*((C2-6D0*C3)*MU**4-4D0*(6D0*C1+C2-3D0*C3)*MPIQ*MUQ&
                                              +6D0*(C2-2D0*C3)*MPI**4+24D0*(2D0*C1+C3)*MPI**6/(4D0*MPI**2-MUQ))
      ETACQ5REL(I)=C4/(192D0*PI**2*M*FPI**4)*MUQ*OMQ*RHOL&
                  +C4*GA**2/(192D0*PI**2*M*FPI**4)*MUQ*(8D0*MPIQ-5D0*MUQ)*RHOL
      ETASQ5REL(I)=(C4/(192D0*PI**2*M*FPI**4)*OMQ*RHOL&
                  -C4*GA**2/(192D0*PI**2*M*FPI**4)*(16D0*MPIQ-7D0*MUQ)*RHOL)*MUQ
      RHOSLQ5REL(I)=-C2*GA**2/(16D0*PI**2*M*FPI**4)*OMQ*RHOL
      ETASLQ5REL(I)=C4/(96D0*PI**2*M*FPI**4)*OMQ*RHOL&
           +C4*GA**2/(96D0*PI**2*M*FPI**4)*(8D0*MPIQ-5D0*MUQ)*RHOL
   END DO
   IF (OSTAT .GE. 4) THEN
      DO I=1,NMU
        MU=MUP(I)
        MUQ=MU**2
        OMQ=-MU**2+4D0*MPI**2
        RHOA=PI/(4D0*MU)
        RHOL=-PI/(2D0*MU)*SQRT(MU**2-4D0*MPI**2)
        RR=0.5D0*SQRT(MUQ-4D0*MPIQ)
        TQ=MUQ-2D0*MPIQ
        RHOCQ5(I)=2D0*((GA**2*(2D0*MPI**2 - MU**2)*(MU*(72D0*C1*(MPI**4 - 2D0*MPI**2*MU**2) + C2*(-24D0*MPI**4 + &
              53D0*MPI**2*MU**2 - 10D0*MU**4) +&
              18D0*(C3*(-2D0*MPI**4 + 5D0*MPI**2*MU**2 - 2D0*MU**4) +&
              128D0*FPI**2*(E14*(-2D0*MPI**2 + MU**2)**2 + MPI**2*(4D0*E19*MPI**2 - 2D0*E19*MU**2 + E22*MU**2))*Pi**2)) -&
              6D0*(MPI**2 - 2D0*MU**2)*(24D0*C1*MPI**2 + C2*(-4D0*MPI**2 + MU**2) + 6D0*C3*(-2D0*MPI**2 + MU**2))*RR*&
              Log((MU + 2D0*RR)/(MU - 2D0*RR))))/(24576D0*FPI**6*MU**2*Pi**2))
        RHOCQ5(I)=RHOCQ5(I)+2D0*((48D0*GA**2*MPI*(MPI**2 - 2D0*MU**2)*RR**2*(6D0*(2D0*C1 - C3)*MPI**2 + 3D0*C3*MU**2 + &
              2D0*C2*RR**2) + &
              GA**4*(1536D0*(2D0*C1 - C3)*MPI**7 - 16D0*(84D0*C1 + 5D0*C2 - 42D0*C3)*MPI**6*MU - 192D0*(6D0*C1 - &
              7D0*C3)*MPI**5*MU**2 + &
              8D0*(84D0*C1 + 5D0*C2 - 84D0*C3)*MPI**4*MU**3 - 288D0*C3*MPI**3*MU**4 + (-36D0*C1 - 5D0*C2 + &
              186D0*C3)*MPI**2*MU**5 - &
              9D0*C3*MU**7 - 8D0*(64D0*C2*MPI**5 + (-12D0*C1 - 5D0*C2 + 6D0*C3)*MPI**4*MU - 40D0*C2*MPI**3*MU**2 + &
              (4D0*C2 - 3D0*C3)*MPI**2*MU**3 + C2*MU**5)*RR**2) + &
              12D0*MU*RR**2*(3D0*(4D0*C1 - C2 - 2D0*C3)*MPI**4 + 3D0*C3*MPI**2*MU**2 + &
              2D0*((12D0*C1 + C2 - 6D0*C3)*MPI**2 + 3D0*C3*MU**2)*RR**2 + 8D0*C2*RR**4))/(24576D0*FPI**6*MU*Pi**2*RR) + &
              (GA**2*(2D0*MPI**4 - 5D0*MPI**2*MU**2 + 2D0*MU**4)*RR*(6D0*(2D0*C1 - C3)*MPI**2 + 3D0*C3*MU**2 + 2D0*C2*RR**2)*&
              Log(1D0 + (4D0*MPI)/(-2D0*MPI + MU)))/(2048D0*FPI**6*MU**2*Pi**2) + &
              (MPI**2*(3D0*(-4D0*C1 + C2 + 2D0*C3)*MPI**4 - 3D0*C3*MPI**2*MU**2 + &
              2D0*GA**4*((28D0*C1 + 9D0*C2 - 14D0*C3)*MPI**4 - 4D0*C3*MU**4 + 4D0*(-8D0*C1 + C2 + 4D0*C3)*MPI**2*RR**2 - &
              MU**2*((16D0*C1 + 4D0*C2 - 15D0*C3)*MPI**2 + 8D0*C3*RR**2)))*Log((MU/2D0 + RR)/(MU/2D0 - RR)))/&
              (2048D0*FPI**6*MU*Pi**2))
        ETACQ5(I)=2D0*((-((-3D0*MU*RR**2*(-3D0*(-4D0*C1 + C2 + C3)*MPI**4 + 2D0*(12D0*C1 + C2 + C3)*MPI**2*RR**2 + &
              8D0*(C2 + C3)*RR**4) + &
              (C3 - C4)*GA**4*(12D0*MPI**2*(2D0*MPI - MU)*(-2D0*MPI**2 + MU**2)**2 + &
              (-192D0*MPI**5 + 87D0*MPI**4*MU + 96D0*MPI**3*MU**2 - 54D0*MPI**2*MU**3 + 6D0*MU**5)*RR**2 - &
              2D0*(16D0*MPI**3 - 19D0*MPI**2*MU + 6D0*MU**3)*RR**4 + 8D0*MU*RR**6) + &
              GA**2*RR**2*(48D0*(-C3 + C4)*MPI**3*MU**2 + 32D0*(C3 - C4)*MPI**3*(3D0*MPI**2 + RR**2) -&
              3D0*MU**3*((24D0*C1 + 3D0*C2 - 2D0*C3 + 5D0*C4)*MPI**2 + 2D0*(3D0*C2 + 2D0*C3 + C4)*RR**2) + &
              MU*(3D0*(60D0*C1 + 3D0*C2 - 8D0*C3 + 11D0*C4)*MPI**4 + 2D0*(36D0*C1 + 21D0*C2 + 8D0*C3 + 13D0*C4)*MPI**2*RR**2 + &
              8D0*(3D0*C2 + 2D0*C3 + C4)*RR**4)))/RR) + &
              3D0*((3D0*(C2 + C3) - 12D0*C1*(1D0 + 3D0*GA**2) + GA**2*(3D0*C2 + C3*(8D0 - 35D0*GA**2) + 5D0*C4*(-1D0 + &
              7D0*GA**2)))*MPI**6 + &
              3D0*GA**2*(8D0*C1 - C2 - 2*C3 + C4 + 10D0*C3*GA**2 - 10D0*C4*GA**2)*MPI**4*MU**2 + &
              6D0*(-C3 + C4)*GA**4*MPI**2*MU**4)*&
              Log(-((MU + 2D0*RR)/(-MU + 2D0*RR))))/(9216D0*FPI**6*MU*Pi**2))
        RHOSQ5(I)=2D0*(((C3 - C4)*GA**4*MU*(-2D0*MPI**2*(-2D0*MPI + MU)**2*(2D0*MPI + MU) + &
              (16D0*MPI**3 - 9D0*MPI**2*MU + MU**3)*RR**2 - &
              2D0*MU*RR**4 + 3D0*MPI**2*(-5D0*MPI**2 + MU**2)*RR*Log(-((MU + 2D0*RR)/(-MU + &
              2D0*RR)))))/(2048D0*FPI**6*Pi**2*RR))
        ETASQ5(I)=2D0*((GA**2*(4D0*MPI**2 - MU**2)*(MU*(C4*(12D0*(2D0 + 9D0*GA**2)*MPI**2 - 5D0*MU**2) - &
              1152D0*FPI**2*(2D0*E17*MPI**2 + 2D0*E21*MPI**2 - E17*MU**2)*Pi**2) + 24D0*C4*RR**3*Log((MU + &
              2D0*RR)/(MU - 2D0*RR))))/ &
              (73728D0*FPI**6*Pi**2))
        ETASQ5(I)=ETASQ5(I)+2D0*((C4*GA**2*(MU*(2D0*GA**2*MPI**2*(-2D0*MPI + MU)**2*(2D0*MPI + MU) - &
              (4D0*(-3D0 + 4D0*GA**2)*MPI**3 - 9D0*GA**2*MPI**2*MU + 3D0*MPI*MU**2 + GA**2*MU**3)*RR**2 + &
              2D0*(2D0*MPI + GA**2*MU)*RR**4 &
              ) + RR**4*(3D0*(-4D0*MPI**2 + MU**2) - 4D0*RR**2)*Log(1D0 + (4D0*MPI)/(-2D0*MPI + MU)) + &
              3D0*GA**2*MPI**2*MU*(5D0*MPI**2 - MU**2)*RR*Log(-((MU + 2D0*RR)/(-MU + &
              2D0*RR)))))/(6144D0*FPI**6*Pi**2*RR))
     END DO
  END IF
END IF
END IF
END IF

END SUBROUTINE INITSPECTRAL2PI
!***************************************************************************************************





!***************************************************************************************************
REAL(KIND(0.0D0))   FUNCTION ERRORFCOM(X)
IMPLICIT NONE
REAL(KIND(0.0D0))          ::X,ERR

CALL ERROR(X,ERR)
ERRORFCOM=1D0-ERR

END FUNCTION ERRORFCOM
!***************************************************************************************************





!***************************************************************************************************
subroutine error ( x, err )
!  This subroutine has been adapted by EE
!  The original subroutine is provided by:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!
!  Parameters:
!
!    Input, real X, the argument.
!
!    Output, real ERR, the function value.
!
  implicit none
  REAL(KIND(0.0D0))          ::c0,eps,er,err,r,x,x2
  integer  k

  eps = 1.0D-15
  x2 = x * x

  if ( abs ( x ) < 3.5D+00 ) then

    er = 1.0D+00
    r = 1.0D+00

    do k = 1, 50
      r = r * x2 / ( k + 0.5D+00 )
      er = er + r
      if ( abs ( r ) <= abs ( er ) * eps ) then
        exit
      end if
    end do

    c0 = 2.0D+00 / sqrt ( pi ) * x * exp ( - x2 )
    err = c0 * er

  else

    er = 1.0D+00
    r = 1.0D+00
    do k = 1, 12
      r = - r * ( k - 0.5D+00 ) / x2
      er = er + r
    end do

    c0 = exp ( - x2 ) / ( abs ( x ) * sqrt ( pi ) )

    err = 1.0D+00 - c0 * er
    if ( x < 0.0D+00 ) then
      err = -err
    end if

  end if

  return
end subroutine error
!***************************************************************************************************





!***************************************************************************************************
REAL(KIND(0.0D0))   FUNCTION J1(MUPUN)
IMPLICIT NONE
INTEGER                    ::I
REAL(KIND(0.0D0))          ::MUPUN,R,VAR

R=0.5D0*SQRT(MUPUN**2-4D0*MPI**2)
J1=0D0

DO I=1,NXP
  VAR=R*XP(I)/MPI
  IF (VAR .GE. 0.001D0) THEN
    J1=J1+(1D0/VAR**2-(1D0+1D0/VAR**2)**1.5D0*LOG(VAR+SQRT(1D0+VAR**2)))*XW(I)
  ELSE
    J1=J1+(-4D0/3D0-VAR**2/5D0+2D0*VAR**4/35D0-8D0*VAR**6/315D0)*XW(I)
  END IF
END DO
END FUNCTION J1
!***************************************************************************************************





!***************************************************************************************************
REAL(KIND(0.0D0))   FUNCTION J2(MUPUN)
IMPLICIT NONE
INTEGER                    ::I
REAL(KIND(0.0D0))          ::MUPUN,R,VAR

R=0.5D0*SQRT(MUPUN**2-4D0*MPI**2)
J2=0D0
DO I=1,NXP
  VAR=R*XP(I)/MPI
  IF (VAR .GE. 0.001D0) THEN
    J2=J2+(1D0/VAR**2-(1D0+1D0/VAR**2)**1.5D0*LOG(VAR+SQRT(1D0+VAR**2)))*XW(I)*XP(I)**2
  ELSE
    J2=J2+(-4D0/3D0-VAR**2/5D0+2D0*VAR**4/35D0-8D0*VAR**6/315D0)*XW(I)*XP(I)**2
  END IF
END DO
END FUNCTION J2
!***************************************************************************************************





!***************************************************************************************************
SUBROUTINE INFO(OSTAT,CUTNUMQ)
IMPLICIT NONE
INTEGER                    ::OSTAT,CUTNUMQ

WRITE(*,*)'*******************************************************************************************************'
SELECT CASE (OSTAT)
  CASE (0)
  WRITE(*,*)'   Semilocal momentum-space chiral NN potential with Roy-Steiner piN LECs at LO [Q^0]'
  CASE (1)
  WRITE(*,*)'   Semilocal momentum-space chiral NN potential with Roy-Steiner piN LECs at NLO [Q^2]'
  CASE (2)
  WRITE(*,*)'   Semilocal momentum-space chiral NN potential with Roy-Steiner piN LECs at N2LO [Q^3]'
  CASE (3)
  WRITE(*,*)'   Semilocal momentum-space chiral NN potential with Roy-Steiner piN LECs at N3LO [Q^4]'
  CASE (4)
  WRITE(*,*)'   Semilocal momentum-space chiral NN potential with Roy-Steiner piN LECs at N4LO [Q^5]'
  CASE (5)
  WRITE(*,*)'   Semilocal momentum-space chiral NN potential with Roy-Steiner piN LECs at N4LO [Q^5]'
  WRITE(*,*)'                                 + N5LO [Q^6] contacts in 3F2, 1F3, 3F3, 3F4'
  CASE DEFAULT
  WRITE(*,*)'   WRONG VALUE OF OSTAT!'
  STOP
END SELECT
SELECT CASE (CUTNUMQ)
  CASE (1)
  WRITE(*,*)'   Cutoff value: Lambda = 400 MeV'
  CASE (2)
  WRITE(*,*)'   Cutoff value: Lambda = 450 MeV'
  CASE (3)
  WRITE(*,*)'   Cutoff value: Lambda = 500 MeV'
  CASE (4)
  WRITE(*,*)'   Cutoff value: Lambda = 550 MeV'
  IF (OSTAT .EQ. 3) THEN
     WRITE(*,*)'   CAUTION: UNNATURALLY LARGE LEC D_3S1 SIGNALS THAT THE CUTOFF MAYBE TOO HIGH!!!'
  END IF
  CASE DEFAULT
  WRITE(*,*)'   WRONG VALUE OF CUTNUMQ!'
  STOP
END SELECT
WRITE(*,*)'*******************************************************************************************************'
END SUBROUTINE INFO
!***************************************************************************************************





!***************************************************************************************************
subroutine CreateCubicSpline(spl, x, y, n, m)
    ! Calculates the coefficients for a cubic spline interpolation. Inputs are:
    !      n      : the number of nodes
    !      m      : the number of functions for which the splines should be calculated
    !      x(n)   : the n nodes at which the original function was calculated
    !      y(n,m) : the function values at the n nodes for m functions
    ! The subroutine then returns spl(4,m,n) which contains the coefficients for the piece-wise
    ! defined polynomials of function j:
    ! f_i(x) = spl(1,j,i)*(x-x_i)**3 + spl(2,j,i)*(x-x_i)**2 + spl(3,j,i)*(x-x_i) + spl(4,j,i)
    ! The resulting spline is natural, meaning the second derivative vanishes at the end nodes
    integer, parameter                      :: wp = kind(1.0d0)
    integer, intent(in)                     :: n, m
    real(wp), dimension(n), intent(in)      :: x
    real(wp), dimension(n,m), intent(in)    :: y
    real(wp), dimension(4,m,n), intent(out) :: spl

    real(wp), dimension(n-1)    :: b, u, v, z
    integer :: i, j

    ! solve tridiagonal system of equations for the quadratic coefficient spl(2,j,i) for
    ! i = 2,..,n-1. The zeroth and nth coefficient are fixed at zero (natural spline).
    ! Note: It is possible to incorporate different boundary conditions with the same
    ! system of eq. if b(2) and b(n-1) are modified accordingly.

    ! Calculate v() and u() which are part of the LR decomposition of the system:
    v(1) = 2.0_wp*(x(3) - x(1))

    do i = 2, n-2
        u(i) = (x(i+1) - x(i)) / v(i-1)
        v(i) = 2.0_wp*(x(i+2) - x(i)) - u(i)*(x(i+1) - x(i))
    end do

    do j = 1, m
        do i = 2, n-1
            b(i) = 3.0_wp*((y(i+1,j)-y(i,j))/(x(i+1)-x(i)) - (y(i,j)-y(i-1,j))/(x(i)-x(i-1)))
        end do

        !forward substitution
        z(1) = b(2)
        do i = 2, n-2
            z(i) = b(i+1) - u(i)*z(i-1)
        end do

        ! backward substitution & calculation of spline coefficients
        spl(1,j,n) = 0.0_wp
        spl(2,j,n) = 0.0_wp
        spl(4,j,n) = y(n,j)

        do i = n-2, 1, -1
            spl(2,j,i+1) = (z(i) - (x(i+2)-x(i+1)) * spl(2,j,i+2)) / v(i)
            spl(1,j,i+1) = (spl(2,j,i+2) - spl(2,j,i+1)) / (3.0_wp * (x(i+2) - x(i+1)))
            spl(3,j,i+1) = (y(i+2,j)-y(i+1,j))/(x(i+2)-x(i+1)) - (spl(2,j,i+2) + 2.0_wp*spl(2,j,i+1))/3.0_wp * (x(i+2)-x(i+1))
            spl(4,j,i+1) = y(i+1,j)
        end do

        spl(2,j,1) = 0.0_wp
        spl(1,j,1) = (spl(2,j,2) - spl(2,j,1)) / (3.0_wp * (x(2) - x(1)))
        spl(3,j,1) = (y(2,j)-y(1,j))/(x(2)-x(1)) - (spl(2,j,2) + 2.0_wp*spl(2,j,1))/3.0_wp * (x(2)-x(1))
        spl(4,j,1) = y(1,j)

        ! calculate first derivate at end point for linear extrapolation
        spl(3,j,n) = (3.0_wp*spl(1,j,n-1)*(x(n)-x(n-1)) + 2.0_wp*spl(2,j,n-1))*(x(n)-x(n-1)) + spl(3,j,n-1)
    end do

end subroutine
!***************************************************************************************************





!***************************************************************************************************
subroutine SplineInterpolation(res, x, nodes, spl, n, m)
    ! Calculates the spline interpolation at point x with the coefficients prepared by CreateCubicSpline
    ! Inputs:
    !      x          : the point at which the spline should be evaluated
    !      n          : the number of nodes
    !      m          : the number of functions for which the spline should be calculated
    !      nodes(n)   : the n nodes at which the original function was calculated
    !      spl(4,m,n) : the spline coefficients returned by CreateCubicSpline
    ! The subroutine then returns res(m) which contains the spline interpolation for the m functions.
    ! If x lies outside of the node grid, a linear extrapolation from the outer nodes is calculated.
    integer, parameter                     :: wp = kind(1.0d0)
    real(wp), intent(in)                   :: x
    integer, intent(in)                    :: n, m
    real(wp), dimension(n), intent(in)     :: nodes
    real(wp), dimension(4,m,n), intent(in) :: spl
    real(wp), dimension(m), intent(out)    :: res
    integer :: low, high, mid
    real(wp) :: dx

    ! check if x lies within the nodes, extrapolate linearly otherwise
    if(x >= nodes(1) .and. x <= nodes(n)) then
        ! perform a binary search to get the interval of nodes in which x lies
        low = 1
        high = n

        do while((high - low) > 1)
            mid = (high + low) / 2

            if(nodes(mid) > x) then
                high = mid
            else
                low = mid
            end if
        end do
        ! now low & high are such that: nodes(low) <= x < nodes(high), high = low+1

        ! calculate interpolation polynomial
        dx = x - nodes(low)
        res = ((spl(1,:,low) * dx + spl(2,:,low)) * dx + spl(3,:,low)) * dx + spl(4,:,low)

    else if(x < nodes(1)) then
        ! extrapolate linearly to the left
        dx = x - nodes(1)
        res = spl(3,:,1) * dx + spl(4,:,1)
    else
        ! extrapolate linearly to the right
        dx = x - nodes(n)
        res = spl(3,:,n) * dx + spl(4,:,n)
    end if

end subroutine
!***************************************************************************************************





!***************************************************************************************************
SUBROUTINE TRNSCH(NP1,NP2,NP,P1,P2,P3,XP,AP)
!     ===============
!
!     TRNS BELEGT DIE FELDER XP UND AP MIT TRANSFORMIERTEN
!     GAUSS-LEGENDRE-PUNKTEN UND GEWICHTEN
!
!     NP1 PUNKTE WERDEN UEBER DIE HYPERBOLISCHE TRANSFORMATION
!
!     X --> (1.+X) / (1./P1-(1./P1-2./P2)*X)
!
!     AUF DAS INTERVALL (0.;P2) ABGEBILDET, WOBEI
!     NP1/2 PUNKTE IN (0.;P1) UND
!     NP1/2 PUNKTE IN (P1;P2) LIEGEN
!
!     NP2 PUNKTE WERDEN UEBER DIE LINEARE TRANSFORMATION
!
!     X --> (P3+P2)/2. + (P3-P2)/2.*X
!
!     AUF DAS INTERVALL (P2;P3) ABGEBILDET
!
!     NP = NP1 + NP2
!
      IMPLICIT NONE
      INTEGER NP,NP1,NP2,I
      REAL(KIND(0.0D0))  XP1(5000),AP1(5000),XP2(5000),AP2(5000)
      REAL(KIND(0.0D0))  XP(NP),AP(NP),P1,P2,P3,X,A
      REAL(KIND(0.0D0))  XX,DELPH

      IF(NP1.GT.5000) STOP 'NP1 in TRNS'
      IF(NP2.GT.5000) STOP 'NP2 in TRNS'

      CALL gaulegch(-1.0D0,1.0D0,XP1,AP1,NP1)

      DO 1 I=1,NP1
      X=XP1(I)
      A=AP1(I)
      XX=1D0/P1-(1D0/P1-2D0/P2)*X
      XP1(I)=(1D0+X) / XX
      AP1(I)=(2D0/P1-2D0/P2)*A / XX**2
1     CONTINUE
!
      IF(NP2 .NE. 0) THEN

      CALL gaulegch(-1.0D0,1.0D0,XP2,AP2,NP2)

      DO 2 I=1,NP2
      X=XP2(I)
      A=AP2(I)
      DELPH=(P3-P2)/2D0
      XP2(I)=(P3+P2)/2D0 + DELPH*X
      AP2(I)=DELPH*A
2     CONTINUE
      ENDIF
!
      DO 3 I=1,NP1
      XP(I)=XP1(I)
      AP(I)=AP1(I)
3     CONTINUE
!
      IF(NP2 .NE. 0) THEN
      DO 4 I=1,NP2
      XP(I+NP1)=XP2(I)
      AP(I+NP1)=AP2(I)
4     CONTINUE
      ENDIF
!
      RETURN
      END SUBROUTINE
!***************************************************************************************************





!***************************************************************************************************
      SUBROUTINE GAULEGCH(X1,X2,X,W,N)
      IMPLICIT NONE
      INTEGER N,M,I,J
      REAL(KIND(0.0D0)) X1,X2,X(N),W(N),EPS,XM,XL,Z,P1,P2,P3,PP,Z1
      PARAMETER (EPS=3.0D-14)
      M=(N+1)/2
      XM=0.5D0*(X2+X1)
      XL=0.5D0*(X2-X1)
      DO 12 I=1,M

        Z=COS(3.141592653589793238D0*(REAL(I,KIND(0.0D0))-0.25D0)/(REAL(N,KIND(0.0D0))+0.5D0))
1       CONTINUE
          P1=1D0
          P2=0D0
          DO 11 J=1,N
            P3=P2
            P2=P1
            P1=((2.0D0*J-1D0)*Z*P2-(J-1D0)*P3)/J
11        CONTINUE
          PP=N*(Z*P1-P2)/(Z*Z-1D0)
          Z1=Z
          Z=Z1-P1/PP
        IF(ABS(Z-Z1).GT.EPS)GO TO 1
        X(I)=XM-XL*Z
        X(N+1-I)=XM+XL*Z
        W(I)=2.0D0*XL/((1.0D0-Z*Z)*PP*PP)
        W(N+1-I)=W(I)
12    CONTINUE
      END SUBROUTINE GAULEGCH
!***************************************************************************************************






!***************************************************************************************************
SUBROUTINE PARCCH(POT,POTEN,JMOM)
IMPLICIT NONE
INTEGER                    ::K,JMOM
REAL(KIND(0.0D0))          ::SUM(6),POTEN(NZPUN),POT(6)
INTENT(IN)                 ::POTEN,JMOM
INTENT(OUT)                ::POT

SUM=0.0D0
IF (JMOM == 0) THEN
  DO K=1,NZPUN
    SUM(1)=SUM(1)+POTEN(K)*ZWEI(K)*PL(K)
    SUM(3)=SUM(3)+POTEN(K)*ZPUN(K)*ZWEI(K)*PL(K)
  END DO
ELSE
  DO K=1,NZPUN
    SUM(1)=SUM(1)+POTEN(K)*ZWEI(K)*PL(K)
    SUM(2)=SUM(2)+POTEN(K)*ZWEI(K)*PL(K)
    SUM(3)=SUM(3)+POTEN(K)*ZWEI(K)*PLP(K)
    SUM(4)=SUM(4)+POTEN(K)*ZWEI(K)*PLM(K)
  END DO
END IF
POT=2.0D0*PI*SUM
END SUBROUTINE PARCCH
!***************************************************************************************************





!***************************************************************************************************
SUBROUTINE PARSIGCH(POT,POTEN,JMOM)
IMPLICIT NONE
INTEGER                    ::K,JMOM
REAL(KIND(0.0D0))          ::SUM(6),POTEN(NZPUN),POT(6)
INTENT(IN)                 ::POTEN,JMOM
INTENT(OUT)                ::POT

SUM=0.0D0
IF(JMOM == 0) THEN
  DO K=1,NZPUN
    SUM(1)=SUM(1)-3.0D0*POTEN(K)*ZWEI(K)*PL(K)
    SUM(3)=SUM(3)+POTEN(K)*ZPUN(K)*ZWEI(K)*PL(K)
  END DO
ELSE
  DO K=1,NZPUN
    SUM(1)=SUM(1)-3.0D0*POTEN(K)*ZWEI(K)*PL(K)
    SUM(2)=SUM(2)+POTEN(K)*ZWEI(K)*PL(K)
    SUM(3)=SUM(3)+POTEN(K)*ZWEI(K)*PLP(K)
    SUM(4)=SUM(4)+POTEN(K)*ZWEI(K)*PLM(K)
  END DO
END IF
POT=2.0D0*PI*SUM
END SUBROUTINE PARSIGCH
!***************************************************************************************************





!***************************************************************************************************
SUBROUTINE PARSIGDCH(POT,POTEN,JMOM,QPUN,QPUNP)
IMPLICIT NONE
INTEGER                    ::K,L,JMOM
REAL(KIND(0.0D0))          ::SUM(6),POTEN(NZPUN),&
                             QPUN,QPUNP,POT(6),LLDUM
INTENT(IN)                 ::POTEN,JMOM,QPUN,QPUNP
INTENT(OUT)                ::POT

L=JMOM
SUM=0.0D0
IF (JMOM == 0) THEN
  DO K=1,NZPUN
      SUM(1)=SUM(1)+POTEN(K)*ZWEI(K)*(-QPUN**2-QPUNP**2+2.0D0*QPUN*QPUNP*&
           ZPUN(K))*PL(K)
      SUM(3)=SUM(3)-POTEN(K)*ZWEI(K)*((QPUN**2+QPUNP**2)*ZPUN(K)-2.0D0*QPUN*&
           QPUNP)*PL(K)
  END DO
ELSE
  DO K=1,NZPUN
        SUM(1)=SUM(1)+POTEN(K)*ZWEI(K)*(-QPUN**2-QPUNP**2+2.0D0*QPUN*QPUNP*&
           ZPUN(K))*PL(K)
        SUM(2)=SUM(2)+POTEN(K)*ZWEI(K)*((QPUN**2+QPUNP**2)*PL(K)-&
             2.0D0*QPUN*QPUNP/REAL(2*L+1,KIND(0.0D0))*(REAL(L,KIND(0.0D0))*PLP(K)+&
             REAL(L+1,KIND(0.0D0))*PLM(K)))
        SUM(3)=SUM(3)+POTEN(K)*ZWEI(K)/REAL(2*L+1,KIND(0.0D0))*(-(QPUN**2+QPUNP**2)*&
             PLP(K)+2.0D0*QPUN*QPUNP*PL(K))
        SUM(4)=SUM(4)+POTEN(K)*ZWEI(K)/REAL(2*L+1,KIND(0.0D0))*((QPUN**2+QPUNP**2)*&
             PLM(K)-2.0D0*QPUN*QPUNP*PL(K))
        LLDUM=REAL(L*(L+1),KIND(0.0D0))
        SUM(5)=SUM(5)+2.0D0*POTEN(K)*ZWEI(K)*SQRT(LLDUM)/&
             REAL(2*L+1,KIND(0.0D0))*(QPUNP**2*PLP(K)+&
             QPUN**2*PLM(K)-2.0D0*QPUN*QPUNP*PL(K))
        SUM(6)=SUM(6)+2.0D0*POTEN(K)*ZWEI(K)*SQRT(LLDUM)/&
             REAL(2*L+1,KIND(0.0D0))*(QPUNP**2*PLM(K)+&
             QPUN**2*PLP(K)-2.0D0*QPUN*QPUNP*PL(K))
  END DO
END IF
POT=2.0D0*PI*SUM
END SUBROUTINE PARSIGDCH
!***************************************************************************************************





!***************************************************************************************************
SUBROUTINE PARSLCH(POT,POTEN,JMOM,QPUN,QPUNP)
IMPLICIT NONE
INTEGER                    ::K,JMOM
REAL(KIND(0.0D0))          ::SUM(6),POTEN(NZPUN),&
                             QPUN,QPUNP,POT(6)
INTENT(IN)                 ::POTEN,JMOM,QPUN,QPUNP
INTENT(OUT)                ::POT

SUM=0.0D0
IF (JMOM == 0) THEN
  DO K=1,NZPUN
     SUM(3)=SUM(3)+POTEN(K)*QPUN*QPUNP*(ZPUN(K)**2-1.0D0)*ZWEI(K)*PL(K)
  END DO
ELSE
  DO K=1,NZPUN
    SUM(2)=SUM(2)+POTEN(K)*QPUNP*QPUN/REAL(2*JMOM+1,KIND(0.0D0))*ZWEI(K)*(PLP(K)-&
         PLM(K))
    SUM(3)=SUM(3)-POTEN(K)*QPUNP*QPUN*ZWEI(K)*(PL(K)-ZPUN(K)*PLP(K))
    SUM(4)=SUM(4)-POTEN(K)*QPUNP*QPUN*ZWEI(K)*(PL(K)-ZPUN(K)*PLM(K))
  END DO
END IF
POT=2.0D0*PI*SUM
END SUBROUTINE PARSLCH
!***************************************************************************************************





!***************************************************************************************************
REAL(KIND(0.0D0))   function plff(x,n)
!======================================
! calculates Legendre polynomials Pn(x)
! using the recurrence relation
! if n > 100 the function retuns 0.0
!======================================
double precision x
integer n, k
double precision pln(0:n)

pln(0) = 1.0

pln(0) = 1.0
if(n>0) then
 pln(1) = x
end if

if (n <= 1) then
  plff = pln(n)
  else
  do k=1,n-1
    pln(k+1) = ((2.0*k+1.0)*x*pln(k) - float(k)*pln(k-1))/(float(k+1))
  end do
  plff = pln(n)
end if
return
end function plff
!***************************************************************************************************
END MODULE SMSCHIRAL
