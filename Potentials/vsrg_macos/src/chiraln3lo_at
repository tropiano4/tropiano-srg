!***************************************************************************
!***************************************************************************
!**                                                                       **
!**      This is the final version of the chiral routine                  **
!**         E.Epelbaum, 02.05.04                                          **
!**                                                                       **
!**                                                                       **
!**  This is the routine for calculating matrix elements of the chiral    **
!**  NLO, NNLO and NNNLO NN potentials with the new cut-off               **
!**  regularization of chiral loops.                                      **
!**                                                                       **
!**  The INPUT parameters are OSTAT, FORCE, REL, QPUN1, QPUN2, JMOM       **
!**  and  CUTNUM.                                                         **
!**  OSTAT, REL, JMOM, CUTNUM are of the type INTEGER; QPUN1, QPUN2,      **
!**  POTENT are  REAL and should be declared in the calling program as    **
!**  REAL with at least 15 significant decimal digits and permiting       **
!**  an exponent between at least 10**-99 and 10**99. If a calling        **
!**  program is written in FORTRAN 77, these variables must be            **
!**  DOUBLE PRECISION on an IBM and SINGLE PRECISION on a CRAY.           **
!**                                                                       **
!**  The input parameter FORCE is of type character. It takes the values  ** 
!**  'nn', 'np', 'pp' depending on the kind of system to be considered.   **                     
!**                                                                       **
!**  The parameter OSTAT defines the chiral order:                        **
!**       OSTAT=0:       NLO                                              **
!**       OSTAT=1:       NNLO                                             **
!**       OSTAT=2:       NNNLO                                            **
!**                                                                       **
!**  The parameter REL is only active at NNNLO and specifies the kind of  **
!**  the NN Schroedinger/Lippmann-Schwinger equation to be solved. REL=0  **
!**  leads to the potential for the usual non-relativistic LS equation,   **
!**  while REL=1 corresponds to the non-relativistic-like equation        **
!**  with relativistic kinematics (see e.g. J.L.Friar, PRC 60 (1999)      **
!**  034002). REL=2 leads to the potential to be used in the              **
!**  relativistic LS equation. For details see our NNNLO paper.           **
!**                                                                       **
!**  QPUN1 and QPUN2 are the final and initial center-of-mass momenta of  **
!**  the nucleons in MeV. (We use the convention: the speed of light = 1) **
!**                                                                       **
!**  The value of the variable CUTNUM defines the cut-off used in the LS  **
!**  equation and in the spectral-function representation (SFR) of the    **
!**  two--pion exchange potential.                                        **
!**  The SFR cut-off is varied between 500 and 700 MeV.                   **
!**  The largest possible value of the LS cut-off (i.e. the value of the  **
!**  cut-off which still leads to LECs of natural size) depends on the    **
!**  chiral order. The following choices are available:                   **
!**  1) NLO (OSTAT=0):                                                    **
!**      CUTNUM         LS cut-off       SFR cut-off                      **
!**        1             400 MeV           500 MeV                        **
!**        2             550 MeV           500 MeV                        **
!**        3             550 MeV           600 MeV                        **
!**        4             400 MeV           700 MeV                        **
!**        5             550 MeV           700 MeV                        **
!**  2) NNLO (OSTAT=1):                                                   **
!**      CUTNUM         LS cut-off       SFR cut-off                      **
!**        1             450 MeV           500 MeV                        **
!**        2             600 MeV           500 MeV                        **
!**        3             550 MeV           600 MeV                        **
!**        4             450 MeV           700 MeV                        **
!**        5             600 MeV           700 MeV                        **
!**  3) NNNLO (OSTAT=2):                                                  **
!**      CUTNUM         LS cut-off       SFR cut-off                      **
!**        1             450 MeV           500 MeV                        **
!**        2             600 MeV           600 MeV                        **
!**        3             550 MeV           600 MeV                        **
!**        4             450 MeV           700 MeV                        **
!**        5             600 MeV           700 MeV                        **
!**  The choice CUTNUM=3 gives the same cut-off combinaton for NLO, NNLO  **
!**  and NNNLO.                                                           **
!**                                                                       **
!**  The total angular momentum JMOM should not extend 8.                 **
!**                                                                       **
!**  The OUTPUT vector POTENT contains 6 elements corresponding to all    **
!**  possible values of S, L1, L2 of the matrix element                   **
!**  <L1,S,J; QPUN1 | V | L2,S,J; QPUN2>  with a fixed value of the       **
!**  angular momentum J:                                                  **
!**         POTENT(1):       S=0, L1=L2=J                                 **
!**         POTENT(2):       S=1, L1=L2=J                                 **
!**         POTENT(3):       S=1, L1=L2=J-1                               **
!**         POTENT(4):       S=1, L1=J-1, L2=J+1                          **
!**         POTENT(5):       S=1, L1=J+1, L2=J-1                          **
!**         POTENT(6):       S=1, L1=L2=J+1                               **
!**                                                                       **
!**  The potential is calculated in MeV^(-2).                             **
!**  The calculated matrix elements of the potential can be used in       **
!**  the Lippmann-Schwinger equation (relativistic or non-relativistic)   **
!**  expressed (symbolically) in the following form:                      **
!**             T = V + 2/PI V G_0 T                                      **
!**  NOTICE: at NNNLO REL=1 and REL=2 lead to the same results.           **
!**  REL=0 only leads to the same results in the c.m.s. but not in the    **
!**  lab system. See our NNNLO paper for more details.                    **
!**                                                                       **
!**  We have taken into account isospin violating effects due to the      **
!**  pion mass differences in the OPE. Other CIB and CSB effects are not  **
!**  considered.                                                          **
!**                                                                       **
!**  At NNNLO the magnetic moment interaction may be taken into account   **
!**  for np-force in the deuteron channel. It is currently switched off.  **
!**  To switch it on remove the commentary signsin the subroutine CHIRAL  **
!**  between:                                                             **
!**  "!***** Megnetic moment interaction in the 3S1-3D1 channel *****"    **
!**  and "!**********************************************************".   **
!**                                                                       **
!**  It is not recommended to use this routine for calculation of         **
!**  observables (in particular, phase shifts) at energies below          **
!**  1 MeV. In that case large numerical errors may appear.               **
!**                                                                       **
!***************************************************************************  
!***************************************************************************




MODULE PARAMETERS
IMPLICIT NONE
INTEGER, PARAMETER         ::DPP = SELECTED_REAL_KIND(15,99)
REAL(KIND=DPP)             ::MPI,MPICH,MPIN,MN,MP,FFAK,PI,FPI,GA,FAKVCC,FAKVCT,FAKREL,MMM,&
                             LAM,CUTPOT,XX       
PARAMETER                   (MPICH=0.1395702_DPP,MPIN=0.1349766_DPP,&
                             MPI=2.0_DPP*MPICH/3.0_DPP+MPIN/3.0_DPP,&
                             MN=0.9395653_DPP,MP=0.9382720_DPP,MMM=2.0_DPP*MP*MN/(MP+MN),&
                             FFAK=0.197327053_DPP,FPI=0.0924_DPP,GA=1.29_DPP,CUTPOT=6.0_DPP,&   
                             PI=3.141592653589793238_DPP,FAKVCC=-3.0_DPP/(16.0_DPP*PI**2*FPI**4),&
                             FAKVCT=-1.0_DPP/(96.0_DPP*PI**2*FPI**4),&
                             FAKREL=1.0_DPP/(192.0_DPP*PI**2*MMM*FPI**4))


CONTAINS

SUBROUTINE VMAGMOM(QQPUN1,QQPUN2,VMM1,VMP1,VPM1,VPP1)
IMPLICIT NONE
INTEGER, PARAMETER         ::DPP = SELECTED_REAL_KIND(15,99)
REAL(KIND=DPP)             ::QQPUN1,QQPUN2,VMM1,VMP1,VPM1,VPP1,ALPHA,BET,GAM,KAPPAP,KAPPAN
PARAMETER                   (ALPHA=1.0_DPP/137.036_DPP,KAPPAP=1.792847_DPP,&
                             KAPPAN=-1.913043_DPP)

! QQPUN1    and   QQPUN2  in GeV !!!
! the potential is NOT multiplied with  the regulating function !!!

BET=ALPHA*KAPPAN*(1.0_DPP+KAPPAP)/(4.0_DPP*MN*MP*(4.0_DPP*PI))
GAM=-ALPHA*KAPPAN/(MN*MMM*(4.0_DPP*PI))
VMM1=4.0_DPP/3.0_DPP*PI*BET/1000000.0_DPP
IF (ABS(QQPUN1-QQPUN2) .GE. 0.000001_DPP) THEN
   IF (QQPUN2/QQPUN1 .LE. 0.01_DPP) THEN
      XX=QQPUN2/QQPUN1
      VPP1=-8.0_DPP/315.0_DPP*(2.0_DPP*BET-3.0_DPP*GAM)*PI*XX**2*(-21.0_DPP+6.0_DPP*XX**2+XX**4)/1000000.0_DPP
      VMP1=8.0_DPP/315.0_DPP*DSQRT(2.0_DPP)*BET*PI*XX**2*(21.0_DPP+3.0_DPP*XX**2+XX**4)/1000000.0_DPP
      VPM1=8.0_DPP/105.0_DPP*DSQRT(2.0_DPP)*BET*PI*(35.0_DPP-35.0_DPP*XX**2+7.0_DPP*XX**4+XX**6)/1000000.0_DPP
   ELSE
      IF (QQPUN1/QQPUN2 .LE. 0.01_DPP) THEN
         XX=QQPUN1/QQPUN2
         VPP1=-8.0_DPP/315.0_DPP*(2.0_DPP*BET-3.0_DPP*GAM)*PI*XX**2*(-21.0_DPP+6.0_DPP*XX**2+XX**4)/1000000.0_DPP
         VMP1=8.0_DPP/105.0_DPP*DSQRT(2.0_DPP)*BET*PI*(35.0_DPP-35.0_DPP*XX**2+7.0_DPP*XX**4+XX**6)/1000000.0_DPP
         VPM1=8.0_DPP/315.0_DPP*DSQRT(2.0_DPP)*BET*PI*XX**2*(21.0_DPP+3.0_DPP*XX**2+XX**4)/1000000.0_DPP
      ELSE
         VPP1=PI/(8.0_DPP*QQPUN1**3*QQPUN2**3)*(BET/3.0_DPP-GAM/2.0_DPP)*&
              (4.0_DPP*(3.0_DPP*QQPUN1**5*QQPUN2-2.0_DPP*QQPUN1**3*QQPUN2**3+3.0_DPP*QQPUN1*QQPUN2**5)+&
              3.0_DPP*(QQPUN1**2-QQPUN2**2)**2*(QQPUN1**2+QQPUN2**2)*&
              DLOG((QQPUN1-QQPUN2)**2/(QQPUN1+QQPUN2)**2))/1000000.0_DPP
         VMP1=PI*BET/(6.0_DPP*SQRT(2.0_DPP)*QQPUN1*QQPUN2**3)*(-12.0_DPP*QQPUN1**3*QQPUN2+20.0_DPP*QQPUN1*QQPUN2**3+&
              3.0_DPP*(QQPUN1**2-QQPUN2**2)**2*DLOG((QQPUN1+QQPUN2)**2/(QQPUN1-QQPUN2)**2))/1000000.0_DPP
         VPM1=PI*BET/(6.0_DPP*SQRT(2.0_DPP)*QQPUN2*QQPUN1**3)*(-12.0_DPP*QQPUN2**3*QQPUN1+20.0_DPP*QQPUN2*QQPUN1**3+&
              3.0_DPP*(QQPUN2**2-QQPUN1**2)**2*DLOG((QQPUN2+QQPUN1)**2/(QQPUN2-QQPUN1)**2))/1000000.0_DPP
      END IF
   END IF
ELSE
   VPP1=PI/(8.0_DPP*QQPUN1**3*QQPUN2**3)*(BET/3.0_DPP-GAM/2.0_DPP)*&
        (4.0_DPP*(3.0_DPP*QQPUN1**5*QQPUN2-2.0_DPP*QQPUN1**3*QQPUN2**3+3.0_DPP*QQPUN1*QQPUN2**5))/1000000.0_DPP
   VPM1=PI*BET/(6.0_DPP*SQRT(2.0_DPP)*QQPUN1*QQPUN2**3)*(-12.0_DPP*QQPUN1**3*QQPUN2+20.0_DPP*QQPUN1*QQPUN2**3)&
        /1000000.0_DPP
   VMP1=PI*BET/(6.0_DPP*SQRT(2.0_DPP)*QQPUN2*QQPUN1**3)*(-12.0_DPP*QQPUN2**3*QQPUN1+20.0_DPP*QQPUN2*QQPUN1**3)&
        /1000000.0_DPP
END IF

END SUBROUTINE VMAGMOM

END MODULE PARAMETERS




MODULE LEC
IMPLICIT NONE
INTEGER, PARAMETER         ::DPP = SELECTED_REAL_KIND(15,99)
REAL(KIND=DPP)             ::D14M15,D1P2,D3,D5,D18,C1,C2,C3,C4

PARAMETER                   (D14M15=-5.65_DPP,D1P2=3.06_DPP,D3=-3.27_DPP,D5=0.45_DPP,&
                             D18=0.0_DPP,C1=-0.81_DPP,C2=3.28_DPP,C3=-3.4_DPP,C4=3.40_DPP)

END MODULE LEC




MODULE INTX
IMPLICIT NONE
INTEGER, PARAMETER         ::DPP = SELECTED_REAL_KIND(15,99)
INTEGER                    ::NINT1,NINT2,NINT
REAL(KIND=DPP)             ::LAMINT1,LAMINT2,LAMINT3,DELINT
PARAMETER                    (NINT1=64,NINT2=64,NINT=NINT1+NINT2,&
                              LAMINT1=0.05_DPP,LAMINT2=0.2_DPP,LAMINT3=1.0_DPP)
END MODULE INTX



MODULE INTMU
IMPLICIT NONE
INTEGER, PARAMETER         ::DPP = SELECTED_REAL_KIND(15,99)
INTEGER                    ::NMU1,NMU2,NMU
REAL(KIND=DPP)             ::LAMMU1,LAMMU2
PARAMETER                    (NMU1=64,NMU2=64,NMU=NMU1+NMU2,&
                              LAMMU1=0.4_DPP,LAMMU2=0.49_DPP)
END MODULE INTMU



MODULE TPEN3LO
IMPLICIT NONE
INTEGER, PARAMETER         ::DPP = SELECTED_REAL_KIND(15,99)
INTEGER                    ::NQV1,NQV2,NQV3,NQV
REAL(KIND=DPP)             ::LAMQV1,LAMQV2,LAMQV3
PARAMETER                    (NQV1=64,NQV2=64,NQV3=250,NQV=NQV1+NQV2+NQV3,&
                              LAMQV1=0.2_DPP,LAMQV2=0.7_DPP,LAMQV3=2.7_DPP)
REAL(KIND=DPP)             ::VCQ(NQV),WSQ(NQV),VS1Q(NQV),VS2Q(NQV),&
                             WC1Q(NQV),WC2Q(NQV),WC3Q(NQV),WC4Q(NQV),&
                             WTQ(NQV),VT1Q(NQV),VT2Q(NQV),&
                             QV(NQV),SPL(NQV),&
                             FFAK1(NQV,NQV),FFAK2(NQV,NQV),FFAK3(NQV,NQV)
END MODULE TPEN3LO





MODULE chiral_n3lo
PRIVATE
PUBLIC::chiral
CONTAINS

SUBROUTINE CHIRAL(OSTAT,FORCE,REL,QPUN1,QPUN2,JMOM,CUTNUM,POTENT)
!in this routine the potential for REL=1 is calculated and the MM interaction is added

USE PARAMETERS
USE LEC

IMPLICIT NONE

INTEGER                    ::I,OSTAT,JMOM,CUTNUM,REL,NKN,NIN1,NIN2,NIN,NN1,NN2,NN1P,NN2P,NFIN,NFINP
INTEGER, PARAMETER         ::DP = SELECTED_REAL_KIND(15,99)
INTEGER                    ::OSTATFIR,RELFIR,CUTNUMFIR
PARAMETER                    (NKN=200,NIN1=30,NIN2=18,NIN=NIN1+NIN2)
REAL(KIND=DP)              ::QPUN1,QPUN2,POTENT(6),CUTFAC,QKN(0:8,NKN),&
                             QIN(NIN),WIN(NIN),PKN(0:8,6,NKN,NIN),LAMIN1,LAMIN2,LAMIN3,MMMM,&
                             WURQPUN1,WURQPUN2,POTENTT(6),VMM,VMP,VPM,VPP,CUTVAL
PARAMETER                    (LAMIN1=200.0_DP,LAMIN2=650.0_DP,LAMIN3=1600.0_DP)
CHARACTER(len=2)           ::FORCE,FORCEFIR
LOGICAL                    ::FIRST1

DATA                          FIRST1/.FALSE./

SAVE                         FIRST1,QIN,WIN,PKN,MMMM,QKN,OSTATFIR,CUTNUMFIR,FORCEFIR,RELFIR

COMMON/CUTVAL/               CUTVAL

!sEXTERNAL                     SELECTION



IF (FIRST1) THEN 
  IF (OSTAT .NE. OSTATFIR) THEN
    FIRST1=.FALSE.
  END IF
  IF (CUTNUM .NE. CUTNUMFIR) THEN
    FIRST1=.FALSE.
  END IF
  IF (FORCE .NE. FORCEFIR) THEN
    FIRST1=.FALSE.
  END IF
  IF (REL .NE. RELFIR) THEN
    FIRST1=.FALSE.
  END IF
END IF


IF (.NOT. FIRST1) THEN 
   OSTATFIR=OSTAT
   CUTNUMFIR=CUTNUM
   FORCEFIR=FORCE
   RELFIR=REL
   CALL TRNSMOD1(NIN1,NIN2,NIN,LAMIN1,LAMIN2,LAMIN3,QIN,WIN)
   QKN=0.0_DP
   SELECT CASE (FORCE)
   CASE ('nn')
      MMMM=MN*1000.0_DP
   CASE ('np')
      MMMM=MMM*1000.0_DP
   CASE ('pp')
      MMMM=MP*1000.0_DP
   CASE DEFAULT
      WRITE(*,*)'wrong value of FORCE'
      STOP
   END SELECT
   FIRST1=.TRUE.
END IF


CALL CHIRALPROM(OSTAT,FORCE,REL,QPUN1,QPUN2,JMOM,CUTNUM,POTENT)

IF (REL .EQ. 1 .AND. OSTAT .EQ. 2) THEN
   CALL SELECTION(QPUN1,JMOM,QKN,NKN,NN1,NN2)
   IF (NN1 .EQ. 0) THEN
      DO I=1,NIN
         CALL CHIRALPROM(OSTAT,FORCE,REL,QPUN1,QIN(I),JMOM,CUTNUM,POTENTT)
         PKN(JMOM,1,NN2,I)=POTENTT(1)
         PKN(JMOM,2,NN2,I)=POTENTT(2)
         PKN(JMOM,3,NN2,I)=POTENTT(3)
         PKN(JMOM,4,NN2,I)=POTENTT(4)
         PKN(JMOM,5,NN2,I)=POTENTT(5)
         PKN(JMOM,6,NN2,I)=POTENTT(6)
      END DO
      NFIN=NN2
   ELSE
      NFIN=NN1
   END IF
   CALL SELECTION(QPUN2,JMOM,QKN,NKN,NN1P,NN2P)
   IF (NN1P .EQ. 0) THEN
      DO I=1,NIN
         CALL CHIRALPROM(OSTAT,FORCE,REL,QPUN2,QIN(I),JMOM,CUTNUM,POTENTT)
         PKN(JMOM,1,NN2P,I)=POTENTT(1)
         PKN(JMOM,2,NN2P,I)=POTENTT(2)
         PKN(JMOM,3,NN2P,I)=POTENTT(3)
         PKN(JMOM,4,NN2P,I)=POTENTT(4)
         PKN(JMOM,5,NN2P,I)=POTENTT(5)
         PKN(JMOM,6,NN2P,I)=POTENTT(6)
      END DO
      NFINP=NN2P
   ELSE
      NFINP=NN1P
   END IF
   WURQPUN1=DSQRT(QPUN1**2+MMMM**2)
   WURQPUN2=DSQRT(QPUN2**2+MMMM**2)
   POTENT=(WURQPUN1+WURQPUN2)*POTENT/(2.0_DP*MMMM)
   DO I=1,NIN
      POTENT(1)=POTENT(1)+QIN(I)**2*WIN(I)/(2.0_DP*PI*MMMM)*PKN(JMOM,1,NFIN,I)*PKN(JMOM,1,NFINP,I)
      POTENT(2)=POTENT(2)+QIN(I)**2*WIN(I)/(2.0_DP*PI*MMMM)*PKN(JMOM,2,NFIN,I)*PKN(JMOM,2,NFINP,I)
      POTENT(3)=POTENT(3)+QIN(I)**2*WIN(I)/(2.0_DP*PI*MMMM)*(PKN(JMOM,3,NFIN,I)*PKN(JMOM,3,NFINP,I)+&
           PKN(JMOM,4,NFIN,I)*PKN(JMOM,4,NFINP,I))
      POTENT(4)=POTENT(4)+QIN(I)**2*WIN(I)/(2.0_DP*PI*MMMM)*(PKN(JMOM,4,NFIN,I)*PKN(JMOM,6,NFINP,I)+&
           PKN(JMOM,3,NFIN,I)*PKN(JMOM,5,NFINP,I))
      POTENT(5)=POTENT(5)+QIN(I)**2*WIN(I)/(2.0_DP*PI*MMMM)*(PKN(JMOM,5,NFIN,I)*PKN(JMOM,3,NFINP,I)+&
           PKN(JMOM,6,NFIN,I)*PKN(JMOM,4,NFINP,I))
      POTENT(6)=POTENT(6)+QIN(I)**2*WIN(I)/(2.0_DP*PI*MMMM)*(PKN(JMOM,6,NFIN,I)*PKN(JMOM,6,NFINP,I)+&
           PKN(JMOM,5,NFIN,I)*PKN(JMOM,5,NFINP,I))
   END DO
END IF

!***** Megnetic moment interaction in the 3S1-3D1 channel *********************
!IF (FORCE .EQ. 'np' .AND. OSTAT .EQ. 2 .AND. JMOM .EQ. 1&                   !**
!       .AND. QPUN1/1000.0_DP/CUTVAL .LE. 2.0_DP&                            !**
!       .AND. QPUN2/1000.0_DP/CUTVAL .LE. 2.0_DP) THEN                       !**
!   CUTFAC=EXP(-(QPUN1/1000.0_DP)**CUTPOT/CUTVAL**CUTPOT-&                   !**
!        (QPUN2/1000.0_DP)**CUTPOT/CUTVAL**CUTPOT)                           !**
!   CALL VMAGMOM(QPUN1/1000.0_DP,QPUN2/1000.0_DP,VMM,VMP,VPM,VPP)            !**
!   POTENT(3)=POTENT(3)+VMM*CUTFAC                                           !**
!   POTENT(4)=POTENT(4)+VMP*CUTFAC                                           !**
!   POTENT(5)=POTENT(5)+VPM*CUTFAC                                           !**
!   POTENT(6)=POTENT(6)+VPP*CUTFAC                                           !**
!END IF                                                                      !**
!******************************************************************************

END SUBROUTINE CHIRAL






SUBROUTINE SELECTION(QPUN,JMOM,QKN,NKN,NN1,NN2)
IMPLICIT NONE

! This routine checks whether QPUN matches with any of the QKN elements and returns the number
! NN1 of the corresponding element. NN1=0 if unmatched. In that case NN2 gives the number 
! of QKN-elements which are different from 0. Otherwise NN2=0. 

INTEGER                    ::NKN,NN1,NN2,I,JMOM
INTEGER, PARAMETER         ::DP = SELECTED_REAL_KIND(15,99)
REAL(KIND=DP)              ::QPUN,QKN(0:8,NKN)

INTENT(IN)                 ::QPUN,NKN,JMOM
INTENT(OUT)                ::NN1,NN2

NN1=0
NN2=0

DO I=1,NKN
   IF (ABS(QKN(JMOM,I)) .LE. 0.0000000000001_DP) THEN
      QKN(JMOM,I)=QPUN
      NN2=I
      EXIT
   END IF
   IF (ABS(QPUN-QKN(JMOM,I)) .LE. 0.0000000000001_DP) THEN
      NN1=I
      EXIT
   END IF
END DO

END SUBROUTINE SELECTION






SUBROUTINE CHIRALPROM(OSTAT,FORCE,REL,QPUN1,QPUN2,JMOM,CUTNUM,POTENT)
!in this routine the small Q,Q' behaviour of the potential is corrected


IMPLICIT NONE

INTEGER                    ::I,L(6),LP(6),OSTAT,JMOM,CUTNUM,REL
INTEGER, PARAMETER         ::DP = SELECTED_REAL_KIND(15,99)
REAL(KIND=DP)              ::QPUN1,QPUN2,POTENT(6),BESCHRL(0:8,6),BESCHRP(0:8,6),POTPR1(6),&
                             POTPR2(6),POTPR3(6),POTPR4(6),QQPP1,QQPP2,QQPP3,QQPP4,&
                             PROML1(0:8,6),PROMP1(0:8,6)
CHARACTER(len=2)           ::FORCE

INTENT(IN)                 ::OSTAT,FORCE,REL,QPUN1,QPUN2,JMOM,CUTNUM
INTENT(OUT)                ::POTENT  

DATA                  PROMP1/ 0.03_DP,     0.20_DP,    4.0_DP,     6.0_DP,   10.0_DP,    20.0_DP, &
                              30.0_DP,     50.0_DP,    60.0_DP,&
                              0.0_DP,      0.20_DP,    4.0_DP,     6.0_DP,   10.0_DP,    20.0_DP, &
                              30.0_DP,     50.0_DP,    60.0_DP,&
                              0.0_DP,      0.03_DP,    4.0_DP,     6.0_DP,   10.0_DP,    20.0_DP, &
                              30.0_DP,     50.0_DP,    60.0_DP,&
                              0.0_DP,      1.5_DP,     4.0_DP,     6.0_DP,   10.0_DP,   20.0_DP, &
                              30.0_DP,     50.0_DP,    60.0_DP,&
                              0.0_DP,      0.001_DP,   6.0_DP,     6.0_DP,   10.0_DP,    20.0_DP, &
                              30.0_DP,     50.0_DP,    20.0_DP,&
                              0.2_DP,      1.5_DP,     4.0_DP,     6.0_DP,   10.0_DP,   20.0_DP, &
                              30.0_DP,     50.0_DP,    60.0_DP /

DATA                  PROML1/ 0.03_DP,    0.20_DP,     4.0_DP,     6.0_DP,    10.0_DP,   20.0_DP, &
                              30.0_DP,     50.0_DP,    60.0_DP,&
                              0.0_DP,      0.20_DP,    4.0_DP,     6.0_DP,    10.0_DP,   20.0_DP, &
                              30.0_DP,     50.0_DP,    60.0_DP,&
                              0.0_DP,      0.03_DP,    4.0_DP,     6.0_DP,    10.0_DP,   20.0_DP, &
                              30.0_DP,     50.0_DP,    60.0_DP,&
                              0.0_DP,      0.001_DP,   4.0_DP,     6.0_DP,    10.0_DP,   20.0_DP, &
                              30.0_DP,     50.0_DP,    60.0_DP,&
                              0.0_DP,      1.5_DP,     4.0_DP,     6.0_DP,    10.0_DP,  20.0_DP, &
                              30.0_DP,     50.0_DP,    60.0_DP,&
                              0.2_DP,      1.5_DP,     4.0_DP,     6.0_DP,    10.0_DP,  20.0_DP, &
                              30.0_DP,     50.0_DP,    60.0_DP /

!s EXTERNAL                     CHIRALOLD

L(1)=JMOM
L(2)=JMOM
L(3)=JMOM-1
L(4)=JMOM-1
L(5)=JMOM+1
L(6)=JMOM+1
LP(1)=JMOM
LP(2)=JMOM
LP(3)=JMOM-1
LP(4)=JMOM+1
LP(5)=JMOM-1
LP(6)=JMOM+1


CALL CHIRALOLD(OSTAT,FORCE,REL,QPUN1,QPUN2,JMOM,CUTNUM,POTENT)

BESCHRL=PROML1
BESCHRP=PROMP1


 
IF (JMOM .LE. 1) THEN
   DO I=1,6
      IF ((JMOM .NE. 0) .OR. ((JMOM == 0) .AND. ((I == 1) .OR. (I == 6)))) THEN
         IF (QPUN1 < BESCHRL(JMOM,I) .AND. (QPUN2 .GE. BESCHRP(JMOM,I))) THEN
            QQPP1=BESCHRL(JMOM,I)
            QQPP2=BESCHRL(JMOM,I)*1.2_DP
            CALL CHIRALOLD(OSTAT,FORCE,REL,QQPP1,QPUN2,JMOM,CUTNUM,POTPR1)
            CALL CHIRALOLD(OSTAT,FORCE,REL,QQPP2,QPUN2,JMOM,CUTNUM,POTPR2)
            POTENT(I)=((POTPR1(I)*QQPP2**(L(I)+2)-POTPR2(I)*QQPP1**(L(I)+2))*QPUN1**L(I)-&
                 (POTPR1(I)*QQPP2**L(I)-POTPR2(I)*QQPP1**L(I))*QPUN1**(L(I)+2))/&
                 ((QQPP1*QQPP2)**L(I)*(QQPP2**2-QQPP1**2))
         ELSE
            IF (QPUN1 .GE. BESCHRL(JMOM,I) .AND. (QPUN2 < BESCHRP(JMOM,I))) THEN
               QQPP1=BESCHRP(JMOM,I)
               QQPP2=BESCHRP(JMOM,I)*1.2_DP
               CALL CHIRALOLD(OSTAT,FORCE,REL,QPUN1,QQPP1,JMOM,CUTNUM,POTPR1)
               CALL CHIRALOLD(OSTAT,FORCE,REL,QPUN1,QQPP2,JMOM,CUTNUM,POTPR2)
               POTENT(I)=((POTPR1(I)*QQPP2**(LP(I)+2)-POTPR2(I)*QQPP1**(LP(I)+2))*QPUN2**LP(I)-&
                    (POTPR1(I)*QQPP2**LP(I)-POTPR2(I)*QQPP1**LP(I))*QPUN2**(LP(I)+2))/&
                    ((QQPP1*QQPP2)**LP(I)*(QQPP2**2-QQPP1**2))
            ELSE
               IF (QPUN1 < BESCHRL(JMOM,I) .AND. (QPUN2 < BESCHRP(JMOM,I))) THEN
                  QQPP1=BESCHRL(JMOM,I)
                  QQPP2=BESCHRL(JMOM,I)*1.2_DP
                  QQPP3=BESCHRP(JMOM,I)
                  QQPP4=BESCHRP(JMOM,I)*1.2_DP
                  CALL CHIRALOLD(OSTAT,FORCE,REL,QQPP1,QQPP3,JMOM,CUTNUM,POTPR1)
                  CALL CHIRALOLD(OSTAT,FORCE,REL,QQPP2,QQPP3,JMOM,CUTNUM,POTPR2)
                  CALL CHIRALOLD(OSTAT,FORCE,REL,QQPP1,QQPP4,JMOM,CUTNUM,POTPR3)
                  CALL CHIRALOLD(OSTAT,FORCE,REL,QQPP2,QQPP4,JMOM,CUTNUM,POTPR4)
                  POTPR1(I)=((POTPR1(I)*QQPP2**(L(I)+2)-POTPR2(I)*QQPP1**(L(I)+2))*QPUN1**L(I)-&
                       (POTPR1(I)*QQPP2**L(I)-POTPR2(I)*QQPP1**L(I))*QPUN1**(L(I)+2))/&
                       ((QQPP1*QQPP2)**L(I)*(QQPP2**2-QQPP1**2))
                  POTPR2(I)=((POTPR3(I)*QQPP2**(L(I)+2)-POTPR4(I)*QQPP1**(L(I)+2))*QPUN1**L(I)-&
                       (POTPR3(I)*QQPP2**L(I)-POTPR4(I)*QQPP1**L(I))*QPUN1**(L(I)+2))/&
                       ((QQPP1*QQPP2)**L(I)*(QQPP2**2-QQPP1**2))
                  POTENT(I)=((POTPR1(I)*QQPP4**(LP(I)+2)-POTPR2(I)*QQPP3**(LP(I)+2))*QPUN2**LP(I)-&
                       (POTPR1(I)*QQPP4**LP(I)-POTPR2(I)*QQPP3**LP(I))*QPUN2**(LP(I)+2))/&
                       ((QQPP3*QQPP4)**LP(I)*(QQPP4**2-QQPP3**2))
               END IF
            END IF
         END IF
      END IF
   END DO
ELSE
   IF (QPUN1 < BESCHRL(JMOM,1) .AND. (QPUN2 .GE. BESCHRP(JMOM,1))) THEN
      QQPP1=BESCHRL(JMOM,1)
      QQPP2=BESCHRL(JMOM,1)*1.2_DP
      CALL CHIRALOLD(OSTAT,FORCE,REL,QQPP1,QPUN2,JMOM,CUTNUM,POTPR1)
      CALL CHIRALOLD(OSTAT,FORCE,REL,QQPP2,QPUN2,JMOM,CUTNUM,POTPR2)
      DO I=1,6
         POTENT(I)=((POTPR1(I)*QQPP2**(L(I)+2)-POTPR2(I)*QQPP1**(L(I)+2))*QPUN1**L(I)-&
              (POTPR1(I)*QQPP2**L(I)-POTPR2(I)*QQPP1**L(I))*QPUN1**(L(I)+2))/&
              ((QQPP1*QQPP2)**L(I)*(QQPP2**2-QQPP1**2))
      END DO
   ELSE
      IF (QPUN1 .GE. BESCHRL(JMOM,1) .AND. (QPUN2 < BESCHRP(JMOM,1))) THEN
         QQPP1=BESCHRP(JMOM,1)
         QQPP2=BESCHRP(JMOM,1)*1.2_DP
         CALL CHIRALOLD(OSTAT,FORCE,REL,QPUN1,QQPP1,JMOM,CUTNUM,POTPR1)
         CALL CHIRALOLD(OSTAT,FORCE,REL,QPUN1,QQPP2,JMOM,CUTNUM,POTPR2)
         DO I=1,6
            POTENT(I)=((POTPR1(I)*QQPP2**(LP(I)+2)-POTPR2(I)*QQPP1**(LP(I)+2))*QPUN2**LP(I)-&
                 (POTPR1(I)*QQPP2**LP(I)-POTPR2(I)*QQPP1**LP(I))*QPUN2**(LP(I)+2))/&
                 ((QQPP1*QQPP2)**LP(I)*(QQPP2**2-QQPP1**2))
         END DO
      ELSE
         IF (QPUN1 < BESCHRL(JMOM,1) .AND. (QPUN2 < BESCHRP(JMOM,1))) THEN
            QQPP1=BESCHRL(JMOM,1)
            QQPP2=BESCHRL(JMOM,1)*1.2_DP
            QQPP3=BESCHRP(JMOM,1)
            QQPP4=BESCHRP(JMOM,1)*1.2_DP
            CALL CHIRALOLD(OSTAT,FORCE,REL,QQPP1,QQPP3,JMOM,CUTNUM,POTPR1)
            CALL CHIRALOLD(OSTAT,FORCE,REL,QQPP2,QQPP3,JMOM,CUTNUM,POTPR2)
            CALL CHIRALOLD(OSTAT,FORCE,REL,QQPP1,QQPP4,JMOM,CUTNUM,POTPR3)
            CALL CHIRALOLD(OSTAT,FORCE,REL,QQPP2,QQPP4,JMOM,CUTNUM,POTPR4)
            DO I=1,6
               POTPR1(I)=((POTPR1(I)*QQPP2**(L(I)+2)-POTPR2(I)*QQPP1**(L(I)+2))*QPUN1**L(I)-&
                    (POTPR1(I)*QQPP2**L(I)-POTPR2(I)*QQPP1**L(I))*QPUN1**(L(I)+2))/&
                    ((QQPP1*QQPP2)**L(I)*(QQPP2**2-QQPP1**2))
               POTPR2(I)=((POTPR3(I)*QQPP2**(L(I)+2)-POTPR4(I)*QQPP1**(L(I)+2))*QPUN1**L(I)-&
                    (POTPR3(I)*QQPP2**L(I)-POTPR4(I)*QQPP1**L(I))*QPUN1**(L(I)+2))/&
                    ((QQPP1*QQPP2)**L(I)*(QQPP2**2-QQPP1**2))
               POTENT(I)=((POTPR1(I)*QQPP4**(LP(I)+2)-POTPR2(I)*QQPP3**(LP(I)+2))*QPUN2**LP(I)-&
                    (POTPR1(I)*QQPP4**LP(I)-POTPR2(I)*QQPP3**LP(I))*QPUN2**(LP(I)+2))/&
                    ((QQPP3*QQPP4)**LP(I)*(QQPP4**2-QQPP3**2))
            END DO
         END IF
      END IF
   END IF
END IF


END SUBROUTINE CHIRALPROM






SUBROUTINE CHIRALOLD(OSTAT,FORCE,REL,QPUN1,QPUN2,JMOM,CUTNUM,POTENT)
!in this routine the chiral potential is calculated 


USE PARAMETERS
USE LEC

IMPLICIT NONE
INTEGER                    ::I,JMOM,OSTAT,NZPUN,CUTN,CUTNN,CUTNNN,&
                             OSTATFIRST,CUTNUMFIRST,CUTNUM,REL,RELFIRST
INTEGER, PARAMETER         ::DP = SELECTED_REAL_KIND(15,99)
PARAMETER                    (NZPUN=30,CUTN=5,CUTNN=5,CUTNNN=5)
REAL(KIND=DP)              ::QPUN1,QPUN2,CUTVAL,QU(NZPUN),QUQUAD(NZPUN),&
                             ZPUN(NZPUN),ZWEI(NZPUN),& 
                             OMEGA(NZPUN),LFUN(NZPUN),AFUN(NZPUN),CUTFAC,&
                             WTEN1T(NZPUN),WTEN1S(NZPUN),WSIG1S(NZPUN),WC1T(NZPUN),&
                             WTEN1TCH(NZPUN),WTEN1TN(NZPUN),&
                             WC2S(NZPUN),WC2T(NZPUN),WTEN2S(NZPUN),WSIG2S(NZPUN),&
                             WTEN2T(NZPUN),WSIG2T(NZPUN),WSL2S(NZPUN),WSL2T(NZPUN),&
                             RTEN1T(6),RTEN1S(6),RSIG1S(6),RC1T(6),RC2S(6),RC2T(6),&
                             RTEN2S(6),RSIG2S(6),RTEN2T(6),RSIG2T(6),RSL2S(6),RSL2T(6),&
                             RTEN1TCH(6),RTEN1TN(6),&
!                             VCN3,WSN3,WTN3,VS1N3,VS2N3,VT1N3,VT2N3,WC1N3,WC2N3,&
!                             WC3N3,WC4N3,VCC1N3,VCC2N3,VCC3N3,VCC4N3,VCC5N3,VCC6N3,&
!                             WCTN3,WCSN3,&
                             VCNNN(NZPUN),WCNNN(NZPUN),WSIGNNN(NZPUN),&
                             WSIGDNNN(NZPUN),VSIGNNN(NZPUN),VSIGDNNN(NZPUN),&
                             RCNNNS(6),RCNNNT(6),RSIGNNNT(6),&
                             RSIGDNNNT(6),RSIGNNNS(6),RSIGDNNNS(6),&
                             POTS(6),POTT(6),POTENT(6),PPOT(6),CC(9),QQPUN1,QQPUN2,&
                             LAMQU,MPIQU,DD(15),FFF1,FFF2,TEMT(6),TEMS(6)

LOGICAL                    ::FIRST

CHARACTER(LEN=8)          ::POTNAME

CHARACTER(LEN=2)          ::FORCE,FORCEFIRST

INTENT(IN)                 ::OSTAT,FORCE,REL,QPUN1,QPUN2,JMOM,CUTNUM
INTENT(OUT)                ::POTENT

!*********************************************  NLO   ***************************************************
!** LAM_LS, LAM = ((0.40, 0.50), (0.55, 0.50), (0.55, 0.60), (0.40, 0.70), (0.55, 0.70))   g_A=1.29 *****
REAL(KIND=DP), DIMENSION(9,CUTN), PARAMETER ::    CCN =  RESHAPE((/ &
                 1.507521966890645659_DP,      -0.155737351563717014_DP,      -0.237639254818454715_DP,&
                -0.181194189495330588_DP,       0.193449246722948831_DP,      -0.505176149004812114_DP,&
                 1.201168054342269809_DP,      -0.359542742067765098_DP,      -0.211680441688417043_DP,&
                 2.107482271232857585_DP,      -0.056523304857028035_DP,      -0.337345884089231163_DP,&
                -0.148630578775917815_DP,       0.203787852799977853_DP,      -0.497657099908921374_DP,&
                 1.334562303635374869_DP,      -0.244522667214492034_DP,      -0.153593626991477356_DP,&
                 2.027898270913552459_DP,      -0.086033716102423566_DP,      -0.406285287002624451_DP,&
                -0.148615256019007241_DP,       0.213492069354222130_DP,      -0.514445029301030643_DP,&
                 1.356095004859203312_DP,      -0.245475184880906500_DP,      -0.135077541007558893_DP,&
                 1.599473905787918593_DP,      -0.155621989794636734_DP,      -0.383224469756722586_DP,&
                -0.181035634287703973_DP,       0.212326931792986673_DP,      -0.534366878086891539_DP,&
                 1.265123289388333294_DP,      -0.360670760985527195_DP,      -0.176565057731995545_DP,&
                 1.976907762610589092_DP,      -0.102328859398108235_DP,      -0.442383091604393042_DP,&
                -0.148408920770009056_DP,       0.219592449162942072_DP,      -0.523317960492910572_DP,&
                 1.367666824437475004_DP,      -0.246394093806975467_DP,      -0.124970684701431467_DP/),&
                                                            (/9,CUTN/))




!*********************************************  NNLO  **************************************************
!***                c1=-0.81, c3=-3.4, c4=3.4;   g_A=1.29   both LAM and LAM_LS are varied:         ****
!***    LAM_LS, LAM = ((0.45, 0.50), (0.60, 0.50), (0.55, 0.60), (0.45, 0.70), (0.60, 0.70))        ****
REAL(KIND=DP), DIMENSION(9,CUTNN), PARAMETER ::    CCNN =  RESHAPE((/ &
                 2.063196913891625961_DP,      -0.152525558301448372_DP,       0.345541450450780441_DP,&
                -0.170642706839654545_DP,       0.244959778987032251_DP,      -0.723394164269538065_DP,&
                 1.222964766841485584_DP,      -0.525616289757158461_DP,      -0.416041892125891044_DP,&
                 2.266684118966358685_DP,      -0.105083868735138725_DP,       0.193922566607062474_DP,&
                -0.135659204733467958_DP,       0.272388819174930741_DP,      -0.636987133834952979_DP,&
                 1.545967448494470986_DP,      -0.465979177828845015_DP,      -0.354735919709170400_DP,&
                 2.256450261437286109_DP,      -0.148752994060917548_DP,       0.328625266877455857_DP,&
                -0.146520087111675246_DP,       0.282747234796471347_DP,      -0.616264820945918057_DP,&
                 1.338382942268841358_DP,      -0.553658646010933064_DP,      -0.409711964731362954_DP,&
                 2.412153684959795541_DP,      -0.152595386629766128_DP,       0.556814992024623479_DP,&
                -0.173340293593994693_DP,       0.281223770000226581_DP,      -0.766842883218259441_DP,&
                 1.250786380072914650_DP,      -0.625967030849838180_DP,      -0.499702412228386350_DP,&
                 2.412297626582129872_DP,      -0.150797961494917254_DP,       0.404795846401873050_DP,&
                -0.138645278395862659_DP,       0.306740095877100938_DP,      -0.072768449837020077_DP,&
                 1.798345734802434315_DP,      -0.600099780410531469_DP,      -0.441643484890203109_DP/),&
                                                            (/9,CUTNN/))


!*********************************************  NNNLO  *************************************************
!***                c1=-0.81, c3=-3.4, c4=3.4;   g_A=1.29   both LAM and LAM_LS are varied:         ****
!***    LAM_LS, LAM = ((0.45, 0.50), (0.60, 0.60), (0.55, 0.60), (0.45, 0.70), (0.60, 0.70))        ****
REAL(KIND=DP), DIMENSION(9,CUTNNN), PARAMETER ::    CCNNN =  RESHAPE((/ &
                 1.500743979918623072_DP,      -0.083384000932478164_DP,       0.414445759602711905_DP,&
                -0.149802942378925330_DP,       0.186150361851370627_DP,      -0.633351141602217393_DP,&
                 1.172873335683373597_DP,      -0.554154821414755139_DP,      -0.451611584884298090_DP,&
                 1.807535964694622077_DP,      -0.080021794360646867_DP,      -0.585615254046747746_DP,&
                 0.114412150333712409_DP,       0.337410994486275095_DP,      -0.660162399341842954_DP,&
                 1.203430147799100514_DP,      -0.581199508448912994_DP,      -0.272592397714430890_DP,&
                 1.714316869329750137_DP,      -0.065337687369959818_DP,      -0.136947102030059553_DP,&
                -0.028210745568818193_DP,       0.286616808363808540_DP,      -0.672313151787085950_DP,&
                 1.197373685489665718_DP,      -0.575041624667762763_DP,      -0.371010601127067519_DP,&
                 2.121724703303493165_DP,      -0.124746706610784075_DP,       0.627507645679311832_DP,&
                -0.159948267474025296_DP,       0.207216171479595063_DP,      -0.757553192516556395_DP,&
                 1.191253581333382883_DP,      -0.621166977483523786_DP,      -0.504474758472328477_DP,&
                 1.894996708358892779_DP,      -0.043607268500148039_DP,      -0.355689550152851530_DP,&
                 0.074586702284583806_DP,       0.344357743511552239_DP,      -0.719251207510904988_DP,&
                 1.203081587912018691_DP,      -0.611391498673339973_DP,      -0.335249866310763256_DP/),&
                                                            (/9,CUTNNN/))
REAL(KIND=DP), DIMENSION(15,CUTNNN), PARAMETER ::    DDNNN =  RESHAPE((/ &
               -26.983609034675936300_DP,       3.740208672657903577_DP,     -26.351574813442177003_DP,&
                 4.809147879104167522_DP,       2.325686042161575706_DP,       4.236888822755748407_DP,&
                 1.089157305671532239_DP,       4.195605557088513571_DP,       2.630319457518107917_DP,&
                -0.006116648546805038_DP,      -2.245000387566057132_DP,      -1.418001692393979773_DP,&
                -1.398787887723857093_DP,      -2.079170680423517492_DP,       0.233274290152836905_DP,&
               -16.767796185859040747_DP,      -2.556476211429715040_DP,     -13.108304243970353653_DP,&
                 2.118442628858005605_DP,       1.918048558868352682_DP,       3.846451892577759324_DP,&
                 1.250013733044439412_DP,       4.226984973175266447_DP,       1.768563020297637900_DP,&
                -0.290609716705030996_DP,      -2.187431521415759139_DP,      -0.902251019718472991_DP,&
                -1.748252586104946049_DP,      -1.549307413958793678_DP,       0.290083503785671881_DP,&
               -18.708190922350560470_DP,      -1.166186317095878167_DP,     -15.756895875224044445_DP,&
                 2.181488793963783479_DP,       2.586636930900492182_DP,       3.993007330657768250_DP,&
                 1.238224142429774188_DP,       4.132214420276087097_DP,       1.974837911745732422_DP,&
                -0.160326503441446722_DP,      -2.207138583301890833_DP,      -0.973257969443574122_DP,&
                -1.672007349961589062_DP,      -1.720986217689598696_DP,       0.270038749728967131_DP,&
               -24.728837981435709992_DP,       0.821354201363674097_DP,     -23.855522291264854573_DP,&
                 4.380707040268117858_DP,       2.396822420338878601_DP,       4.209858204600640974_DP,&
                 1.218984535822320581_DP,       4.034023284177056468_DP,       2.029637351658742261_DP,&
                 0.041316283846170240_DP,      -2.339767870401419536_DP,      -1.357779342656354693_DP,&
                -1.224984840695308108_DP,      -1.752168028964613100_DP,       0.227434199156465178_DP,&
               -17.629497389858471479_DP,      -2.077109138263415478_DP,     -12.407786560957555722_DP,&
                 1.889510631913951855_DP,       1.921291545796531164_DP,       3.875605805768201684_DP,&
                 1.411589889852692403_DP,       4.172335608256688921_DP,       1.551627911565999662_DP,&
                -0.173791071437607081_DP,      -2.220345769126105928_DP,      -0.858003193989459678_DP,&
                -1.661958213526658401_DP,      -1.484131891431353711_DP,       0.289235530806034591_DP/),&
                                                            (/15,CUTNNN/))



REAL(KIND=DP), DIMENSION(CUTNNN), PARAMETER ::    CC2NNNNP =  (/ &
                -0.091264996267065135_DP,      -0.089201410473187928_DP,       -0.074868987050364155_DP,&
                -0.128867189224690010_DP,      -0.054388199475126978_DP /)

REAL(KIND=DP), DIMENSION(CUTNNN), PARAMETER ::    CC2NNNNN =  (/ &
                -0.0880292272966139017_DP,     -0.0851415188632103498_DP,      -0.0706820819393567945_DP,&
                -0.127157666083440313_DP,      -0.0494251322696792894_DP /)

REAL(KIND=DP), DIMENSION(CUTNN), PARAMETER ::     CC2NNNP =  (/ &
                -0.153621731090710756_DP,      -0.108208286330767678_DP,       -0.149848883561033208_DP,&
                -0.153335972061577397_DP,      -0.151722372092924107_DP /)

REAL(KIND=DP), DIMENSION(CUTNN), PARAMETER ::     CC2NNNN =  (/ &
                -0.153155986920833126_DP,      -0.106809184515778380_DP,       -0.149386652660771058_DP,&
                -0.152997644320195803_DP,      -0.151315237801069591_DP /)

REAL(KIND=DP), DIMENSION(CUTN), PARAMETER ::     CC2NNP =  (/ &
                -0.156846186862361847_DP,      -0.061671887291089522_DP,       -0.090322166871349918_DP,&
                -0.156683287745929517_DP,      -0.106092156284632366_DP /)

REAL(KIND=DP), DIMENSION(CUTN), PARAMETER ::     CC2NNN =  (/ &
                -0.156388105576778541_DP,      -0.059333665422213584_DP,      -0.088394211250128640_DP,&
                -0.156238417025471699_DP,      -0.104412684471350423_DP /)

REAL(KIND=DP), DIMENSION(2,CUTN), PARAMETER ::    CUTOFN =  RESHAPE((/ &
                                     0.40_DP, 0.50_DP, &
                                     0.55_DP, 0.50_DP, &
                                     0.55_DP, 0.60_DP, &
                                     0.40_DP, 0.70_DP, &
                                     0.55_DP, 0.70_DP/),&
                                                            (/2,CUTN/))

REAL(KIND=DP), DIMENSION(2,CUTNN), PARAMETER ::    CUTOFNN =  RESHAPE((/ &
                                     0.45_DP, 0.50_DP, &
                                     0.60_DP, 0.50_DP, &
                                     0.55_DP, 0.60_DP, &
                                     0.45_DP, 0.70_DP, &
                                     0.60_DP, 0.70_DP/),&
                                                            (/2,CUTNN/))

REAL(KIND=DP), DIMENSION(2,CUTNNN), PARAMETER ::    CUTOFNNN =  RESHAPE((/ &
                                     0.45_DP, 0.50_DP, &
                                     0.60_DP, 0.60_DP, &      
                                     0.55_DP, 0.60_DP, &
                                     0.45_DP, 0.70_DP, &
                                     0.60_DP, 0.70_DP/),&
                                                            (/2,CUTNNN/))

DATA                          FIRST/.FALSE./


SAVE                         FIRST,OSTATFIRST,CUTNUMFIRST,FORCEFIRST,RELFIRST

COMMON/CUTVAL/               CUTVAL

!EXTERNAL GAULEGMOD
!EXTERNAL PARC  
!EXTERNAL PARSIG
!EXTERNAL PARSIGD
!EXTERNAL PARSIGK
!EXTERNAL PARSL
!EXTERNAL PARSIGL
!EXTERNAL SPLSETUP

POTENT=0.0_DP

IF (JMOM < 0 .OR. JMOM > 8) THEN
  WRITE(*,*)'The total angular momentum should be positive and smaller than 9'
  STOP
END IF
 
IF (CUTNUM < 1) THEN
  WRITE(*,*)'The INPUT parameter CUTNUM should take a positive value'
  STOP
END IF 

IF (OSTAT .NE. 0 .AND. OSTAT .NE. 1 .AND. OSTAT .NE. 2) THEN
  WRITE(*,*)'Wrong value of the input parameter OSTAT'
  STOP
END IF

IF (REL .NE. 0 .AND. REL .NE. 1 .AND. REL .NE. 2) THEN
  WRITE(*,*)'Wrong value of the input parameter REL'
  STOP
END IF



IF (FORCE .NE. 'np' .AND.  FORCE .NE. 'nn' .AND.  FORCE .NE. 'pp') THEN
  WRITE(*,*)'The FORCE parameter CUTNUM should be "np", "nn" or "pp"'
  STOP
END IF


IF (OSTAT .NE. 2 .AND. REL .NE. 0) THEN
  WRITE(*,*)'Please use REL = 0'
  STOP
END IF



SELECT CASE (OSTAT)
  CASE (0)
    IF (CUTNUM > CUTN) THEN
      WRITE(*,*)'The value of the parameter CUTNUM should not extend ',CUTN 
      STOP
    END IF 
    CUTVAL=CUTOFN(1,CUTNUM)
    LAM=CUTOFN(2,CUTNUM)
    POTNAME='CD NLO'
    DO I=1,9 
      CC(I)=CCN(I,CUTNUM)*10000.0_DP
    END DO
    IF (FORCE .EQ. 'np') THEN
      CC(2)=CC2NNP(CUTNUM)*10000.0_DP
    END IF

    IF (FORCE .EQ. 'nn') THEN
      CC(2)=CC2NNN(CUTNUM)*10000.0_DP
    END IF


  CASE (1)
    IF (CUTNUM > CUTNN) THEN
       WRITE(*,*)'The value of the parameter CUTNUM should not extend ',CUTNN 
       STOP
    END IF
    CUTVAL=CUTOFNN(1,CUTNUM)
    LAM=CUTOFNN(2,CUTNUM)
    POTNAME='CD NNLO'
    DO I=1,9
      CC(I)=CCNN(I,CUTNUM)*10000.0_DP
    END DO
    IF (FORCE .EQ. 'np') THEN
      CC(2)=CC2NNNP(CUTNUM)*10000.0_DP
    END IF

    IF (FORCE .EQ. 'nn') THEN
      CC(2)=CC2NNNN(CUTNUM)*10000.0_DP
    END IF


  CASE (2)
    IF (CUTNUM > CUTNNN) THEN
       WRITE(*,*)'The value of the parameter CUTNUM should not extend ',CUTNNN 
       STOP
    END IF
    CUTVAL=CUTOFNNN(1,CUTNUM)
    LAM=CUTOFNNN(2,CUTNUM)
    POTNAME='CD NNNLO'
    DO I=1,9
      CC(I)=CCNNN(I,CUTNUM)*10000.0_DP
    END DO
    DO I=1,15
      DD(I)=DDNNN(I,CUTNUM)*10000.0_DP
    END DO
    
    IF (FORCE .EQ. 'np') THEN
      CC(2)=CC2NNNNP(CUTNUM)*10000.0_DP
    END IF

    IF (FORCE .EQ. 'nn') THEN
      CC(2)=CC2NNNNN(CUTNUM)*10000.0_DP
    END IF

  CASE default
    WRITE(*,*)'The value of the variable OSTAT should be  0, 1 or 2'
    STOP
END SELECT  


IF (FIRST) THEN 
  IF (OSTAT .NE. OSTATFIRST) THEN
    FIRST=.FALSE.
  END IF
  IF (CUTNUM .NE. CUTNUMFIRST) THEN
    FIRST=.FALSE.
  END IF
  IF (FORCE .NE. FORCEFIRST) THEN
    FIRST=.FALSE.
  END IF
  IF (REL .NE. RELFIRST) THEN
    FIRST=.FALSE.
  END IF
END IF


IF (.NOT. FIRST) THEN
   OSTATFIRST=OSTAT
   CUTNUMFIRST=CUTNUM
   FORCEFIRST=FORCE
   RELFIRST=REL
   WRITE(*,*)'===================================================================================='
!   WRITE(*,*)
   WRITE(*,60)' This is the ',POTNAME,' version of the potential,','  ',FORCE,' case' 
   IF (OSTAT .NE. 2 .OR. REL .EQ. 0) THEN
      WRITE(*,60)' The potential has to be used in the non-relativistic Schroedinger equation'
   ELSE
      IF (REL .EQ. 1) THEN
         WRITE(*,60)' The potential has to be used in the "non-relativistic" Schroedinger equation with relativ. kinematics'
      ELSE
         WRITE(*,60)' The potential has to be used in the relativistic Schroedinger equation'
      END IF
   END IF
   WRITE(*,*)
   WRITE(*,65)' The cut-off in the LS equation is: ',CUTVAL*1000.0_DP,' MeV'
   WRITE(*,65)' The cut-off in the spect. fun. is: ',LAM*1000.0_DP,' MeV'
   WRITE(*,*)
   WRITE(*,60)' The parameters of the potential are:'
   WRITE(*,61)'g_A = ',GA,' ','f_PI = ',FPI*1000.0_DP,' MeV'
   WRITE(*,62)'M_PI0 = ',MPIN*1000.0_DP,' MeV',' ',&
        'M_PI+ = M_PI- = ',MPICH*1000.0_DP,' MeV',' ','M_NUCL = ',MMM*1000.0_DP,' MeV'
   WRITE(*,*)


   IF (OSTAT .EQ. 0) THEN
      WRITE(*,70)'d18 =',D18,' GeV^(-2)'
   END IF
   IF (OSTAT .EQ. 1) THEN
      WRITE(*,70)'c1 =',C1,' GeV^(-1)'
      WRITE(*,70)'c3 =',C3,' GeV^(-1)'
      WRITE(*,70)'c4 =',C4,' GeV^(-1)'
      WRITE(*,70)'d18 =',D18,' GeV^(-2)'
   END IF
   IF (OSTAT .EQ. 2) THEN
      WRITE(*,70)'c1 =',C1,' GeV^(-1)'
      WRITE(*,70)'c2 =',C2,' GeV^(-1)'
      WRITE(*,70)'c3 =',C3,' GeV^(-1)'
      WRITE(*,70)'c4 =',C4,' GeV^(-1)'
      WRITE(*,70)'d1+d2 =',D1P2,' GeV^(-2)'
      WRITE(*,70)'d3 =',D3,' GeV^(-2)'
      WRITE(*,70)'d5 =',D5,' GeV^(-2)'
      WRITE(*,70)'d14-d15 =',D14M15,' GeV^(-2)'
      WRITE(*,70)'d18 =',D18,' GeV^(-2)'
   END IF
   WRITE(*,*)
   WRITE(*,60)' Contact interactions:'
   WRITE(*,64)'C_1S0~ = ',CC(2)/10000.0_DP,' * 10000 GeV^(-2)'
   WRITE(*,64)'C_1S0 = ',CC(1)/10000.0_DP,' * 10000 GeV^(-4)'
   WRITE(*,64)'C_3S1~ = ',CC(4)/10000.0_DP,' * 10000 GeV^(-2)'
   WRITE(*,64)'C_3S1 = ',CC(3)/10000.0_DP,' * 10000 GeV^(-4)'
   WRITE(*,64)'C_3S1-3D1 = ',CC(9)/10000.0_DP,' * 10000 GeV^(-4)'
   WRITE(*,64)'C_1P1 = ',CC(5)/10000.0_DP,' * 10000 GeV^(-4)'
   WRITE(*,64)'C_3P0 = ',CC(7)/10000.0_DP,' * 10000 GeV^(-4)'
   WRITE(*,64)'C_3P1 = ',CC(6)/10000.0_DP,' * 10000 GeV^(-4)'
   WRITE(*,64)'C_3P2 = ',CC(8)/10000.0_DP,' * 10000 GeV^(-4)'
   IF (OSTAT .EQ. 2) THEN
     WRITE(*,*)
     WRITE(*,64)'D1 = ',DD(1)/10000.0_DP,' * 10000 GeV^(-6)'
     WRITE(*,64)'D2 = ',DD(2)/10000.0_DP,' * 10000 GeV^(-6)'
     WRITE(*,64)'D3 = ',DD(3)/10000.0_DP,' * 10000 GeV^(-6)'
     WRITE(*,64)'D4 = ',DD(4)/10000.0_DP,' * 10000 GeV^(-6)'
     WRITE(*,64)'D5 = ',DD(5)/10000.0_DP,' * 10000 GeV^(-6)'
     WRITE(*,64)'D6 = ',DD(6)/10000.0_DP,' * 10000 GeV^(-6)'
     WRITE(*,64)'D7 = ',DD(7)/10000.0_DP,' * 10000 GeV^(-6)'
     WRITE(*,64)'D8 = ',DD(8)/10000.0_DP,' * 10000 GeV^(-6)'
     WRITE(*,64)'D9 = ',DD(9)/10000.0_DP,' * 10000 GeV^(-6)'
     WRITE(*,64)'D10 = ',DD(10)/10000.0_DP,' * 10000 GeV^(-6)'
     WRITE(*,64)'D11 = ',DD(11)/10000.0_DP,' * 10000 GeV^(-6)'
     WRITE(*,64)'D12 = ',DD(12)/10000.0_DP,' * 10000 GeV^(-6)'
     WRITE(*,64)'D13 = ',DD(13)/10000.0_DP,' * 10000 GeV^(-6)'
     WRITE(*,64)'D14 = ',DD(14)/10000.0_DP,' * 10000 GeV^(-6)'
     WRITE(*,64)'D15 = ',DD(15)/10000.0_DP,' * 10000 GeV^(-6)'
   END IF
   WRITE(*,*)
   WRITE(*,*)'===================================================================================='

   IF (OSTAT .EQ. 2) THEN
      CALL N3LO
   END IF
END IF

FIRST=.TRUE.


QQPUN1=QPUN1/1000.0_DP
QQPUN2=QPUN2/1000.0_DP

IF (QQPUN1/CUTVAL .GE. 2.0_DP .OR. QQPUN2/CUTVAL .GE. 2.0_DP) THEN
  POTENT=0.0_DP
  RETURN
END IF

IF (REL .EQ. 0 .AND. OSTAT .EQ. 2) THEN
  SELECT CASE (FORCE)
    CASE ('nn')
      FFF1=SQRT((1.0_DP+QQPUN1**2/(2.0_DP*MN**2))*SQRT(1.0_DP+QQPUN1**2/(4.0_DP*MN**2)))
      FFF2=SQRT((1.0_DP+QQPUN2**2/(2.0_DP*MN**2))*SQRT(1.0_DP+QQPUN2**2/(4.0_DP*MN**2)))
      QQPUN1=SQRT(QQPUN1**2+QQPUN1**4/(4.0_DP*MN**2))
      QQPUN2=SQRT(QQPUN2**2+QQPUN2**4/(4.0_DP*MN**2))
    CASE ('pp')
      FFF1=SQRT((1.0_DP+QQPUN1**2/(2.0_DP*MP**2))*SQRT(1.0_DP+QQPUN1**2/(4.0_DP*MP**2)))
      FFF2=SQRT((1.0_DP+QQPUN2**2/(2.0_DP*MP**2))*SQRT(1.0_DP+QQPUN2**2/(4.0_DP*MP**2)))
      QQPUN1=SQRT(QQPUN1**2+QQPUN1**4/(4.0_DP*MP**2))
      QQPUN2=SQRT(QQPUN2**2+QQPUN2**4/(4.0_DP*MP**2))
    CASE ('np')
      FFF1=SQRT((1.0_DP+QQPUN1**2/(2.0_DP*MMM**2))*SQRT(1.0_DP+QQPUN1**2/(4.0_DP*MMM**2)))
      FFF2=SQRT((1.0_DP+QQPUN2**2/(2.0_DP*MMM**2))*SQRT(1.0_DP+QQPUN2**2/(4.0_DP*MMM**2)))
      QQPUN1=SQRT(QQPUN1**2+QQPUN1**4/(4.0_DP*MMM**2))
      QQPUN2=SQRT(QQPUN2**2+QQPUN2**4/(4.0_DP*MMM**2))
  END SELECT
END IF  

CALL GAULEGMOD(-1.0_DP,1.0_DP,ZPUN,ZWEI,NZPUN) ! Gauss Legendre: ZPUN is the angle for dcos integral, ZWEI is the weight, and NZPUN is the number of points

! AT: Non-local regulator. CUTPOT controls the power in the exp (i.e., CUTPOT = 2 would give a Gaussian regulator).
CUTFAC=EXP(-QQPUN1**CUTPOT/CUTVAL**CUTPOT-QQPUN2**CUTPOT/CUTVAL**CUTPOT)
MPIQU=MPI**2
LAMQU=LAM**2


DO I=1,NZPUN
  QUQUAD(I)=QQPUN1**2+QQPUN2**2-2.0_DP*QQPUN1*QQPUN2*ZPUN(I)
  QU(I)=SQRT(QUQUAD(I))
  OMEGA(I)=SQRT(QUQUAD(I)+4.0_DP*MPIQU)
  LFUN(I)=OMEGA(I)/QU(I)/2.0_DP*LOG((2.0_DP*LAMQU*QUQUAD(I)+4.0_DP*MPIQU*LAMQU-4.0_DP*MPIQU*QUQUAD(I)+&
          2.0_DP*LAM*QU(I)*SQRT((LAMQU-4.0_DP*MPIQU)*(QUQUAD(I)+4.0_DP*MPIQU)))/&
          (4.0_DP*MPIQU*(LAMQU+QUQUAD(I))))
  AFUN(I)=1.0_DP/2.0_DP/QU(I)*ATAN(QU(I)*(LAM-2.0_DP*MPI)/(QUQUAD(I)+2.0_DP*LAM*MPI))
  WTEN1T(I)=-GA**2/(4.0_DP*FPI**2)*(1.0_DP-4.0_DP*MPIQU/GA*D18)/(QUQUAD(I)+MPIQU)
  WTEN1TCH(I)=-GA**2/(4.0_DP*FPI**2)*(1.0_DP-4.0_DP*MPIQU/GA*D18)/(QUQUAD(I)+MPICH**2)
  WTEN1TN(I)=-GA**2/(4.0_DP*FPI**2)*(1.0_DP-4.0_DP*MPIQU/GA*D18)/(QUQUAD(I)+MPIN**2)
  ! AT: NLO terms in pion-exchange piece
  WTEN1S(I)=-3.0_DP*GA**4/(64.0_DP*PI**2*FPI**4)*LFUN(I) ! AT: V_T^(2) in eqn. (2.14) in EGM (2005)
  WSIG1S(I)=-WTEN1S(I)*QUQUAD(I)
  WC1T(I)=-LFUN(I)/(384.0_DP*PI**2*FPI**4)*(4.0_DP*MPIQU*(5.0_DP*GA**4-4.0_DP*GA**2-1.0_DP)+QUQUAD(I)*&
          (23.0_DP*GA**4-10.0_DP*GA**2-1.0_DP)+48.0_DP*GA**4*MPI**4/OMEGA(I)**2) ! AT: W_C^(2) eqn in (2.14) in EGM (2005)
    IF (OSTAT .GE. 1) THEN
      WC2S(I)=-3.0_DP*GA**2/(16.0_DP*PI*FPI**4)*(2.0_DP*MPIQU*&
               (2.0_DP*C1-C3)-QUQUAD(I)*C3)*(2.0_DP*MPIQU+QUQUAD(I))*AFUN(I)
      WTEN2T(I)=-GA**2/(32.0_DP*PI*FPI**4)*C4*OMEGA(I)**2*AFUN(I)
      WSIG2T(I)=-QUQUAD(I)*WTEN2T(I)
      IF (OSTAT .EQ. 2) THEN
        CALL SPLSETUP(QU(I))
        WTEN1T(I)=WTEN1T(I)*(1.0_DP-(QQPUN1**2+QQPUN2**2)/MMM**2/2.0_DP)
        WTEN1TCH(I)=WTEN1TCH(I)*(1.0_DP-(QQPUN1**2+QQPUN2**2)/MMM**2/2.0_DP)
        WTEN1TN(I)=WTEN1TN(I)*(1.0_DP-(QQPUN1**2+QQPUN2**2)/MMM**2/2.0_DP)
!**************   actual NNNLO contributions
        VCNNN(I)=-(VCN3(QU(I))+VCC1N3(QU(I))+VCC2N3(QU(I))+VCC3N3(QU(I))+VCC4N3(QU(I))&
                 +VCC5N3(QU(I))+VCC6N3(QU(I)))
        WCNNN(I)=-(WC1N3(QU(I))+WC2N3(QU(I))+WC3N3(QU(I))+WC4N3(QU(I)))
        WSIGNNN(I)=-(WSN3(QU(I))+WCSN3(QU(I)))
        WSIGDNNN(I)=-(WTN3(QU(I))+WCTN3(QU(I)))
        VSIGNNN(I)=-(VS1N3(QU(I))+VS2N3(QU(I)))
        VSIGDNNN(I)=-(VT1N3(QU(I))+VT2N3(QU(I)))
!**************   1/m-corrections (not taken into account at NNLO)
        WC2S(I)=WC2S(I)-3.0_DP*GA**2/(16.0_DP*PI*FPI**4)*(-GA**2*MPI**5/(16.0_DP*MMM*OMEGA(I)**2)+&
                (MPIQU*3.0_DP*GA**2/(16.0_DP*MMM)-QUQUAD(I)*3.0_DP*GA**2/(32.0_DP*MMM))*&
                (2.0_DP*MPIQU+QUQUAD(I))*AFUN(I))
        WC2T(I)=-GA**2/(128.0_DP*PI*MMM*FPI**4)*(-3.0_DP*GA**2*MPI**5/OMEGA(I)**2+(4.0_DP*MPIQU+&
             2.0_DP*QUQUAD(I)-GA**2*(7.0_DP*MPIQU+4.5_DP*QUQUAD(I)))*(2.0_DP*MPIQU+QUQUAD(I))*AFUN(I))
        WTEN2S(I)=9.0_DP*GA**4/(512.0_DP*PI*MMM*FPI**4)*(4.0_DP*MPIQU+1.5_DP*QUQUAD(I))*AFUN(I) 
        WSIG2S(I)=-QUQUAD(I)*WTEN2S(I)
        WTEN2T(I)=WTEN2T(I)-GA**2/(32.0_DP*PI*FPI**4)*(1.0_DP/(4.0_DP*MMM)*OMEGA(I)**2-&
                  GA**2/(8.0_DP*MMM)*(8.0_DP*MPIQU+2.5_DP*QUQUAD(I)))*AFUN(I)
        WSIG2T(I)=-QUQUAD(I)*WTEN2T(I)
        WSL2S(I)=3.0_DP*GA**4/(32.0_DP*PI*MMM*FPI**4)*(2.0_DP*MPIQU+QUQUAD(I))*AFUN(I)
        WSL2T(I)=GA**2*(1.0_DP-GA**2)/(32.0_DP*PI*MMM*FPI**4)*OMEGA(I)**2*AFUN(I)
     END IF       
    END IF
END DO    



CALL PARSIGD(RTEN1T,WTEN1T,JMOM,NZPUN,QQPUN1,QQPUN2,ZPUN,ZWEI)
CALL PARSIGD(RTEN1TCH,WTEN1TCH,JMOM,NZPUN,QQPUN1,QQPUN2,ZPUN,ZWEI)
CALL PARSIGD(RTEN1TN,WTEN1TN,JMOM,NZPUN,QQPUN1,QQPUN2,ZPUN,ZWEI)
CALL PARSIGD(RTEN1S,WTEN1S,JMOM,NZPUN,QQPUN1,QQPUN2,ZPUN,ZWEI)
CALL PARSIG(RSIG1S,WSIG1S,JMOM,NZPUN,QQPUN1,QQPUN2,ZPUN,ZWEI)
CALL PARC(RC1T,WC1T,JMOM,NZPUN,QQPUN1,QQPUN2,ZPUN,ZWEI)
IF (OSTAT .GE. 1) THEN
  CALL PARC(RC2S,WC2S,JMOM,NZPUN,QQPUN1,QQPUN2,ZPUN,ZWEI)
  CALL PARSIGD(RTEN2T,WTEN2T,JMOM,NZPUN,QQPUN1,QQPUN2,ZPUN,ZWEI)
  CALL PARSIG(RSIG2T,WSIG2T,JMOM,NZPUN,QQPUN1,QQPUN2,ZPUN,ZWEI)
  IF (OSTAT .EQ. 2) THEN
    CALL PARC(RCNNNS,VCNNN,JMOM,NZPUN,QQPUN1,QQPUN2,ZPUN,ZWEI)
    CALL PARC(RCNNNT,WCNNN,JMOM,NZPUN,QQPUN1,QQPUN2,ZPUN,ZWEI)
    CALL PARSIG(RSIGNNNT,WSIGNNN,JMOM,NZPUN,QQPUN1,QQPUN2,ZPUN,ZWEI)
    CALL PARSIGD(RSIGDNNNT,WSIGDNNN,JMOM,NZPUN,QQPUN1,QQPUN2,ZPUN,ZWEI)
    CALL PARSIG(RSIGNNNS,VSIGNNN,JMOM,NZPUN,QQPUN1,QQPUN2,ZPUN,ZWEI)
    CALL PARSIGD(RSIGDNNNS,VSIGDNNN,JMOM,NZPUN,QQPUN1,QQPUN2,ZPUN,ZWEI)
!**************   1/m-corrections 
    CALL PARC(RC2T,WC2T,JMOM,NZPUN,QQPUN1,QQPUN2,ZPUN,ZWEI)
    CALL PARSIGD(RTEN2S,WTEN2S,JMOM,NZPUN,QQPUN1,QQPUN2,ZPUN,ZWEI)
    CALL PARSIG(RSIG2S,WSIG2S,JMOM,NZPUN,QQPUN1,QQPUN2,ZPUN,ZWEI)
    CALL PARSL(RSL2S,WSL2S,JMOM,NZPUN,QQPUN1,QQPUN2,ZPUN,ZWEI)
    CALL PARSL(RSL2T,WSL2T,JMOM,NZPUN,QQPUN1,QQPUN2,ZPUN,ZWEI)
  END IF
END IF



PPOT=0.0_DP

! AT: NOTE: Match CC terms to eqn. 2.5 in EGM (2005) (i.e., CC(4) is C3S1~)
IF (JMOM == 0) THEN
  IF (OSTAT .NE. 2) THEN
    PPOT(1)=CC(1)*(QQPUN1**2+QQPUN2**2)+CC(2)
    PPOT(3)=CC(7)*QQPUN1*QQPUN2
  ELSE
    PPOT(1)=CC(1)*(QQPUN1**2+QQPUN2**2)+CC(2)+DD(1)*QQPUN1**2*QQPUN2**2&
            +DD(2)*(QQPUN1**4+QQPUN2**4)
    PPOT(3)=CC(7)*QQPUN1*QQPUN2+DD(7)*(QQPUN1**3*QQPUN2+QQPUN2**3*QQPUN1)
  END IF
ELSE
  IF (JMOM == 1) THEN
    IF (OSTAT .NE. 2) THEN
      PPOT(4)=CC(3)*(QQPUN1**2+QQPUN2**2)+CC(4)
      PPOT(1)=CC(5)*QQPUN1*QQPUN2
      PPOT(2)=CC(6)*QQPUN1*QQPUN2
      PPOT(5)=CC(9)*QQPUN1**2
      PPOT(6)=CC(9)*QQPUN2**2
    ELSE
      PPOT(4)=CC(3)*(QQPUN1**2+QQPUN2**2)+CC(4)+DD(3)*QQPUN1**2*QQPUN2**2+&
                   DD(4)*(QQPUN1**4+QQPUN2**4)
      PPOT(1)=CC(5)*QQPUN1*QQPUN2+DD(5)*(QQPUN1**3*QQPUN2+QQPUN2**3*QQPUN1)
      PPOT(2)=CC(6)*QQPUN1*QQPUN2+DD(6)*(QQPUN1**3*QQPUN2+QQPUN2**3*QQPUN1)
      PPOT(5)=CC(9)*QQPUN1**2+DD(9)*QQPUN1**2*QQPUN2**2+DD(10)*QQPUN1**4
      PPOT(6)=CC(9)*QQPUN2**2+DD(9)*QQPUN1**2*QQPUN2**2+DD(10)*QQPUN2**4
      PPOT(3)=DD(13)*QQPUN1**2*QQPUN2**2
    END IF
  ELSE
    IF (JMOM == 2) THEN
      IF (OSTAT .NE. 2) THEN
        PPOT(4)=CC(8)*QQPUN1*QQPUN2
      ELSE
        PPOT(4)=CC(8)*QQPUN1*QQPUN2+DD(8)*(QQPUN1**3*QQPUN2+QQPUN2**3*QQPUN1)
        PPOT(1)=DD(11)*QQPUN1**2*QQPUN2**2
        PPOT(2)=DD(12)*QQPUN1**2*QQPUN2**2
        PPOT(5)=DD(15)*QQPUN1**3*QQPUN2
        PPOT(6)=DD(15)*QQPUN1*QQPUN2**3
      END IF
    ELSE
      IF (JMOM .EQ. 3 .AND.  OSTAT .EQ. 2) THEN
        PPOT(4)=DD(14)*QQPUN1**2*QQPUN2**2
      END IF
    END IF
  END IF
END IF

!PPOT=0.0_DP
IF (FORCE .EQ. 'np') THEN
  POTT=2.0_DP*RTEN1TCH-RTEN1TN+RTEN1S+RSIG1S+RC1T+PPOT ! AT: Need to turn off two-pion exchange piece here (adding contact to pion exchange here)
ELSE
  POTT=RTEN1TN+RTEN1S+RSIG1S+RC1T+PPOT
END IF
POTS=RTEN1S+RSIG1S-3.0_DP*(RTEN1T+RC1T)+PPOT


IF (OSTAT == 1) THEN
  POTT=POTT+RC2S+RTEN2T+RSIG2T
  POTS=POTS+RC2S-3.0_DP*(RTEN2T+RSIG2T)
END IF


IF (OSTAT == 2) THEN
  TEMT=RCNNNS+RCNNNT+RSIGNNNT+RSIGDNNNT+RSIGNNNS+RSIGDNNNS
  TEMS=RCNNNS+RSIGNNNS+RSIGDNNNS-3.0_DP*(RCNNNT+RSIGNNNT+RSIGDNNNT)
  DO I=1,6
     IF(ABS(TEMT(I)) .LE. 0.00000001_DP/CUTFAC*(4.0_DP*PI)**2 .AND. JMOM .GE. 3) THEN
        TEMT(I)=0.0_DP
     END IF
     IF(ABS(TEMS(I)) .LE. 0.00000001_DP/CUTFAC*(4.0_DP*PI)**2 .AND. JMOM .GE. 3) THEN
        TEMS(I)=0.0_DP
     END IF
  END DO

  POTT=POTT+RC2S+RTEN2T+RSIG2T+RC2T+RTEN2S+RSIG2S+RSL2S+RSL2T+TEMT
  POTS=POTS+RC2S-3.0_DP*(RTEN2T+RSIG2T)+RTEN2S+RSIG2S+RSL2S&
           -3.0_DP*(RC2T+RSL2T)+TEMS
END IF


IF (FORCE .NE. 'np') THEN
  POTS=0.0_DP
END IF


IF ((JMOM/2)*2 .NE. JMOM) THEN
  POTENT(1)=POTS(1)
  POTENT(2)=POTT(2)
  POTENT(3)=POTS(4)
  POTENT(4)=POTS(6)
  POTENT(5)=POTS(5)
  POTENT(6)=POTS(3)
ELSE
  POTENT(1)=POTT(1)
  POTENT(2)=POTS(2)
  POTENT(3)=POTT(4)
  POTENT(4)=POTT(6)
  POTENT(5)=POTT(5)
  POTENT(6)=POTT(3)
END IF


POTENT=POTENT*CUTFAC/(4.0_DP*PI)**2/1000000.0_DP

IF (REL .EQ. 0 .AND. OSTAT .EQ. 2) THEN
  POTENT=FFF1*POTENT*FFF2
END IF



60 FORMAT (A,A,A,A,A,A)
61 FORMAT (A20,F7.3,A6,A21,F7.3,A4)
62 FORMAT (A10,F7.3,A4,A7,A16,F7.3,A4,A6,A9,F7.3,A4)
64 FORMAT (A20,F11.7,A17)
65 FORMAT (A36,F7.2,A4)
70 FORMAT (A20,F5.2,A)

END SUBROUTINE CHIRALOLD











      SUBROUTINE GAULEGMOD(X1,X2,X,W,N)
      INTEGER, PARAMETER           ::DP = SELECTED_REAL_KIND(15,99)

      INTEGER         ::N,M,I,J
      REAL(KIND=DP)   ::EPS,PI,XM,XL,Z,P1,P2,P3,PP,Z1

      REAL(KIND=DP) X1,X2,X(N),W(N)
      PARAMETER (EPS=3.0e-14_DP,PI=3.141592653589793238462643383279502884197_DP)
      M=(N+1)/2
      XM=0.5_DP*(X2+X1)
      XL=0.5_DP*(X2-X1)
      DO 12 I=1,M
        Z=COS(PI*(I-0.25_DP)/(N+0.5_DP))
1       CONTINUE
          P1=1.0
          P2=0.0
          DO 11 J=1,N
            P3=P2
            P2=P1
            P1=((2.0_DP*J-1.0_DP)*Z*P2-(J-1.0_DP)*P3)/J
11        CONTINUE
          PP=N*(Z*P1-P2)/(Z*Z-1.0_DP)
          Z1=Z
          Z=Z1-P1/PP
        IF(ABS(Z-Z1).GT.EPS)GO TO 1
        X(I)=XM-XL*Z
        X(N+1-I)=XM+XL*Z
        W(I)=2.0_DP*XL/((1.0_DP-Z*Z)*PP*PP)
        W(N+1-I)=W(I)
12    CONTINUE
      END SUBROUTINE GAULEGMOD







FUNCTION PL(N,X)                              !LEGENDRE POLINOME
IMPLICIT NONE
INTEGER, PARAMETER           ::DP = SELECTED_REAL_KIND(15,99)
REAL(KIND=DP)                ::X,PL
INTEGER                      ::N
INTENT(IN)                   ::N,X

PL=11111111.1111_DP
IF (N.EQ.0) THEN
  PL=1.0_DP
END IF
IF (N.EQ.1) THEN
  PL=X
END IF
IF (N.EQ.2) THEN
 PL=0.5_DP*(3.0_DP*X**2-1.0_DP)
END IF
IF (N.EQ.3) THEN
  PL=0.5_DP*(5.0_DP*X**3-3.0_DP*X)
END IF
IF (N.EQ.4) THEN
  PL=1.0_DP/8.0_DP*(35.0_DP*X**4-30.0_DP*X**2+3.0_DP)
END IF
IF (N.EQ.5) THEN
  PL=1.0_DP/8.0_DP*(63.0_DP*X**5-70.0_DP*X**3+15.0_DP*X)
END IF
IF (N.EQ.6) THEN
  PL=1.0_DP/16.0_DP*(231.0_DP*X**6-315.0_DP*X**4+105.0_DP*X**2-5.0_DP)
END IF
IF (N.EQ.7) THEN
  PL=1.0_DP/16.0_DP*(429.0_DP*X**7-693.0_DP*X**5+315.0_DP*X**3-35.0_DP*X)
END IF
IF (N.EQ.8) THEN
  PL=35.0_DP/128.0_DP-315.0_DP*X**2/32.0_DP+3465.0_DP*X**4/64.0_DP-3003.0_DP*X**6/32.0_DP+&
     6435.0_DP*X**8/128.0_DP
END IF
IF (N.EQ.9) THEN
  PL=315.0_DP*X/128.0_DP-1155.0_DP*X**3/32.0_DP+9009.0_DP*X**5/64.0_DP-6435.0_DP*X**7/32.0_DP+&
     12155.0_DP*X**9/128.0_DP
END IF
IF (PL.EQ.11111111.1111_DP) THEN
  WRITE(*,*)'Die Nummer J ist falsch gewaehlt.'
  STOP
END IF
RETURN
END FUNCTION PL







SUBROUTINE PARC(POT,POTEN,JMOM,NZPUN,QPUN,QPUNP,ZPUN,ZWEI)
IMPLICIT NONE
INTEGER                    ::K,NZPUN,JMOM
INTEGER, PARAMETER         ::DP = SELECTED_REAL_KIND(15,99)
REAL(KIND=DP)              ::SUM(6),POTEN(NZPUN),&
                             QPUN,QPUNP,ZPUN(NZPUN),ZWEI(NZPUN),&
                             POT(6),PI,QPUNDU
INTENT(IN)                 ::POTEN,JMOM,NZPUN,QPUN,QPUNP,ZPUN,ZWEI
INTENT(OUT)                ::POT
PARAMETER                    (PI=3.141592653589793238_DP)
!EXTERNAL PL


QPUNDU=QPUN+QPUNP

SUM=0.0_DP
IF (JMOM == 0) THEN
  DO K=1,NZPUN
    SUM(1)=SUM(1)+POTEN(K)*ZWEI(K)*PL(0,ZPUN(K))
    SUM(3)=SUM(3)+POTEN(K)*ZPUN(K)*ZWEI(K)*PL(0,ZPUN(K))
  END DO
ELSE
  DO K=1,NZPUN      
    SUM(1)=SUM(1)+POTEN(K)*ZWEI(K)*PL(JMOM,ZPUN(K))       
    SUM(2)=SUM(2)+POTEN(K)*ZWEI(K)*PL(JMOM,ZPUN(K))       
    SUM(3)=SUM(3)+POTEN(K)*ZWEI(K)*PL(JMOM+1,ZPUN(K))       
    SUM(4)=SUM(4)+POTEN(K)*ZWEI(K)*PL(JMOM-1,ZPUN(K))       
  END DO
END IF
POT=2.0_DP*PI*SUM
END SUBROUTINE PARC








SUBROUTINE PARSIG(POT,POTEN,JMOM,NZPUN,QPUN,QPUNP,ZPUN,ZWEI)
IMPLICIT NONE
INTEGER                    ::K,NZPUN,JMOM
INTEGER, PARAMETER         ::DP = SELECTED_REAL_KIND(15,99)
REAL(KIND=DP)              ::SUM(6),POTEN(NZPUN),&
                             QPUN,QPUNP,ZPUN(NZPUN),ZWEI(NZPUN),&
                             POT(6),PI,QPUNDU
INTENT(IN)                 ::POTEN,JMOM,NZPUN,QPUN,QPUNP,ZPUN,ZWEI
INTENT(OUT)                ::POT
PARAMETER                    (PI=3.141592653589793238_DP)
!EXTERNAL PL

QPUNDU=QPUN+QPUNP

SUM=0.0_DP
IF(JMOM == 0) THEN 
  DO K=1,NZPUN
    SUM(1)=SUM(1)-3.0_DP*POTEN(K)*ZWEI(K)*PL(0,ZPUN(K))
    SUM(3)=SUM(3)+POTEN(K)*ZPUN(K)*ZWEI(K)*PL(0,ZPUN(K))
  END DO
ELSE
  DO K=1,NZPUN      
    SUM(1)=SUM(1)-3.0_DP*POTEN(K)*ZWEI(K)*PL(JMOM,ZPUN(K))       
    SUM(2)=SUM(2)+POTEN(K)*ZWEI(K)*PL(JMOM,ZPUN(K))       
    SUM(3)=SUM(3)+POTEN(K)*ZWEI(K)*PL(JMOM+1,ZPUN(K))       
    SUM(4)=SUM(4)+POTEN(K)*ZWEI(K)*PL(JMOM-1,ZPUN(K))       
  END DO
END IF 
POT=2.0_DP*PI*SUM
END SUBROUTINE PARSIG









SUBROUTINE PARSL(POT,POTEN,JMOM,NZPUN,QPUN,QPUNP,ZPUN,ZWEI)
IMPLICIT NONE
INTEGER                    ::K,JMOM,NZPUN
INTEGER, PARAMETER         ::DP = SELECTED_REAL_KIND(15,99)
REAL(KIND=DP)              ::SUM(6),POTEN(NZPUN),&
                             QPUN,QPUNP,ZPUN(NZPUN),ZWEI(NZPUN),&
                             POT(6),PI
INTENT(IN)                 ::POTEN,JMOM,NZPUN,QPUN,QPUNP,ZPUN,ZWEI
INTENT(OUT)                ::POT
PARAMETER                    (PI=3.141592653589793238_DP)
!EXTERNAL PL


SUM=0.0_DP
IF (JMOM == 0) THEN
  DO K=1,NZPUN
     SUM(3)=SUM(3)+POTEN(K)*QPUN*QPUNP*(ZPUN(K)**2-1.0_DP)*ZWEI(K)*PL(0,ZPUN(K))
  END DO
ELSE
  DO K=1,NZPUN      
    SUM(2)=SUM(2)+POTEN(K)*QPUNP*QPUN/REAL(2*JMOM+1,KIND=DP)*ZWEI(K)*(PL(JMOM+1,ZPUN(K))-&
         PL(JMOM-1,ZPUN(K)))       
    SUM(3)=SUM(3)-POTEN(K)*QPUNP*QPUN*ZWEI(K)*(PL(JMOM,ZPUN(K))-ZPUN(K)*PL(JMOM+1,ZPUN(K)))       
    SUM(4)=SUM(4)-POTEN(K)*QPUNP*QPUN*ZWEI(K)*(PL(JMOM,ZPUN(K))-ZPUN(K)*PL(JMOM-1,ZPUN(K)))     
  END DO
END IF
POT=2.0_DP*PI*SUM
END SUBROUTINE PARSL









SUBROUTINE PARSIGL(POT,POTEN,JMOM,NZPUN,QPUN,QPUNP,ZPUN,ZWEI)
IMPLICIT NONE
INTEGER                    ::K,L,JMOM,NZPUN
INTEGER, PARAMETER         ::DP = SELECTED_REAL_KIND(15,99)
REAL(KIND=DP)              ::SUM(6),POTEN(NZPUN),&
                             QPUN,QPUNP,ZPUN(NZPUN),ZWEI(NZPUN),&
                             POT(6),PI,LLDUM
INTENT(IN)                 ::POTEN,JMOM,NZPUN,QPUN,QPUNP,ZPUN,ZWEI
INTENT(OUT)                ::POT  
PARAMETER                    (PI=3.141592653589793238_DP)
!EXTERNAL PL


L=JMOM
SUM=0.0_DP
IF (JMOM == 0) THEN
  DO K=1,NZPUN
      SUM(1)=SUM(1)+POTEN(K)*QPUN**2*QPUNP**2*(ZPUN(K)**2-1.0_DP)*ZWEI(K)*PL(0,ZPUN(K))
      SUM(3)=SUM(3)+POTEN(K)*QPUN**2*QPUNP**2*ZPUN(K)*(1.0_DP-ZPUN(K)**2)*ZWEI(K)*PL(0,ZPUN(K))
  END DO
ELSE
  DO K=1,NZPUN      
        SUM(1)=SUM(1)+POTEN(K)*QPUN**2*QPUNP**2*(ZPUN(K)**2-1.0_DP)*ZWEI(K)*PL(L,ZPUN(K))       
        SUM(2)=SUM(2)+POTEN(K)*QPUN**2*QPUNP**2*ZWEI(K)*(-PL(L,ZPUN(K))+&
             REAL(L-1,KIND=DP)/REAL(2*L+1,KIND=DP)*ZPUN(K)*PL(L+1,ZPUN(K))+&
             REAL(L+2,KIND=DP)/REAL(2*L+1,KIND=DP)*ZPUN(K)*PL(L-1,ZPUN(K)))       
        SUM(3)=SUM(3)+POTEN(K)*QPUN**2*QPUNP**2*ZWEI(K)*(REAL(2*L+3,KIND=DP)/&
             REAL(2*L+1,KIND=DP)*PL(L+1,ZPUN(K))-2.0_DP/REAL(2*L+1,KIND=DP)*ZPUN(K)*&
             PL(L,ZPUN(K))-ZPUN(K)**2*PL(L+1,ZPUN(K)))    
        SUM(4)=SUM(4)+POTEN(K)*QPUN**2*QPUNP**2*ZWEI(K)*(REAL(2*L-1,KIND=DP)/&
             REAL(2*L+1,KIND=DP)*PL(L-1,ZPUN(K))+2.0_DP/REAL(2*L+1,KIND=DP)*ZPUN(K)*&
             PL(L,ZPUN(K))-ZPUN(K)**2*PL(L-1,ZPUN(K)))
        LLDUM=REAL(L*(L+1),KIND=DP)
        SUM(5)=SUM(5)+2.0_DP*POTEN(K)*QPUN**2*QPUNP**2*ZWEI(K)*SQRT(LLDUM)/&
             REAL(2*L+1,KIND=DP)**2*(PL(L+1,ZPUN(K))-PL(L-1,ZPUN(K)))
  END DO
END IF
POT=2.0_DP*PI*SUM
END SUBROUTINE PARSIGL









SUBROUTINE PARSIGD(POT,POTEN,JMOM,NZPUN,QPUN,QPUNP,ZPUN,ZWEI)
IMPLICIT NONE
INTEGER                    ::K,L,JMOM,NZPUN
INTEGER, PARAMETER         ::DP = SELECTED_REAL_KIND(15,99)
REAL(KIND=DP)              ::SUM(6),POTEN(NZPUN),&
                             QPUN,QPUNP,ZPUN(NZPUN),ZWEI(NZPUN),&
                             POT(6),PI,LLDUM
INTENT(IN)                 ::POTEN,JMOM,NZPUN,QPUN,QPUNP,ZPUN,ZWEI
INTENT(OUT)                ::POT
PARAMETER                    (PI=3.141592653589793238_DP)
!EXTERNAL PL


L=JMOM
SUM=0.0_DP
IF (JMOM == 0) THEN
  DO K=1,NZPUN
      SUM(1)=SUM(1)+POTEN(K)*ZWEI(K)*(-QPUN**2-QPUNP**2+2.0_DP*QPUN*QPUNP*&
           ZPUN(K))*PL(0,ZPUN(K))
      SUM(3)=SUM(3)-POTEN(K)*ZWEI(K)*((QPUN**2+QPUNP**2)*ZPUN(K)-2.0_DP*QPUN*&
           QPUNP)*PL(0,ZPUN(K))
  END DO
ELSE
  DO K=1,NZPUN      
        SUM(1)=SUM(1)+POTEN(K)*ZWEI(K)*(-QPUN**2-QPUNP**2+2.0_DP*QPUN*QPUNP*&
           ZPUN(K))*PL(L,ZPUN(K))     
        SUM(2)=SUM(2)+POTEN(K)*ZWEI(K)*((QPUN**2+QPUNP**2)*PL(L,ZPUN(K))-&
             2.0_DP*QPUN*QPUNP/REAL(2*L+1,KIND=DP)*(REAL(L,KIND=DP)*PL(L+1,ZPUN(K))+&
             REAL(L+1,KIND=DP)*PL(L-1,ZPUN(K))))   
        SUM(3)=SUM(3)+POTEN(K)*ZWEI(K)/REAL(2*L+1,KIND=DP)*(-(QPUN**2+QPUNP**2)*&
             PL(L+1,ZPUN(K))+2.0_DP*QPUN*QPUNP*PL(L,ZPUN(K))) 
        SUM(4)=SUM(4)+POTEN(K)*ZWEI(K)/REAL(2*L+1,KIND=DP)*((QPUN**2+QPUNP**2)*&
             PL(L-1,ZPUN(K))-2.0_DP*QPUN*QPUNP*PL(L,ZPUN(K)))        
        LLDUM=REAL(L*(L+1),KIND=DP)
        SUM(5)=SUM(5)+2.0_DP*POTEN(K)*ZWEI(K)*SQRT(LLDUM)/&
             REAL(2*L+1,KIND=DP)*(QPUNP**2*PL(L+1,ZPUN(K))+&
             QPUN**2*PL(L-1,ZPUN(K))-2.0_DP*QPUN*QPUNP*PL(L,ZPUN(K)))
        SUM(6)=SUM(6)+2.0_DP*POTEN(K)*ZWEI(K)*SQRT(LLDUM)/&
             REAL(2*L+1,KIND=DP)*(QPUNP**2*PL(L-1,ZPUN(K))+&
             QPUN**2*PL(L+1,ZPUN(K))-2.0_DP*QPUN*QPUNP*PL(L,ZPUN(K)))
  END DO
END IF
POT=2.0_DP*PI*SUM
END SUBROUTINE PARSIGD









SUBROUTINE PARSIGK(POT,POTEN,JMOM,NZPUN,QPUN,QPUNP,ZPUN,ZWEI)
IMPLICIT NONE
INTEGER                    ::K,L,NZPUN,JMOM
INTEGER, PARAMETER         ::DP = SELECTED_REAL_KIND(15,99)
REAL(KIND=DP)              ::SUM(6),POTEN(NZPUN),&
                             QPUN,QPUNP,ZPUN(NZPUN),ZWEI(NZPUN),&
                             POT(6),PI,LLDUM
INTENT(IN)                 ::POTEN,JMOM,NZPUN,QPUN,QPUNP,ZPUN,ZWEI
INTENT(OUT)                ::POT
PARAMETER                    (PI=3.141592653589793238_DP)
!EXTERNAL PL


L=JMOM
SUM=0.0_DP
IF (JMOM == 0) THEN
  DO K=1,NZPUN
      SUM(1)=SUM(1)+POTEN(K)/4.0_DP*ZWEI(K)*(-QPUN**2-QPUNP**2-2.0_DP*QPUN*QPUNP*&
           ZPUN(K))*PL(0,ZPUN(K))
      SUM(3)=SUM(3)-POTEN(K)/4.0_DP*ZWEI(K)*((QPUN**2+QPUNP**2)*ZPUN(K)+2.0_DP*QPUN*QPUNP)*&
           PL(0,ZPUN(K))
  END DO
ELSE
  DO K=1,NZPUN      
        SUM(1)=SUM(1)-POTEN(K)/4.0_DP*ZWEI(K)*(QPUN**2+QPUNP**2+2.0_DP*QPUN*QPUNP*&
           ZPUN(K))*PL(L,ZPUN(K))     
        SUM(2)=SUM(2)+POTEN(K)/4.0_DP*ZWEI(K)*((QPUN**2+QPUNP**2)*PL(L,ZPUN(K))+&
             2.0_DP*QPUN*QPUNP/REAL(2*L+1,KIND=DP)*(REAL(L,KIND=DP)*&
             PL(L+1,ZPUN(K))+REAL(L+1,KIND=DP)*PL(L-1,ZPUN(K))))   
        SUM(3)=SUM(3)+POTEN(K)/4.0_DP*ZWEI(K)/REAL(2*L+1,KIND=DP)*(-(QPUN**2+QPUNP**2)*&
             PL(L+1,ZPUN(K))-2.0_DP*QPUN*QPUNP*PL(L,ZPUN(K))) 
        SUM(4)=SUM(4)+POTEN(K)/4.0_DP*ZWEI(K)/REAL(2*L+1,KIND=DP)*((QPUN**2+QPUNP**2)*&
             PL(L-1,ZPUN(K))+2.0_DP*QPUN*QPUNP*PL(L,ZPUN(K))) 
        LLDUM=REAL(L*(L+1),KIND=DP)
        SUM(5)=SUM(5)+1.0_DP/2.0_DP*POTEN(K)*ZWEI(K)*SQRT(LLDUM)/&
             REAL(2*L+1,KIND=DP)*(QPUNP**2*PL(L+1,ZPUN(K))+&
             QPUN**2*PL(L-1,ZPUN(K))+2.0_DP*QPUN*QPUNP*PL(L,ZPUN(K)))
        SUM(6)=SUM(6)+1.0_DP/2.0_DP*POTEN(K)*ZWEI(K)*SQRT(LLDUM)/&
             REAL(2*L+1,KIND=DP)*(QPUNP**2*PL(L-1,ZPUN(K))+&
             QPUN**2*PL(L+1,ZPUN(K))+2.0_DP*QPUN*QPUNP*PL(L,ZPUN(K)))
  END DO
END IF
POT=2.0_DP*PI*SUM
END SUBROUTINE PARSIGK










SUBROUTINE TRNSMOD1(NP1,NP2,NP,P1,P2,P3,XP,AP)
!     ===============
!
!     TRNS BELEGT DIE FELDER XP UND AP MIT TRANSFORMIERTEN
!     GAUSS-LEGENDRE-PUNKTEN UND GEWICHTEN
!
!     NP1 PUNKTE WERDEN UEBER DIE HYPERBOLISCHE TRANSFORMATION
!
!     X --> (1.+X) / (1./P1-(1./P1-2./P2)*X)
!
!     AUF DAS INTERVALL (0.;P2) ABGEBILDET, WOBEI
!     NP1/2 PUNKTE IN (0.;P1) UND
!     NP1/2 PUNKTE IN (P1;P2) LIEGEN
!
!     NP2 PUNKTE WERDEN UEBER DIE LINEARE TRANSFORMATION
!
!     X --> (P3+P2)/2. + (P3-P2)/2.*X
!
!     AUF DAS INTERVALL (P2;P3) ABGEBILDET
!
!     NP = NP1 + NP2
!
      IMPLICIT NONE 
      INTEGER NP,NP1,NP2,I
      INTEGER, PARAMETER         ::DP = SELECTED_REAL_KIND(15,99)
      REAL(KIND=DP)  XP1(500),AP1(500),XP2(500),AP2(500)
      REAL(KIND=DP)  XP(NP),AP(NP),P1,P2,P3,X,A
      REAL(KIND=DP)  XX,DELPH
      INTENT(IN)                 ::NP1,NP2,NP,P1,P2,P3
      INTENT(OUT)                ::XP,AP

      IF(NP1.GT.500) STOP 'NP1 in TRNS'
      IF(NP2.GT.500) STOP 'NP2 in TRNS'


      CALL gaulegmod(-1.0_DP,1.0_DP,XP1,AP1,NP1)

 

      DO I=1,NP1
         X=XP1(I)
         A=AP1(I)
         XX=1.0_DP/P1-(1.0_DP/P1-2.0_DP/P2)*X
         XP1(I)=(1.0_DP+X) / XX
         AP1(I)=(2.0_DP/P1-2.0_DP/P2)*A / XX**2
      END DO
!
      IF(NP2 .NE. 0) THEN

      CALL gaulegmod(-1.0_DP,1.0_DP,XP2,AP2,NP2)


      DO I=1,NP2
         X=XP2(I)
         A=AP2(I)
         DELPH=(P3-P2)/2.0_DP
         XP2(I)=(P3+P2)/2.0_DP + DELPH*X
         AP2(I)=DELPH*A
      END DO
      ENDIF
!
      DO I=1,NP1
         XP(I)=XP1(I)
         AP(I)=AP1(I)
      END DO
!
      IF(NP2 .NE. 0) THEN
      DO I=1,NP2
         XP(I+NP1)=XP2(I)
         AP(I+NP1)=AP2(I)
      END DO
      ENDIF
!
      RETURN
      END SUBROUTINE





!****************************      n3lo      ************************************

SUBROUTINE SPLSETUP(QPUN) 

USE TPEN3LO
IMPLICIT NONE
INTEGER, PARAMETER         ::DP = SELECTED_REAL_KIND(15,99)
REAL(KIND=DP)              ::QPUN

IF (QPUN .LE. QV(NQV)) THEN
   CALL SPLMODEE1(QV,NQV,QPUN,SPL,FFAK1,FFAK2,FFAK3)
END IF

END SUBROUTINE SPLSETUP



FUNCTION VCN3(QPUN)

USE TPEN3LO
IMPLICIT NONE
INTEGER, PARAMETER         ::DP = SELECTED_REAL_KIND(15,99)
INTEGER                    ::i
REAL(KIND=DP)              ::VCN3,QPUN
!EXTERNAL SPLMODEE1

IF (QPUN .GE. QV(NQV) .OR. QPUN .LE. QV(1)) THEN
!   STOP 'in functip VCN3: QPUN is too large'
   VCN3=0.0_DP
ELSE
  VCN3=0.0_DP
  DO I=1,NQV
     VCN3=VCN3+SPL(I)*VCQ(I)
  END DO
END IF

END FUNCTION VCN3






FUNCTION WSN3(QPUN)

USE TPEN3LO
IMPLICIT NONE
INTEGER, PARAMETER         ::DP = SELECTED_REAL_KIND(15,99)
INTEGER                    ::i
REAL(KIND=DP)              ::WSN3,QPUN
!EXTERNAL SPLMODEE1

IF (QPUN .GE. QV(NQV) .OR. QPUN .LE. QV(1)) THEN
!   STOP 'in functip WSN3: QPUN is too large'
   WSN3=0.0_DP
ELSE
  WSN3=0.0_DP
  DO I=1,NQV
     WSN3=WSN3+SPL(I)*WSQ(I)
  END DO
END IF

END FUNCTION WSN3






FUNCTION WTN3(QPUN)

USE TPEN3LO
IMPLICIT NONE
INTEGER, PARAMETER         ::DP = SELECTED_REAL_KIND(15,99)
INTEGER                    ::i
REAL(KIND=DP)              ::WTN3,QPUN
!EXTERNAL SPLMODEE1

IF (QPUN .GE. QV(NQV) .OR. QPUN .LE. QV(1)) THEN
!   STOP 'in functip WTN3: QPUN is too large'
   WTN3=0.0_DP
ELSE
  WTN3=0.0_DP
  DO I=1,NQV
     WTN3=WTN3-SPL(I)*WSQ(I)/QPUN**2
  END DO
END IF

END FUNCTION WTN3







FUNCTION VS1N3(QPUN)

USE TPEN3LO
IMPLICIT NONE
INTEGER, PARAMETER         ::DP = SELECTED_REAL_KIND(15,99)
INTEGER                    ::i
REAL(KIND=DP)              ::VS1N3,QPUN
!EXTERNAL SPLMODEE1

IF (QPUN .GE. QV(NQV) .OR. QPUN .LE. QV(1)) THEN
!   STOP 'in functip VS1N3: QPUN is too large'
   VS1N3=0.0_DP
ELSE 
  VS1N3=0.0_DP
  DO I=1,NQV
     VS1N3=VS1N3+SPL(I)*VS1Q(I)
  END DO
END IF

END FUNCTION VS1N3






FUNCTION VS2N3(QPUN)

USE TPEN3LO
IMPLICIT NONE
INTEGER, PARAMETER         ::DP = SELECTED_REAL_KIND(15,99)
INTEGER                    ::i
REAL(KIND=DP)              ::VS2N3,QPUN
!EXTERNAL SPLMODEE1

IF (QPUN .GE. QV(NQV) .OR. QPUN .LE. QV(1)) THEN
!   STOP 'in functip VS2N3: QPUN is too large'
   VS2N3=0.0_DP
ELSE
  VS2N3=0.0_DP
  DO I=1,NQV
     VS2N3=VS2N3+SPL(I)*VS2Q(I)
  END DO
END IF

END FUNCTION VS2N3









FUNCTION VT1N3(QPUN)

USE TPEN3LO
IMPLICIT NONE
INTEGER, PARAMETER         ::DP = SELECTED_REAL_KIND(15,99)
INTEGER                    ::i
REAL(KIND=DP)              ::VT1N3,QPUN
!EXTERNAL SPLMODEE1

IF (QPUN .GE. QV(NQV) .OR. QPUN .LE. QV(1)) THEN
!   STOP 'in functip VT1N3: QPUN is too large'
   VT1N3=0.0_DP
ELSE
  VT1N3=0.0_DP
  DO I=1,NQV
     VT1N3=VT1N3-SPL(I)*VS1Q(I)/QPUN**2
  END DO
END IF

END FUNCTION VT1N3






FUNCTION VT2N3(QPUN)

USE TPEN3LO
IMPLICIT NONE
INTEGER, PARAMETER         ::DP = SELECTED_REAL_KIND(15,99)
INTEGER                    ::i
REAL(KIND=DP)              ::VT2N3,QPUN
!EXTERNAL SPLMODEE1

IF (QPUN .GE. QV(NQV) .OR. QPUN .LE. QV(1)) THEN
!   STOP 'in functip VT2N3: QPUN is too large'
   VT2N3=0.0_DP
ELSE
  VT2N3=0.0_DP
  DO I=1,NQV
     VT2N3=VT2N3-SPL(I)*VS2Q(I)/QPUN**2
  END DO
END IF

END FUNCTION VT2N3








FUNCTION WC1N3(QPUN)

USE TPEN3LO
IMPLICIT NONE
INTEGER, PARAMETER         ::DP = SELECTED_REAL_KIND(15,99)
INTEGER                    ::i
REAL(KIND=DP)              ::WC1N3,QPUN
!EXTERNAL SPLMODEE1

IF (QPUN .GE. QV(NQV) .OR. QPUN .LE. QV(1)) THEN
!   STOP 'in functip WC1N3: QPUN is too large'
   WC1N3=0.0_DP
ELSE
  WC1N3=0.0_DP
  DO I=1,NQV
     WC1N3=WC1N3+SPL(I)*WC1Q(I)
  END DO
END IF

END FUNCTION WC1N3






FUNCTION WC2N3(QPUN)

USE TPEN3LO
IMPLICIT NONE
INTEGER, PARAMETER         ::DP = SELECTED_REAL_KIND(15,99)
INTEGER                    ::i
REAL(KIND=DP)              ::WC2N3,QPUN
!EXTERNAL SPLMODEE1

IF (QPUN .GE. QV(NQV) .OR. QPUN .LE. QV(1)) THEN
!   STOP 'in functip WC2N3: QPUN is too large'
   WC2N3=0.0_DP
ELSE
  WC2N3=0.0_DP
  DO I=1,NQV
     WC2N3=WC2N3+SPL(I)*WC2Q(I)
  END DO
END IF

END FUNCTION WC2N3






FUNCTION WC3N3(QPUN)

USE TPEN3LO
IMPLICIT NONE
INTEGER, PARAMETER         ::DP = SELECTED_REAL_KIND(15,99)
INTEGER                    ::i
REAL(KIND=DP)              ::WC3N3,QPUN
!EXTERNAL SPLMODEE1

IF (QPUN .GE. QV(NQV) .OR. QPUN .LE. QV(1)) THEN
!   STOP 'in functip WC3N3: QPUN is too large'
   WC3N3=0.0_DP
ELSE
  WC3N3=0.0_DP
  DO I=1,NQV
     WC3N3=WC3N3+SPL(I)*WC3Q(I)
  END DO
END IF

END FUNCTION WC3N3






FUNCTION WC4N3(QPUN)

USE TPEN3LO
IMPLICIT NONE
INTEGER, PARAMETER         ::DP = SELECTED_REAL_KIND(15,99)
INTEGER                    ::i
REAL(KIND=DP)              ::WC4N3,QPUN
!EXTERNAL SPLMODEE1

IF (QPUN .GE. QV(NQV) .OR. QPUN .LE. QV(1)) THEN
!   STOP 'in functip WC4N3: QPUN is too large'
   WC4N3=0.0_DP
ELSE
  WC4N3=0.0_DP
  DO I=1,NQV
     WC4N3=WC4N3+SPL(I)*WC4Q(I)
  END DO
END IF

END FUNCTION WC4N3






FUNCTION VCC1N3(QPUN)

USE PARAMETERS
USE LEC
IMPLICIT NONE
INTEGER, PARAMETER         ::DP = SELECTED_REAL_KIND(15,99)
REAL(KIND=DP)              ::VCC1N3,QPUN,L,OM

OM=SQRT(4.0_DP*MPI**2+QPUN**2)
L=OM/QPUN/2.0_DP*LOG((2.0_DP*LAM**2*QPUN**2+4.0_DP*MPI**2*LAM**2-4.0_DP*MPI**2*QPUN**2+2.0_DP*LAM*QPUN*&
  SQRT((LAM**2-4.0_DP*MPI**2)*(QPUN**2+4.0_DP*MPI**2)))/(4.0_DP*MPI**2*(LAM**2+QPUN**2)))
VCC1N3=FAKVCC*L/20.0_DP*OM**4*C2**2

END FUNCTION VCC1N3




FUNCTION VCC2N3(QPUN)

USE PARAMETERS
USE LEC
IMPLICIT NONE
INTEGER, PARAMETER         ::DP = SELECTED_REAL_KIND(15,99)
REAL(KIND=DP)              ::VCC2N3,QPUN,L,OM

OM=SQRT(4.0_DP*MPI**2+QPUN**2)
L=OM/QPUN/2.0_DP*LOG((2.0_DP*LAM**2*QPUN**2+4.0_DP*MPI**2*LAM**2-4.0_DP*MPI**2*QPUN**2+2.0_DP*LAM*QPUN*&
  SQRT((LAM**2-4.0_DP*MPI**2)*(QPUN**2+4.0_DP*MPI**2)))/(4.0_DP*MPI**2*(LAM**2+QPUN**2)))
VCC2N3=FAKVCC*L*(2.0_DP*MPI**2+QPUN**2)**2*C3**2

END FUNCTION VCC2N3





FUNCTION VCC3N3(QPUN)

USE PARAMETERS
USE LEC
IMPLICIT NONE
INTEGER, PARAMETER         ::DP = SELECTED_REAL_KIND(15,99)
REAL(KIND=DP)              ::VCC3N3,QPUN,L,OM


OM=SQRT(4.0_DP*MPI**2+QPUN**2)
L=OM/QPUN/2.0_DP*LOG((2.0_DP*LAM**2*QPUN**2+4.0_DP*MPI**2*LAM**2-4.0_DP*MPI**2*QPUN**2+2.0_DP*LAM*QPUN*&
  SQRT((LAM**2-4.0_DP*MPI**2)*(QPUN**2+4.0_DP*MPI**2)))/(4.0_DP*MPI**2*(LAM**2+QPUN**2)))
VCC3N3=FAKVCC*L*16.0_DP*MPI**4*C1**2

END FUNCTION VCC3N3





FUNCTION VCC4N3(QPUN)

USE PARAMETERS
USE LEC
IMPLICIT NONE
INTEGER, PARAMETER         ::DP = SELECTED_REAL_KIND(15,99)
REAL(KIND=DP)              ::VCC4N3,QPUN,L,OM


OM=SQRT(4.0_DP*MPI**2+QPUN**2)
L=OM/QPUN/2.0_DP*LOG((2.0_DP*LAM**2*QPUN**2+4.0_DP*MPI**2*LAM**2-4.0_DP*MPI**2*QPUN**2+2.0_DP*LAM*QPUN*&
  SQRT((LAM**2-4.0_DP*MPI**2)*(QPUN**2+4.0_DP*MPI**2)))/(4.0_DP*MPI**2*(LAM**2+QPUN**2)))
VCC4N3=FAKVCC*L/3.0_DP*OM**2*(2.0_DP*MPI**2+QPUN**2)*C2*C3

END FUNCTION VCC4N3





FUNCTION VCC5N3(QPUN)

USE PARAMETERS
USE LEC
IMPLICIT NONE
INTEGER, PARAMETER         ::DP = SELECTED_REAL_KIND(15,99)
REAL(KIND=DP)              ::VCC5N3,QPUN,L,OM


OM=SQRT(4.0_DP*MPI**2+QPUN**2)
L=OM/QPUN/2.0_DP*LOG((2.0_DP*LAM**2*QPUN**2+4.0_DP*MPI**2*LAM**2-4.0_DP*MPI**2*QPUN**2+2.0_DP*LAM*QPUN*&
  SQRT((LAM**2-4.0_DP*MPI**2)*(QPUN**2+4.0_DP*MPI**2)))/(4.0_DP*MPI**2*(LAM**2+QPUN**2)))
VCC5N3=-FAKVCC*L*4.0_DP/3.0_DP*OM**2*MPI**2*C1*C2

END FUNCTION VCC5N3




FUNCTION VCC6N3(QPUN)

USE PARAMETERS
USE LEC
IMPLICIT NONE
INTEGER, PARAMETER         ::DP = SELECTED_REAL_KIND(15,99)
REAL(KIND=DP)              ::VCC6N3,QPUN,L,OM

OM=SQRT(4.0_DP*MPI**2+QPUN**2)
L=OM/QPUN/2.0_DP*LOG((2.0_DP*LAM**2*QPUN**2+4.0_DP*MPI**2*LAM**2-4.0_DP*MPI**2*QPUN**2+2.0_DP*LAM*QPUN*&
  SQRT((LAM**2-4.0_DP*MPI**2)*(QPUN**2+4.0_DP*MPI**2)))/(4.0_DP*MPI**2*(LAM**2+QPUN**2)))
VCC6N3=-FAKVCC*L*8.0_DP*MPI**2*(2.0_DP*MPI**2+QPUN**2)*C1*C3

END FUNCTION VCC6N3




FUNCTION WCTN3(QPUN)

USE PARAMETERS
USE LEC
IMPLICIT NONE
INTEGER, PARAMETER         ::DP = SELECTED_REAL_KIND(15,99)
REAL(KIND=DP)              ::WCTN3,QPUN,L,OM


OM=SQRT(4.0_DP*MPI**2+QPUN**2)
L=OM/QPUN/2.0_DP*LOG((2.0_DP*LAM**2*QPUN**2+4.0_DP*MPI**2*LAM**2-4.0_DP*MPI**2*QPUN**2+2.0_DP*LAM*QPUN*&
  SQRT((LAM**2-4.0_DP*MPI**2)*(QPUN**2+4.0_DP*MPI**2)))/(4.0_DP*MPI**2*(LAM**2+QPUN**2)))
WCTN3=FAKVCT*L*OM**2*C4**2

END FUNCTION WCTN3




FUNCTION WCSN3(QPUN)

USE PARAMETERS
USE LEC
IMPLICIT NONE
INTEGER, PARAMETER         ::DP = SELECTED_REAL_KIND(15,99)
REAL(KIND=DP)              ::WCSN3,QPUN,L,OM

OM=SQRT(4.0_DP*MPI**2+QPUN**2)
L=OM/QPUN/2.0_DP*LOG((2.0_DP*LAM**2*QPUN**2+4.0_DP*MPI**2*LAM**2-4.0_DP*MPI**2*QPUN**2+2.0_DP*LAM*QPUN*&
  SQRT((LAM**2-4.0_DP*MPI**2)*(QPUN**2+4.0_DP*MPI**2)))/(4.0_DP*MPI**2*(LAM**2+QPUN**2)))
!*EE
!WCSN3=FAKVCT*L*OM**2*QPUN**2
WCSN3=-FAKVCT*L*OM**2*QPUN**2*C4**2

END FUNCTION WCSN3






SUBROUTINE N3LO

USE INTX
USE INTMU
USE TPEN3LO
USE PARAMETERS
USE LEC
IMPLICIT NONE
INTEGER, PARAMETER         ::DP = SELECTED_REAL_KIND(15,99)
INTEGER                    ::I,J,K,L
REAL(KIND=DP)              ::QINT(NINT),WINT(NINT),&
                             QMU(NMU),WMU(NMU),&
                             FAK1,FAK2,FAK3,FAK4,FAK5,FAK6,FAK7,&
                             MPIQ,GAQ,MU,MUQ,KMU,KMUQ,&
                             VC(NMU),WS(NMU),VS1(NMU),VS2(NMU),&
                             WC1(NMU),WC2(NMU),WC3(NMU),WC4(NMU),&
                             PREF1,PREF2

COMMON/INT/                  QINT,WINT


CALL TRNSMOD1(NINT1,NINT2,NINT,LAMINT1,LAMINT2,LAMINT3,QINT,WINT)

IF ((LAM .GE. LAMMU2 + 0.009_DP) .AND. (LAM .LE. 0.9_DP)) THEN 
  CALL TRNSMOD1(NMU1,NMU2,NMU,LAMMU1-2.0_DP*MPI,LAMMU2-2.0_DP*MPI,LAM-2.0_DP*MPI,QMU,WMU)
ELSE
  WRITE(*,*)'wrong LAM'
  STOP
END IF

DO I=1,NMU
   QMU(I)=QMU(I)+2.0_DP*MPI
END DO



FAK1=GA**4/(PI*(4.0_DP*FPI)**6)
FAK2=2.0_DP*GA**6/(8.0_DP*PI*FPI**2)**3
FAK3=GA**2/(8.0_DP*PI*FPI**4)
FAK4=2.0_DP*GA**6/(8.0_DP*PI*FPI**2)**3
FAK5=1.0_DP/(24.0_DP*FPI**4*PI)
FAK6=1.0_DP/(60.0_DP*FPI**4*PI)
FAK7=2.0_DP/(3.0_DP*(8.0_DP*PI*FPI**2)**3)
MPIQ=MPI**2
GAQ=GA**2


DO I=1,NMU
   MU=QMU(I)
   MUQ=MU**2
   KMU=SQRT(MUQ/4.0_DP-MPIQ)
   KMUQ=KMU**2
   VC(I)=3.0_DP*FAK1*(MUQ-2.0_DP*MPIQ)/MU*((MPIQ-2.0_DP*MUQ)*(2.0_DP*MPI+&
         (2.0_DP*MPIQ-MUQ)/(2.0_DP*MU)*LOG((MU+2.0_DP*MPI)/(MU-2.0_DP*MPI)))+&
         4.0_DP*GAQ*MPI*(2.0_DP*MPIQ-MUQ))
   WS(I)=FAK1*(MUQ-4.0_DP*MPIQ)*((MPIQ-MUQ/4.0_DP)*LOG((MU+2.0_DP*MPI)/(MU-2.0_DP*MPI))+&
         (1.0_DP+2.0_DP*GAQ)*MU*MPI)
   VS1(I)=FAK3*MU*KMU**3*D14M15
   VS2(I)=FAK4*MU*KMU**3*(-1.0_DP/9.0_DP+(INTEG1(MU)-INTEG2(MU)))
   WC1(I)=FAK5*(2.0_DP*(-1.0_DP+GAQ)*KMUQ+3.0_DP*GAQ*(2.0_DP*MPIQ-MUQ))*KMU/MU*&
          (2.0_DP*MPIQ-MUQ)*D1P2
   WC2(I)=FAK5*(2.0_DP*(-1.0_DP+GAQ)*KMUQ+3.0_DP*GAQ*(2.0_DP*MPIQ-MUQ))*KMU/MU*&
          4.0_DP*MPIQ*D5
   WC3(I)=-FAK6*KMU**3/MU*(6.0_DP*(-1.0_DP+GAQ)*KMUQ+5.0_DP*GAQ*(2.0_DP*MPIQ-MUQ))*D3
   WC4(I)=1.0_DP/(92160.0_DP*FPI**6*MUQ*PI**3)*(-320.0_DP*(1.0_DP+2.0_DP*GAQ)**2*MPI**6+&
          240.0_DP*(1.0_DP+6.0_DP*GAQ+8.0_DP*GA**4)*MPI**4*MUQ-60.0_DP*GAQ*(8.0_DP+15.0_DP*GAQ)&
                  *MPIQ*MU**4+&
          (-4.0_DP+29.0_DP*GA**2+122.0_DP*GA**4+3.0_DP*GA**6)*MU**6)*LOG((MU+2.0_DP*KMU)/(2.0_DP*MPI))+&
!
          KMU/(2700.0_DP*MU*(8.0_DP*PI*FPI**2)**3)*(-16.0_DP*(171.0_DP+2.0_DP*GAQ*(1.0_DP+GAQ)*&
          (327.0_DP+49.0_DP*GAQ))*&
          MPI**4+4.0_DP*(-73.0_DP+1748.0_DP*GA**2+2549.0_DP*GA**4+726.0_DP*GA**6)*MPIQ*MUQ-&
          (-64.0_DP+389.0_DP*GA**2+1782.0_DP*GA**4+1093.0_DP*GA**6)*MU**4)+&
!
          2.0_DP*KMU/(3.0_DP*MU*(8.0_DP*PI*FPI**2)**3)*(-GA**6*(MUQ-2.0_DP*MPIQ)**2*INTEG1(MU)+&
          2.0_DP*GA**4*(2.0_DP*GA**2-1.0_DP)*KMU**2*(MUQ-2.0_DP*MPIQ)*INTEG2(MU))
END DO


QV(1)=0.00000000001_DP
DO I=2,NQV1
   QV(I)=QV(I-1)+LAMQV1/REAL(NQV1-1,KIND=DP)
END DO
DO I=1,NQV2
   QV(NQV1+I)=QV(NQV1+I-1)+(LAMQV2-LAMQV1)/REAL(NQV2,KIND=DP)
END DO
DO I=1,NQV3
   QV(NQV1+NQV2+I)=QV(NQV1+NQV2+I-1)+(LAMQV3-LAMQV2)/REAL(NQV3,KIND=DP)
END DO



VCQ=0.0_DP
WSQ=0.0_DP
VS1Q=0.0_DP
VS2Q=0.0_DP
WC1Q=0.0_DP
WC2Q=0.0_DP
WC3Q=0.0_DP
WC4Q=0.0_DP
WTQ=0.0_DP
VT1Q=0.0_DP
VT2Q=0.0_DP

DO I=1,NQV
   PREF1=-2.0_DP*QV(I)**6/PI
   DO J=1,NMU
      PREF2=1.0_DP/(QMU(J)**5*(QMU(J)**2+QV(I)**2))*WMU(J)
      VCQ(I)=VCQ(I)+PREF1*PREF2*VC(J)
      WSQ(I)=WSQ(I)+PREF1*PREF2*WS(J)
      VS1Q(I)=VS1Q(I)+PREF1*PREF2*VS1(J)
      VS2Q(I)=VS2Q(I)+PREF1*PREF2*VS2(J)
      WC1Q(I)=WC1Q(I)+PREF1*PREF2*WC1(J)
      WC2Q(I)=WC2Q(I)+PREF1*PREF2*WC2(J)
      WC3Q(I)=WC3Q(I)+PREF1*PREF2*WC3(J)
      WC4Q(I)=WC4Q(I)+PREF1*PREF2*WC4(J)
   END DO
   WTQ(I)=-WSQ(I)/QV(I)**2
   VT1Q(I)=-VS1Q(I)/QV(I)**2
   VT2Q(I)=-VS2Q(I)/QV(I)**2
END DO

CALL SPLFAKEE1(QV,NQV,FFAK1,FFAK2,FFAK3)


END SUBROUTINE N3LO










FUNCTION INTEG1(MUPUN)

USE INTX
USE PARAMETERS
IMPLICIT NONE
INTEGER, PARAMETER         ::DP = SELECTED_REAL_KIND(15,99)
INTEGER                    ::I
REAL(KIND=DP)              ::MUPUN,INTEG1,QINT(NINT),WINT(NINT),FUN,K,X

COMMON/INT/                  QINT,WINT

FUN(X)=MPI**2/(K**2*X**2)-(1.0_DP+MPI**2/(K**2*X**2))**1.5_DP*&
        LOG((K*X+SQRT(MPI**2+K**2*X**2))/MPI)


K=SQRT(MUPUN**2/4.0_DP-MPI**2)
INTEG1=0.0_DP
DO I=1,NINT
   IF (K*QINT(I) .LE. 0.00025_DP) THEN
      INTEG1=INTEG1+(-4.0_DP/3.0_DP-(K*QINT(I)/MPI)**2/5.0_DP+(K*QINT(I)/MPI)**4*2.0_DP/35.0_DP)*WINT(I)
   ELSE
      INTEG1=INTEG1+FUN(QINT(I))*WINT(I)
   END IF
END DO

END FUNCTION INTEG1







FUNCTION INTEG2(MUPUN)

USE INTX
USE PARAMETERS
IMPLICIT NONE
INTEGER, PARAMETER         ::DP = SELECTED_REAL_KIND(15,99)
INTEGER                    ::I
REAL(KIND=DP)              ::MUPUN,INTEG2,QINT(NINT),WINT(NINT),FUN,K,X

COMMON/INT/                  QINT,WINT

FUN(X)=MPI**2/(K**2*X**2)-(1.0_DP+MPI**2/(K**2*X**2))**1.5_DP*&
        LOG((K*X+SQRT(MPI**2+K**2*X**2))/MPI)


K=SQRT(MUPUN**2/4.0_DP-MPI**2)
INTEG2=0.0_DP
DO I=1,NINT
   IF (K*QINT(I) .LE. 0.00025_DP) THEN
      INTEG2=INTEG2+(-4.0_DP/3.0_DP-(K*QINT(I)/MPI)**2/5.0_DP+(K*QINT(I)/MPI)**4*2.0_DP/35.0_DP)*&
             WINT(I)*QINT(I)**2
   ELSE
      INTEG2=INTEG2+FUN(QINT(I))*WINT(I)*QINT(I)**2
   END IF
END DO

END FUNCTION INTEG2




      SUBROUTINE SPLFAKEE1(X,N,fak1,fak2,fak3)
!============================
!      IMPLICIT REAL(KIND=DP) (A-Z)
!     DIE 2.ABLEITUNGEN AN DEN RAENDERN MUESSEN = 0 SEIN !
!     MIT DEN N STUETZSTELLEN X WIRD DER SPLINE AUFGEBAUT
IMPLICIT NONE
INTEGER, PARAMETER         ::DP = SELECTED_REAL_KIND(15,99)
INTEGER                    :: n,n1,i,j,n2,n3,k,l,j1
REAL(KIND=DP)              :: fak1(n,n),fak2(n,n),fak3(n,n),X(N),&
                         HI(N+20),U(N+20),Q(N+20,N+20),C(N+20,N+20),&
                         ax,bx,am,al,pi,h1,h2,h3,cx
     
      IF (N.LE.0) STOP 'SPLFAK2: N.LE.0'
      U(1)=0.0_DP
      HI(2)=X(2)-X(1)
      N1=N-1
      DO 10 I=2,N1
      AX=X(I+1)-X(I)
      HI(I+1)=AX
      BX=X(I+1)-X(I-1)
      CX=X(I)-X(I-1)
      AL=AX/BX
      AM=1.0_DP-AL
      PI=1.0_DP/(2.0_DP-AM*U(I-1))
      U(I)=AL*PI
      DO 20 J=1,N
      Q(1,J)=0.0_DP
      H1=0.0_DP
      H2=0.0_DP
      H3=0.0_DP
      IF(J.EQ.I-1) H1=1.0_DP/(CX*BX)
      IF(J.EQ.I) H2=1.0_DP/(CX*AX)
      IF(J.EQ.I+1) H3=1.0_DP/(AX*BX)
      Q(I,J)=-PI*(AM*Q(I-1,J)-H1+H2-H3)
  20  CONTINUE
  10  CONTINUE
      N2=N+1
      N3=N+2
      DO 30 K=3,N2
      J1=N3-K
      H1=1.0_DP/HI(J1+1)
      DO 40 L=1,N
      C(N,L)=0.0_DP
      C(J1,L)=Q(J1,L)-C(J1+1,L)*U(J1)
      FAK1(J1,L)=-HI(J1+1)*(2.0_DP*C(J1,L)+C(J1+1,L))
      IF(L.EQ.J1) FAK1(J1,L)=FAK1(J1,L)-H1
      IF(L.EQ.J1+1) FAK1(J1,L)=FAK1(J1,L)+H1
      FAK2(J1,L)=3.0_DP*C(J1,L)
      FAK3(J1,L)=(C(J1+1,L)-C(J1,L))*H1
      FAK1(N,L)=0.0_DP
      FAK2(N,L)=0.0_DP
      FAK3(N,L)=0.0_DP
  40  CONTINUE
  30  CONTINUE
      RETURN
      END SUBROUTINE
      
      
      
      SUBROUTINE SPLMODEE1(X,N,XA,SPL,fak1,fak2,fak3)
!==================================
      IMPLICIT NONE
INTEGER, PARAMETER         ::DP = SELECTED_REAL_KIND(15,99)
!     MITTELS N STUETZSTELLEN X WERDEN DIE FUNKTIONSWERTE SPL
!     AN BELIEBIGEN STELLEN XA INTERPOLIERT
!     IM HP MUSS ZUR ENDGUELTIGEN RECHNUNG NOCH
!     SUMME UEBER J SPL(J)*Y(J) GEBILDET WERDEN
INTEGER               :: i,n,j,i1
REAL(KIND=DP)         :: fak1(n,n),fak2(n,n),fak3(n,n),x(n),spl(n),xa,dx

      IF (N.LE.0) STOP 'SPLMOD2: N.LE.0'
   1  I=0
   2  I=I+1
      IF(I.GT.N) GO TO 3
      IF(XA.GE.X(I)) GO TO 2
   3  I1=I-1
      IF(I1.EQ.0) I1=1
      DX=XA-X(I1)
      DO 10 J=1,N
      SPL(J)=((FAK3(I1,J)*DX+FAK2(I1,J))*DX+FAK1(I1,J))*DX
      IF(J.EQ.I1) SPL(J)=SPL(J)+1.
  10  CONTINUE
      RETURN
      END SUBROUTINE

END MODULE chiral_n3lo




