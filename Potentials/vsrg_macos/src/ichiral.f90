!**************************************************************************************************
!**************************************************************************************************
!**************************************************************************************************
!****                                                                                          ****
!****      This library containes subroutines to generate improved chiral NN potentials        ****
!****      (i-chiral) up to N4LO. For notations and definitions, see:                          ****
!****             E.Epelbaum, H.Krebs, U.-G.Mei√üner, arXiv:1412.0142[nucl-th],                 ****
!****                                                arXiv:1412.4623[nucl-th],                 ****
!****                                                                                          ****
!****      To generate momentum-space partial-wave matrix elements use the routine:            ****
!****                                                                                          ****
!****      - CHIRALMOMPWD(OSTAT,FORCE,PPUN1,PPUN2,JMOM,CUTNUMR,POTEN)                          ****
!****        It generates < p',l',s,j | V | p,l,s,j > for given values of the magnitude of the ****
!****        incomung and outgoing momenta p=PPUN2 and p'=PPUN1, [real double precision],      ****
!****        which should be given in GeV, and a fixed values of j=JMOM [integer]. These       ****
!****        parameters should be provided as input. The output vector POTEN(6) [real double   ****
!****        precision] contains MEs for all possible combinations of l, l' and s using the    ****
!****        following notation:                                                               ****
!****          POTEN(1):       s=0, l'=l=j                                                     ****
!****          POTEN(2):       s=1, l'=l=j                                                     ****
!****          POTEN(3):       s=1, l'=l=j-1                                                   ****
!****          POTEN(4):       s=1, l'=j-1, l=j+1                                              ****
!****          POTEN(5):       s=1, l'=j+1, l=j-1                                              ****
!****          POTEN(6):       s=1, l'=l=j+1                                                   ****
!****        Matrix elements POTEN(i) are generated in units of GeV^(-2). Partial-wave MEs     ****
!****        have the standard normalization (CHECK YOUR CONVENTION FOR THE SIGN OF THE        ****
!****        OFF-DIAGONAL MEs) and are to be substituted into the Lippmann-Schwinger equation  ****
!****        without any prefactors, i.e. T = V + integral[k^2 dk V G_0 T].                    ****  
!****        NOTICE: this is a DIFFERENT convention compared to the one adopted in the         ****
!****        nonlocal n3lo chiral subroutine "chiral_n3lo.f90" of 2004, where all momenta and  ****
!****        potential MEs were given in units MeV and MeV**(-2) and a different normalization ****
!****        of the LS equation was assumed. In order to bring the PWD MEs of this routine     ****
!****        into the convention of "chiral_n3lo.f90", multiply POTEN(i) by the factor of      ****
!****        PI/2D0/1000000D0.                                                                 ****
!****                                                                                          ****
!****        The remaining input parameters are:                                               ****
!****          OSTAT [integer]:   0, 1, 2, 3, 4 stays for LO, NLO, N2LO, N3LO and N4LO         ****
!****          FORCE [character,len=2]: type of the interaction ('nn', 'pp' or 'np')           ****
!****          CUTNUMR [integer]: 1, 2, 3, 4, 5 stays for the r-space cutoff R = 0.8, 0.9,     ****
!****                             1.0, 1.1 and 1.2 fm. (Notice: only DR, SFR is not employed.) ****
!****                                                                                          ****
!****      Notice:                                                                             ****
!****                                                                                          ****
!****      1. Due to a local regularization of long-range interactions, the potential          ****
!****         decreases with momenta much slower than the one generated by "chiral_n3lo.f90".  ****
!****         Therefore, integrations over momenta when solving the Lippmann-Schwinger         ****
!****         equation should go up to about 6...7 GeV.                                        ****
!****                                                                                          ****
!****      2. The potentials at all chiral orders are designed for the  standard               ****
!****         non-relativistic-like Lippmann-Schwinger equation with the relativistic          ****
!****         relation between the cms energy and momentum, see the first paper listed above   ****
!****         for details. Also for the deuteron BE one should use relativistic kinematics.    ****
!****                                                                                          ****
!****      3. Always do first initialize the potential for all required momenta and partial    ****
!****         for fixed values of OSTAT and CUTNUMR. Doing this in a different way will result ****
!****         in a very bad performance of the subroutine.                                     ****
!****                                                                                          ****
!****      E.Epelbaum, 16.12.2014                                                              ****
!**************************************************************************************************
!**************************************************************************************************
!**************************************************************************************************
MODULE ICHIRAL
IMPLICIT NONE
SAVE
PRIVATE
PUBLIC CHIRALMOMPWD
INTEGER                    ::NISO,NSPIN
REAL(KIND(0.0D0))          ::PI,FAK
PARAMETER                   (PI=3.1415926535897932385D0,FAK=0.197327D0,&
                             NISO=4,&
                             NSPIN=4)
INTEGER                    ::NGRID
REAL(KIND(0.0D0))          ::TYPMOMSCALE,POWER
PARAMETER                   (NGRID=200,&
                             TYPMOMSCALE=0.5D0,POWER=1D0)
REAL(KIND(0.0D0))          ::QGRID(NGRID),LAMGRID,&
                             FAK1(NGRID,NGRID),FAK2(NGRID,NGRID),FAK3(NGRID,NGRID),SPL(1,NGRID),&
                             POTMOMGRID(NGRID,NSPIN,NISO)
PARAMETER                   (LAMGRID=15D0)
INTEGER                    ::NR,NR1,NR2
REAL(KIND(0.0D0))          ::LAMR1,LAMR2,LAMR3
PARAMETER                   (NR=1024,NR1=(NR/6)*2,NR2=NR-NR1,LAMR1=0.5D0,LAMR2=2.0D0,LAMR3=32D0)
REAL(KIND(0.0D0))          ::RP(NR),RW(NR)
INTEGER                    ::NXP
REAL(KIND(0.0D0))          ::LAMXP1,LAMXP2,LAMXP3
PARAMETER                   (NXP=64,LAMXP1=0.01D0,LAMXP2=0.1D0,LAMXP3=1D0)
REAL(KIND(0.0D0))          ::XP(NXP),XW(NXP)
INTEGER                    ::NCUTR
REAL(KIND(0.0D0))          ::GA,GAD18,C1N2LO,C3N2LO,C4N2LO,C1N3LO,C2N3LO,C3N3LO,C4N3LO,&
                             D1PD2N3LO,D3N3LO,D5N3LO,D14MD15N3LO,MPI,MPIN,MPIC,FPI,M,&
                             C1N4LO,C2N4LO,C3N4LO,C4N4LO,D1PD2N4LO,D3N4LO,D5N4LO,D14MD15N4LO,&
                             E14N4LO,E17N4LO,E19N4LO,E21N4LO,E22N4LO,MPROT,MNEUT
PARAMETER                   (NCUTR=5)
REAL(KIND(0.0D0))          ::CUTR(NCUTR),CLO(4,NCUTR),CNLODR(11,NCUTR),&
                             CN2LODR(11,NCUTR),CN3LODR(26,NCUTR),CN4LODR(27,NCUTR)
PARAMETER                   (GA=1.267D0,GAD18=1.29D0,&
                             MPI=0.13803D0,MPIN=0.13498D0,MPIC=0.139570D0,FPI=0.0924D0,&
                             MPROT=0.9382720D0,MNEUT=0.9395653D0,&
                             M=2.0D0*MPROT*MNEUT/(MPROT+MNEUT),&
                             C1N2LO=-0.81D0,C3N2LO=-4.69D0,C4N2LO=3.40D0,&
                             C1N3LO=-0.81D0,C2N3LO=3.28D0,C3N3LO=-4.69D0,C4N3LO=3.40D0,&
                             D1PD2N3LO=3.06D0,D3N3LO=-3.27D0,D5N3LO=0.45D0,D14MD15N3LO=-5.65D0,&
                             C1N4LO=-0.75D0,C2N4LO=3.49D0,C3N4LO=-4.77D0,C4N4LO=3.34D0,&
                             D1PD2N4LO=6.21D0,D3N4LO=-6.83D0,D5N4LO=0.78D0,D14MD15N4LO=-12.02D0,&
                             E14N4LO=1.52D0,E17N4LO=-0.37D0,E19N4LO=0D0,E21N4LO=0D0,E22N4LO=0D0,&
                             CUTR=  (/ 0.8D0, 0.9D0, 1.0D0, 1.1D0, 1.2D0 /)) 
!==================================================================================================
!==================================================================================================
!==================================================================================================
!==================================================================================================
 DATA            CLO    /&                                                                       !=
-0.70783251D-01,-0.70966204D-01,-0.70504891D-01,-0.71242851D-01,&                                !=
-0.80050154D-01,-0.93993012D-01,-0.79471700D-01,-0.80130908D-01,&                                !=
-0.89419368D-01,-0.11634195D+00,-0.88481716D-01,-0.89018739D-01,&                                !=
-0.98880017D-01,-0.13883176D+00,-0.97517141D-01,-0.97889682D-01,&                                !=
-0.10841682D+00,-0.16201308D+00,-0.10656125D+00,-0.10672760D+00/                                 !=
!==================================================================================================
 DATA           CNLODR  /&                                                                       !=
-0.66689541D-01, 0.56010410D+00, 0.21478830D+00,-0.89078169D-01, 0.41726899D+00, 0.26367233D+00,&!=
 0.30580012D+00, 0.20989021D+00,-0.35466944D+00,-0.64761561D-01,-0.63985572D-01,&                !=
-0.87570306D-01, 0.48852150D+00, 0.26536435D+00,-0.10383369D+00, 0.33658763D+00, 0.36521274D+00,&!=
 0.21328661D+00, 0.25787718D+00,-0.40701649D+00,-0.85648009D-01,-0.85099288D-01,&                !=
-0.98661440D-01, 0.42696439D+00, 0.32839904D+00,-0.11544373D+00, 0.23903431D+00, 0.48135797D+00,&!=
 0.11518702D+00, 0.31889968D+00,-0.45660902D+00,-0.96612565D-01,-0.96184407D-01,&                !=
-0.10620443D+00, 0.35131152D+00, 0.40496938D+00,-0.12536297D+00, 0.10062076D+00, 0.61259933D+00,&!=
 0.42275259D-02, 0.39325901D+00,-0.50411282D+00,-0.10397457D+00,-0.10361459D+00,&                !=
-0.11195427D+00, 0.24843578D+00, 0.49618869D+00,-0.13372805D+00,-0.98197537D-01, 0.75867859D+00,&!=
-0.12243468D+00, 0.48126455D+00,-0.55013336D+00,-0.10951649D+00,-0.10919285D+00/                 !=
!==================================================================================================
 DATA           CN2LODR  /&                                                                      !=
 0.11350755D+00, 0.48951870D-01, 0.54018033D+00, 0.58706514D-01, 0.92535039D-01, 0.26610294D+00,&!=
 0.87748344D+00, 0.11301122D+01, 0.22625097D+00, 0.11559681D+00, 0.11656916D+00,&                !=
 0.30169662D-01, 0.16450932D+00, 0.54389982D+00,-0.84577172D-02, 0.13158024D+00, 0.37608824D+00,&!=
 0.65385816D+00, 0.92787086D+00, 0.68656798D-01, 0.32241953D-01, 0.32995526D-01,&                !=
-0.20442498D-01, 0.21183815D+00, 0.58655668D+00,-0.51744071D-01, 0.10547917D+00, 0.50255787D+00,&!=
 0.49015102D+00, 0.85060265D+00,-0.63264608D-01,-0.18267870D-01,-0.17648239D-01,&                !=
-0.52935931D-01, 0.20702838D+00, 0.66106048D+00,-0.81310674D-01, 0.13345630D-01, 0.64699272D+00,&!=
 0.33644545D+00, 0.83653021D+00,-0.17869913D+00,-0.50601357D-01,-0.50068025D-01,&                !=
-0.74818543D-01, 0.15226827D+00, 0.76482587D+00,-0.10224971D+00,-0.15483367D+00, 0.80878376D+00,&!=
 0.17384046D+00, 0.86421336D+00,-0.28243735D+00,-0.72294060D-01,-0.71817343D-01/                 !=
!==================================================================================================
 DATA           CN3LODR  /&                                                                      !=
 0.23279298D+00,-0.43332483D-01, 0.30691437D+01, 0.61346471D+00, 0.10068417D+01, 0.94800086D+00,&!=
 0.13769664D+01, 0.24406523D+00,-0.32915362D+00,-0.45205438D+01, 0.38437955D+01, 0.34238372D+00,&!=
 0.86405818D+00,-0.15053730D+01, 0.14422300D+01, 0.10678445D+01,-0.40295103D+00, 0.13413041D+01,&!=
-0.70695747D+00, 0.56368265D+00,-0.50078032D+00,-0.13550510D+00, 0.65399601D+00,-0.16545663D+00,&!=
 0.23516052D+00, 0.23630919D+00,&                                                                !=
 0.16000516D+00,-0.40033560D-01,-0.18080408D+01, 0.30136136D+01, 0.80951879D+00, 0.16652337D+01,&!=
 0.96170774D+00, 0.16875675D+00,-0.38438362D+00,-0.80894391D+01, 0.64033602D+01, 0.40924580D+00,&!=
-0.31809379D+00,-0.31565425D+00, 0.12225167D+01, 0.78122222D+00, 0.63111114D+00, 0.11252861D+01,&!=
 0.36557762D+00, 0.31886008D+00,-0.43980527D+00,-0.23432567D+00, 0.25928271D-01,-0.41027011D+00,&!=
 0.16310841D+00, 0.16478429D+00,&                                                                !=
 0.10346774D+00,-0.11548547D+00,-0.69811799D+01, 0.64536934D+01, 0.69256852D+00, 0.24623307D+01,&!=
 0.47819828D+00, 0.10428757D+00,-0.42555460D+00,-0.12351397D+02, 0.92049845D+01, 0.53875888D+00,&!=
-0.20897659D+01, 0.16466383D+01, 0.11239846D+01, 0.51202747D+00, 0.15809455D+01, 0.96668809D+00,&!=
 0.14145098D+01, 0.14177184D+00,-0.60946353D+00,-0.41076570D+00,-0.88052606D+00,-0.72894117D+00,&!=
 0.10697950D+00, 0.10902314D+00,&                                                                !=
 0.51340611D-01,-0.20782833D+00,-0.13365890D+02, 0.10806036D+02, 0.62667616D+00, 0.34612604D+01,&!=
-0.11441266D+00, 0.51258449D-01,-0.48683189D+00,-0.17585922D+02, 0.12397686D+02, 0.72975227D+00,&!=
-0.43925368D+01, 0.42797791D+01, 0.11446110D+01, 0.26447209D+00, 0.25083716D+01, 0.85916154D+00,&!=
 0.26058360D+01, 0.13370065D-01,-0.10773454D+01,-0.69458792D+00,-0.21386144D+01,-0.11377128D+01,&!=
 0.55065475D-01, 0.57385919D-01,&                                                                !=
 0.10036341D-01,-0.33437723D+00,-0.21993406D+02, 0.16511078D+02, 0.59301994D+00, 0.47818721D+01,&!=
-0.85692590D+00, 0.97160421D-02,-0.57898624D+00,-0.23692109D+02, 0.15763552D+02, 0.96240613D+00,&!=
-0.73943110D+01, 0.80088964D+01, 0.11740406D+01, 0.31269222D-01, 0.34431844D+01, 0.78649585D+00,&!=
 0.41339515D+01,-0.76783138D-01,-0.19420558D+01,-0.11274550D+01,-0.38115628D+01,-0.16563854D+01,&!=
 0.13958984D-01, 0.16560728D-01/                                                                 !=
!==================================================================================================
 DATA           CN4LODR  /&                                                                      !=
 0.16094633D-01,-0.26822900D+00,-0.42099462D+01, 0.33349458D+01, 0.55569068D+00, 0.78818440D+00,&!=
-0.23518839D+00, 0.15919891D-01,-0.23078327D+00,-0.51053680D+01, 0.35068115D+01, 0.27610860D+00,&!=
 0.34069993D+00,-0.54374125D+00, 0.41222939D+00, 0.45442602D+00,-0.46930910D+00, 0.46939541D+00,&!=
-0.45016743D+00,-0.18115584D+00,-0.87272144D+00,-0.36756438D-01, 0.35160384D-01,-0.80074913D+00,&!=
 0.31579897D-01, 0.33791976D-01,-0.22145602D+00,&                                                !=
 0.18964047D-01,-0.18119119D+00,-0.62483584D+01, 0.47449776D+01, 0.55426213D+00, 0.13945903D+01,&!=
-0.36021930D+00, 0.19599934D-01,-0.21913632D+00,-0.77292869D+01, 0.53294518D+01, 0.39348723D+00,&!=
-0.24281374D+00,-0.54072875D-01, 0.70463018D+00, 0.40923318D+00, 0.40833366D+00, 0.57166134D+00,&!=
 0.32959097D+00,-0.13606035D+00,-0.88419670D+00,-0.15128999D+00,-0.44427792D+00,-0.89383551D+00,&!=
 0.27978642D-01, 0.30034988D-01,-0.13733522D+00,&                                                !=
 0.71428681D-02,-0.17809839D+00,-0.96883155D+01, 0.72603695D+01, 0.54549579D+00, 0.21581312D+01,&!=
-0.63083753D+00, 0.74586873D-02,-0.27853630D+00,-0.11741492D+02, 0.80658260D+01, 0.54557983D+00,&!=
-0.13409599D+01, 0.10079940D+01, 0.10395611D+01, 0.28145924D+00, 0.12814795D+01, 0.60650386D+00,&!=
 0.12136229D+01,-0.14633608D+00,-0.10822482D+01,-0.33821494D+00,-0.12351531D+01,-0.11057812D+01,&!=
 0.13640070D-01, 0.15762445D-01,-0.13512291D+00,&                                                !=
-0.98366454D-02,-0.24516175D+00,-0.15133985D+02, 0.11128524D+02, 0.54106613D+00, 0.31575496D+01,&!=
-0.10624998D+01,-0.95950363D-02,-0.37703506D+00,-0.16915591D+02, 0.11373204D+02, 0.73163495D+00,&!=
-0.33131603D+01, 0.32361221D+01, 0.12957836D+01, 0.11822682D+00, 0.21785261D+01, 0.61937066D+00,&!=
 0.23153478D+01,-0.17441468D+00,-0.15545352D+01,-0.62929897D+00,-0.24028827D+01,-0.14373767D+01,&!=
-0.44603112D-02,-0.21518108D-02,-0.20204512D+00,&                                                !=
-0.28904584D-01,-0.36363071D+00,-0.23115656D+02, 0.16514291D+02, 0.54360999D+00, 0.44901341D+01,&!=
-0.16799764D+01,-0.27265482D-01,-0.51235049D+00,-0.23426941D+02, 0.15139002D+02, 0.95592690D+00,&!=
-0.61724474D+01, 0.67679897D+01, 0.15202229D+01,-0.63129002D-01, 0.31039861D+01, 0.62358062D+00,&!=
 0.37930404D+01,-0.20191945D+00,-0.24113325D+01,-0.10673057D+01,-0.40057121D+01,-0.18986774D+01,&!=
-0.24077807D-01,-0.21520700D-01,-0.31982164D+00/                                                 !=
!==================================================================================================
!==================================================================================================
!==================================================================================================
!==================================================================================================
INTEGER                    ::CUTNUMRFIR,OSTATFIR
LOGICAL                    ::FIRST1
DATA                       FIRST1/.FALSE./
INTEGER                    ::NZPUN
PARAMETER                   (NZPUN=64)
REAL(KIND(0.0D0))          ::ZPUN(NZPUN),ZWEI(NZPUN),PL(NZPUN),PLP(NZPUN),PLM(NZPUN)
!***************************************************************************************************
CONTAINS





!***************************************************************************************************
SUBROUTINE CHIRALCOORDLR(OSTAT,RPUN,CUTNUMR,POTEN,OPEP)
IMPLICIT NONE
INTEGER                    ::OSTAT,CUTNUMR
REAL(KIND(0.0D0))          ::POTLONGCOORD(12),&
                             POTLONGQ4COORD(6),&
                             POTLONGQ4RELCOORD(8),&
                             POTENLONG(NSPIN,NISO),&
                             POTEN(NSPIN,NISO),&
                             OPEP(NSPIN,NISO),&
                             RPUN

IF (RPUN .LE. 0.0005D0) THEN 
  RPUN=0.0005D0
END IF
IF (RPUN .GE. 50D0) THEN 
  POTEN=0D0
  RETURN
END IF

CALL INITLONGRANGE(OSTAT,POTLONGCOORD,POTLONGQ4COORD,POTLONGQ4RELCOORD,RPUN)
POTENLONG=0D0
POTENLONG(2,2)=POTLONGCOORD(4)*REGLONGRANGE(RPUN,CUTNUMR)
POTENLONG(3,2)=POTLONGCOORD(3)*REGLONGRANGE(RPUN,CUTNUMR)
POTENLONG(2,3)=4D0*(POTLONGCOORD(6)-POTLONGCOORD(4))*REGLONGRANGE(RPUN,CUTNUMR)
POTENLONG(3,3)=4D0*(POTLONGCOORD(5)-POTLONGCOORD(3))*REGLONGRANGE(RPUN,CUTNUMR)
OPEP=POTENLONG
IF (OSTAT .GE. 1) THEN
  POTENLONG(1,2)=POTLONGCOORD(7)*REGLONGRANGE(RPUN,CUTNUMR)
  POTENLONG(2,1)=POTENLONG(2,1)+POTLONGCOORD(8)*REGLONGRANGE(RPUN,CUTNUMR)
  POTENLONG(3,1)=POTENLONG(3,1)+POTLONGCOORD(9)*REGLONGRANGE(RPUN,CUTNUMR)
  IF (OSTAT .GE. 2) THEN
    POTENLONG(1,1)=POTLONGCOORD(10)*REGLONGRANGE(RPUN,CUTNUMR)
    POTENLONG(2,2)=POTENLONG(2,2)+POTLONGCOORD(11)*REGLONGRANGE(RPUN,CUTNUMR)
    POTENLONG(3,2)=POTENLONG(3,2)+POTLONGCOORD(12)*REGLONGRANGE(RPUN,CUTNUMR)
    IF (OSTAT .GE. 3) THEN
      POTENLONG(1,1)=POTENLONG(1,1)+POTLONGQ4COORD(1)*REGLONGRANGE(RPUN,CUTNUMR)&
                                   +POTLONGQ4RELCOORD(1)*REGLONGRANGE(RPUN,CUTNUMR)
      POTENLONG(1,2)=POTENLONG(1,2)+POTLONGQ4COORD(2)*REGLONGRANGE(RPUN,CUTNUMR)&
                                   +POTLONGQ4RELCOORD(2)*REGLONGRANGE(RPUN,CUTNUMR)
      POTENLONG(2,1)=POTENLONG(2,1)+POTLONGQ4COORD(3)*REGLONGRANGE(RPUN,CUTNUMR)&
                                   +POTLONGQ4RELCOORD(3)*REGLONGRANGE(RPUN,CUTNUMR)
      POTENLONG(3,1)=POTENLONG(3,1)+POTLONGQ4COORD(4)*REGLONGRANGE(RPUN,CUTNUMR)&
                                   +POTLONGQ4RELCOORD(4)*REGLONGRANGE(RPUN,CUTNUMR)
      POTENLONG(2,2)=POTENLONG(2,2)+POTLONGQ4COORD(5)*REGLONGRANGE(RPUN,CUTNUMR)&
                                   +POTLONGQ4RELCOORD(5)*REGLONGRANGE(RPUN,CUTNUMR)
      POTENLONG(3,2)=POTENLONG(3,2)+POTLONGQ4COORD(6)*REGLONGRANGE(RPUN,CUTNUMR)&
                                   +POTLONGQ4RELCOORD(6)*REGLONGRANGE(RPUN,CUTNUMR)
      POTENLONG(4,1)=POTLONGQ4RELCOORD(7)*REGLONGRANGE(RPUN,CUTNUMR)
      POTENLONG(4,2)=POTLONGQ4RELCOORD(8)*REGLONGRANGE(RPUN,CUTNUMR)
    END IF
  END IF
END IF

POTEN=POTENLONG
END SUBROUTINE CHIRALCOORDLR
!***************************************************************************************************




!***************************************************************************************************
SUBROUTINE CHIRALMOMLR(OSTAT,QPUN,CUTNUMR,POTMOM)
IMPLICIT NONE
INTEGER                    ::I,J,K,OSTAT,CUTNUMR
REAL(KIND(0.0D0))          ::QPUN,&
                             POTMOM(NSPIN,NISO),QPUNTEMP(1)

IF (FIRST1) THEN 
  IF (OSTAT .NE. OSTATFIR) THEN
    FIRST1=.FALSE.
  END IF
  IF (CUTNUMR .NE. CUTNUMRFIR) THEN
    FIRST1=.FALSE.
  END IF
END IF

!######################################################################################
!######################################################################################
IF (.NOT. FIRST1) THEN 
  CALL INFO(OSTAT,CUTNUMR)
  OSTATFIR=OSTAT
  CUTNUMRFIR=CUTNUMR
  CALL INITMOMGRID()
  CALL SPLFAKCH(QGRID,NGRID,FAK1,FAK2,FAK3)
  CALL TRNSCH(NXP/2,NXP/2,NXP,LAMXP1,LAMXP2,LAMXP3,XP,XW)
  CALL INITPOTMOMGRID(OSTAT,CUTNUMR)
  FIRST1=.TRUE.
END IF
!######################################################################################
!######################################################################################

IF (QPUN .LE. QGRID(1)) THEN
  QPUN=QGRID(1)
END IF
IF (QPUN .GE. LAMGRID) THEN
  POTMOM=0D0
  RETURN
END IF

QPUNTEMP(1)=QPUN
CALL CUBBASISCH(QGRID,NGRID,QPUNTEMP,1,SPL)
POTMOM=0D0
DO I=1,NISO
  DO J=1,NSPIN
    DO K=1,NGRID
      POTMOM(J,I)=POTMOM(J,I)+SPL(1,K)*POTMOMGRID(K,J,I)
    END DO
  END DO
END DO
END SUBROUTINE CHIRALMOMLR
!***************************************************************************************************





!***************************************************************************************************
SUBROUTINE CHIRALMOMPWD(OSTAT,FORCE,PPUN1,PPUN2,JMOM,CUTNUMR,POTEN)
IMPLICIT NONE
INTEGER                    ::I,J,OSTAT,CUTNUMR,JMOM
REAL(KIND(0.0D0))          ::PPUN1,PPUN2,POTEN(6),POTENOPERATOR(NSPIN,NISO),Q,&
                             V1T(NZPUN),V2T(NZPUN),V3T(NZPUN),V4T(NZPUN),&
                             W1T(NZPUN),W2T(NZPUN),W3T(NZPUN),W4T(NZPUN),&
                             VR1T(6),VR2T(6),VR3T(6),VR4T(6),&
                             WR1T(6),WR2T(6),WR3T(6),WR4T(6),&
                             POTISOT(6),POTISOS(6),POTENCONT(6)
CHARACTER(len=2)           ::FORCE

IF (JMOM .GE. NZPUN/2-5) THEN
  WRITE(*,*)'Increase the number of angular integration points NZPUN'
  STOP
ELSE
  IF (JMOM .LT. 0) THEN
    WRITE(*,*)'Wrong value of JMOM'
    STOP
  END IF
END IF

CALL GAULEGCH(-1D0,1D0,ZPUN,ZWEI,NZPUN)
DO I=1,NZPUN
  PL(I)=PLFF(ZPUN(I),JMOM)
  PLP(I)=PLFF(ZPUN(I),JMOM+1)
  IF (JMOM .GE. 1) THEN
    PLM(I)=PLFF(ZPUN(I),JMOM-1)
  END IF
END DO

SELECT CASE (FORCE)
CASE ('nn')
  DO I=1,NZPUN
    Q=SQRT(PPUN1**2+PPUN2**2-2D0*PPUN1*PPUN2*ZPUN(I))
    CALL CHIRALMOMLR(OSTAT,Q,CUTNUMR,POTENOPERATOR)
    IF (OSTAT .GE. 3) THEN 
      POTENOPERATOR=POTENOPERATOR*(MNEUT/SQRT(MNEUT**2+PPUN1**2)/2D0+MNEUT/SQRT(MNEUT**2+PPUN2**2)/2D0)
    END IF
    V1T(I)=POTENOPERATOR(1,1)+POTENOPERATOR(1,2)+1D0/4D0*POTENOPERATOR(1,3)-POTENOPERATOR(1,4)
    V2T(I)=POTENOPERATOR(2,1)+POTENOPERATOR(2,2)+1D0/4D0*POTENOPERATOR(2,3)-POTENOPERATOR(2,4)
    V3T(I)=POTENOPERATOR(3,1)+POTENOPERATOR(3,2)+1D0/4D0*POTENOPERATOR(3,3)-POTENOPERATOR(3,4)
    V4T(I)=POTENOPERATOR(4,1)+POTENOPERATOR(4,2)+1D0/4D0*POTENOPERATOR(4,3)-POTENOPERATOR(4,4)
  END DO
  CALL PARCCH(VR1T,V1T,JMOM)
  CALL PARSIGCH(VR2T,V2T,JMOM)
  CALL PARSIGDCH(VR3T,V3T,JMOM,PPUN1,PPUN2)
  CALL PARSLCH(VR4T,V4T,JMOM,PPUN1,PPUN2)
  DO J=1,6
    POTISOT(J)=VR1T(J)+VR2T(J)+VR3T(J)+VR4T(J)
    POTISOS(J)=0D0
  END DO
CASE ('pp')
  DO I=1,NZPUN
    Q=SQRT(PPUN1**2+PPUN2**2-2D0*PPUN1*PPUN2*ZPUN(I))
    CALL CHIRALMOMLR(OSTAT,Q,CUTNUMR,POTENOPERATOR)
    IF (OSTAT .GE. 3) THEN 
      POTENOPERATOR=POTENOPERATOR*(MPROT/SQRT(MPROT**2+PPUN1**2)/2D0+MPROT/SQRT(MPROT**2+PPUN2**2)/2D0)
    END IF
    V1T(I)=POTENOPERATOR(1,1)+POTENOPERATOR(1,2)+1D0/4D0*POTENOPERATOR(1,3)+POTENOPERATOR(1,4)
    V2T(I)=POTENOPERATOR(2,1)+POTENOPERATOR(2,2)+1D0/4D0*POTENOPERATOR(2,3)+POTENOPERATOR(2,4)
    V3T(I)=POTENOPERATOR(3,1)+POTENOPERATOR(3,2)+1D0/4D0*POTENOPERATOR(3,3)+POTENOPERATOR(3,4)
    V4T(I)=POTENOPERATOR(4,1)+POTENOPERATOR(4,2)+1D0/4D0*POTENOPERATOR(4,3)+POTENOPERATOR(4,4)
  END DO
  CALL PARCCH(VR1T,V1T,JMOM)
  CALL PARSIGCH(VR2T,V2T,JMOM)
  CALL PARSIGDCH(VR3T,V3T,JMOM,PPUN1,PPUN2)
  CALL PARSLCH(VR4T,V4T,JMOM,PPUN1,PPUN2)
  DO J=1,6
    POTISOT(J)=VR1T(J)+VR2T(J)+VR3T(J)+VR4T(J)
    POTISOS(J)=0D0
  END DO
CASE ('np')
  DO I=1,NZPUN
    Q=SQRT(PPUN1**2+PPUN2**2-2D0*PPUN1*PPUN2*ZPUN(I))
    CALL CHIRALMOMLR(OSTAT,Q,CUTNUMR,POTENOPERATOR)
    IF (OSTAT .GE. 3) THEN 
      POTENOPERATOR=POTENOPERATOR*(M/SQRT(M**2+PPUN1**2)/2D0+M/SQRT(M**2+PPUN2**2)/2D0)
    END IF
    V1T(I)=POTENOPERATOR(1,1)+POTENOPERATOR(1,2)-1D0/4D0*POTENOPERATOR(1,3)
    V2T(I)=POTENOPERATOR(2,1)+POTENOPERATOR(2,2)-1D0/4D0*POTENOPERATOR(2,3)
    V3T(I)=POTENOPERATOR(3,1)+POTENOPERATOR(3,2)-1D0/4D0*POTENOPERATOR(3,3)
    V4T(I)=POTENOPERATOR(4,1)+POTENOPERATOR(4,2)-1D0/4D0*POTENOPERATOR(4,3)
    W1T(I)=POTENOPERATOR(1,1)-3D0*POTENOPERATOR(1,2)-1D0/4D0*POTENOPERATOR(1,3)
    W2T(I)=POTENOPERATOR(2,1)-3D0*POTENOPERATOR(2,2)-1D0/4D0*POTENOPERATOR(2,3)
    W3T(I)=POTENOPERATOR(3,1)-3D0*POTENOPERATOR(3,2)-1D0/4D0*POTENOPERATOR(3,3)
    W4T(I)=POTENOPERATOR(4,1)-3D0*POTENOPERATOR(4,2)-1D0/4D0*POTENOPERATOR(4,3)
  END DO
  CALL PARCCH(VR1T,V1T,JMOM)
  CALL PARCCH(WR1T,W1T,JMOM)
  CALL PARSIGCH(VR2T,V2T,JMOM)
  CALL PARSIGCH(WR2T,W2T,JMOM)
  CALL PARSIGDCH(VR3T,V3T,JMOM,PPUN1,PPUN2)
  CALL PARSIGDCH(WR3T,W3T,JMOM,PPUN1,PPUN2)
  CALL PARSLCH(VR4T,V4T,JMOM,PPUN1,PPUN2)
  CALL PARSLCH(WR4T,W4T,JMOM,PPUN1,PPUN2)
  DO J=1,6
    POTISOT(J)=VR1T(J)+VR2T(J)+VR3T(J)+VR4T(J)
    POTISOS(J)=WR1T(J)+WR2T(J)+WR3T(J)+WR4T(J)
  END DO
CASE DEFAULT
   WRITE(*,*)'wrong value of FORCE'
   STOP
END SELECT

IF ((JMOM/2)*2 .NE. JMOM) THEN
  POTEN(1)=POTISOS(1)
  POTEN(2)=POTISOT(2)
  POTEN(3)=POTISOS(4)
  POTEN(4)=POTISOS(6)
  POTEN(5)=POTISOS(5)
  POTEN(6)=POTISOS(3)
ELSE
  POTEN(1)=POTISOT(1)
  POTEN(2)=POTISOS(2)
  POTEN(3)=POTISOT(4)
  POTEN(4)=POTISOT(6)
  POTEN(5)=POTISOT(5)
  POTEN(6)=POTISOT(3)
END IF

CALL INITCONTACTS(OSTAT,FORCE,PPUN1,PPUN2,JMOM,CUTNUMR,POTENCONT)
DO I=1,6
  POTEN(I)=POTEN(I)+POTENCONT(I)
  IF (ABS(POTEN(I)) .LE. 1D-7) THEN
    POTEN(I)=1D-20
  END IF
END DO

END SUBROUTINE CHIRALMOMPWD
!***************************************************************************************************





!***************************************************************************************************
SUBROUTINE INFO(OSTAT,CUTNUMR)
IMPLICIT NONE
INTEGER                    ::OSTAT,CUTNUMR

WRITE(*,*)'*************************************************************************'
SELECT CASE (OSTAT)
  CASE (0)
  WRITE(*,*)'   Improved chiral NN potential at LO [Q^0]'
  CASE (1)
  WRITE(*,*)'   Improved chiral NN potential at NLO [Q^2]'
  CASE (2)
  WRITE(*,*)'   Improved chiral NN potential at N2LO [Q^3]'
  CASE (3)
  WRITE(*,*)'   Improved chiral NN potential at N3LO [Q^4]'
  CASE (4)
  WRITE(*,*)'   Improved chiral NN potential at N4LO [Q^5]'
  CASE DEFAULT
  WRITE(*,*)'Wrong value of OSTAT'
  STOP
END SELECT
SELECT CASE (CUTNUMR)
  CASE (1)
  WRITE(*,*)'   Cutoff value: R=0.8fm'
  CASE (2)
  WRITE(*,*)'   Cutoff value: R=0.9fm'
  CASE (3)
  WRITE(*,*)'   Cutoff value: R=1.0fm'
  CASE (4)
  WRITE(*,*)'   Cutoff value: R=1.1fm'
  CASE (5)
  WRITE(*,*)'   Cutoff value: R=1.2fm'
  CASE DEFAULT
  WRITE(*,*)'Wrong value of CUTNUMR'
  STOP
END SELECT
WRITE(*,*)'*************************************************************************'
END SUBROUTINE INFO
!***************************************************************************************************





!***************************************************************************************************
SUBROUTINE INITCONTACTS(OSTAT,FORCE,PPUN1,PPUN2,JMOM,CUTNUMR,POTENCONT)
IMPLICIT NONE
INTEGER                    ::I,OSTAT,CUTNUMR,JMOM
REAL(KIND(0.0D0))          ::PPUN1,PPUN2,POTENCONT(6),LAMBDANL,FAKT,CC(26),C1S0Q2NNPP
CHARACTER(len=2)           ::FORCE

POTENCONT=0D0
LAMBDANL=2D0/CUTR(CUTNUMR)*FAK
FAKT=EXP(-(PPUN1**2+PPUN2**2)/LAMBDANL**2)

SELECT CASE (OSTAT)
CASE (0)
  DO I=1,4
    CC(I)=CLO(I,CUTNUMR)*FAKT
  END DO
  SELECT CASE (JMOM)
  CASE (0)
    SELECT CASE (FORCE)
    CASE ('np')
      POTENCONT(1)=CC(1)
    CASE ('nn')
      POTENCONT(1)=CC(3)
    CASE ('pp')
      POTENCONT(1)=CC(4)
    END SELECT
  CASE (1)
    POTENCONT(3)=CC(2)
  END SELECT
CASE (1, 2)
  IF (OSTAT .EQ. 1) THEN 
    DO I=1,11
      CC(I)=CNLODR(I,CUTNUMR)*FAKT
    END DO
  ELSE
    DO I=1,11
      CC(I)=CN2LODR(I,CUTNUMR)*FAKT
    END DO
  END IF
  SELECT CASE (JMOM)
  CASE (0)
    POTENCONT(6)=CC(7)*PPUN1*PPUN2
    SELECT CASE (FORCE)
    CASE ('np')
      POTENCONT(1)=CC(1)+CC(2)*(PPUN1**2+PPUN2**2)
    CASE ('nn')
      POTENCONT(1)=CC(10)+CC(2)*(PPUN1**2+PPUN2**2)
    CASE ('pp')
      POTENCONT(1)=CC(11)+CC(2)*(PPUN1**2+PPUN2**2)
    END SELECT
  CASE (1)
    SELECT CASE (FORCE)
    CASE  ('np')
      POTENCONT(1)=CC(3)*PPUN1*PPUN2
      POTENCONT(2)=CC(8)*PPUN1*PPUN2
      POTENCONT(3)=CC(4)+CC(5)*(PPUN1**2+PPUN2**2)
      POTENCONT(4)=CC(6)*PPUN2**2
      POTENCONT(5)=CC(6)*PPUN1**2
    CASE ('nn', 'pp')
      POTENCONT(2)=CC(8)*PPUN1*PPUN2
    END SELECT
  CASE (2)
    POTENCONT(3)=CC(9)*PPUN1*PPUN2
  END SELECT
CASE (3, 4)
  DO I=1,26
    IF (OSTAT .EQ. 3) THEN
      CC(I)=CN3LODR(I,CUTNUMR)*FAKT
      C1S0Q2NNPP=CC(2)
    ELSE
      CC(I)=CN4LODR(I,CUTNUMR)*FAKT
      C1S0Q2NNPP=CN4LODR(27,CUTNUMR)*FAKT
    END IF
  END DO
  SELECT CASE (JMOM)
  CASE (0)
    POTENCONT(6)=CC(16)*PPUN1*PPUN2&
                +CC(17)*PPUN1*PPUN2*(PPUN1**2+PPUN2**2)
    SELECT CASE (FORCE)
    CASE ('np')
      POTENCONT(1)=CC(1)+CC(2)*(PPUN1**2+PPUN2**2)&
                  +CC(3)*PPUN1**2*PPUN2**2+CC(4)*(PPUN1**4+PPUN2**4)
    CASE ('nn')
      POTENCONT(1)=CC(25)+C1S0Q2NNPP*(PPUN1**2+PPUN2**2)&
                  +CC(3)*PPUN1**2*PPUN2**2+CC(4)*(PPUN1**4+PPUN2**4)
    CASE ('pp')
      POTENCONT(1)=CC(26)+C1S0Q2NNPP*(PPUN1**2+PPUN2**2)&
                  +CC(3)*PPUN1**2*PPUN2**2+CC(4)*(PPUN1**4+PPUN2**4)
    END SELECT
  CASE (1)
    SELECT CASE (FORCE)
    CASE  ('np')
      POTENCONT(1)=CC(5)*PPUN1*PPUN2&
                  +CC(6)*PPUN1*PPUN2*(PPUN1**2+PPUN2**2)
      POTENCONT(2)=CC(18)*PPUN1*PPUN2&
                  +CC(19)*PPUN1*PPUN2*(PPUN1**2+PPUN2**2)
      POTENCONT(3)=CC(8)+CC(9)*(PPUN1**2+PPUN2**2)&
                  +CC(10)*PPUN1**2*PPUN2**2+CC(11)*(PPUN1**4+PPUN2**4)
      POTENCONT(4)=CC(12)*PPUN2**2&
                  +CC(13)*PPUN1**2*PPUN2**2+CC(14)*PPUN2**4
      POTENCONT(5)=CC(12)*PPUN1**2&
                  +CC(13)*PPUN1**2*PPUN2**2+CC(14)*PPUN1**4
      POTENCONT(6)=CC(15)*PPUN1**2*PPUN2**2
    CASE ('nn', 'pp')
      POTENCONT(2)=CC(18)*PPUN1*PPUN2&
                  +CC(19)*PPUN1*PPUN2*(PPUN1**2+PPUN2**2)
    END SELECT
  CASE (2)
    SELECT CASE (FORCE)
    CASE  ('np')
      POTENCONT(1)=CC(7)*PPUN1**2*PPUN2**2
      POTENCONT(2)=CC(23)*PPUN1**2*PPUN2**2
      POTENCONT(3)=CC(20)*PPUN1*PPUN2&
                  +CC(21)*PPUN1*PPUN2*(PPUN1**2+PPUN2**2)
      POTENCONT(4)=CC(22)*PPUN1*PPUN2**3
      POTENCONT(5)=CC(22)*PPUN1**3*PPUN2
    CASE ('nn', 'pp')
      POTENCONT(1)=CC(7)*PPUN1**2*PPUN2**2
      POTENCONT(3)=CC(20)*PPUN1*PPUN2&
                  +CC(21)*PPUN1*PPUN2*(PPUN1**2+PPUN2**2)
      POTENCONT(4)=CC(22)*PPUN1*PPUN2**3
      POTENCONT(5)=CC(22)*PPUN1**3*PPUN2
    END SELECT
  CASE (3)
    SELECT CASE (FORCE)
    CASE  ('np')
      POTENCONT(3)=CC(24)*PPUN1**2*PPUN2**2
    END SELECT
  END SELECT
END SELECT

POTENCONT=POTENCONT*10000D0/(2D0*PI)**3

END SUBROUTINE INITCONTACTS
!***************************************************************************************************




!***************************************************************************************************
SUBROUTINE INITPOTMOMGRID(OSTAT,CUTNUMR)
IMPLICIT NONE
INTEGER                    ::I,J,K,L,CUTNUMR,OSTAT,IFAIL
REAL(KIND(0.0D0))          ::POTENCOORD(NSPIN,NISO),OPEPCOORD(NSPIN,NISO),POTENCOORDRGRID(NR,NSPIN,NISO),&
                             NORMALIZATION,FACTOR(NR,NGRID,NSPIN),XDUMMY,&
                             JBB(0:1001),YBB(0:1001),JPBB(0:1001),YPBB(0:1001)

CALL TRNSCH(NR1,NR2,NR,LAMR1,LAMR2,LAMR3,RP,RW)

DO I=1,NR
  CALL CHIRALCOORDLR(OSTAT,RP(I),CUTNUMR,POTENCOORD,OPEPCOORD)
  DO J=1,NISO
    DO K=1,NSPIN
      POTENCOORDRGRID(I,K,J)=POTENCOORD(K,J)
    END DO
  END DO
END DO

POTMOMGRID=0D0
NORMALIZATION=1D0/(2D0*PI**2*FAK**3)
DO I=1,NGRID
  DO L=1,NR
    XDUMMY=RP(L)/FAK*QGRID(I)
    CALL SBESJY(XDUMMY,2,JBB,YBB,JPBB,YPBB,IFAIL)
    FACTOR(L,I,1)=RP(L)**2*JBB(0)*RW(L)*NORMALIZATION
    FACTOR(L,I,2)=FACTOR(L,I,1)
    FACTOR(L,I,3)=-3D0/QGRID(I)**2*RP(L)**2*JBB(2)*RW(L)*NORMALIZATION
    FACTOR(L,I,4)=1D0/QGRID(I)*RP(L)**3*JBB(1)*RW(L)*NORMALIZATION/FAK  
  END DO
END DO

DO J=1,NISO
  DO K=1,NSPIN
    DO I=1,NGRID
      DO L=1,NR
        POTMOMGRID(I,K,J)=POTMOMGRID(I,K,J)+POTENCOORDRGRID(L,K,J)*FACTOR(L,I,K)
      END DO
    END DO
  END DO
END DO
DO J=1,NISO
  DO I=1,NGRID
    POTMOMGRID(I,2,J)=POTMOMGRID(I,2,J)+POTMOMGRID(I,3,J)*QGRID(I)**2/(-3D0)
  END DO
END DO

END SUBROUTINE INITPOTMOMGRID
!***************************************************************************************************





!***************************************************************************************************
SUBROUTINE INITLONGRANGE(OSTAT,POTLONGCOORD,POTLONGQ4COORD,POTLONGQ4RELCOORD,RPUN)
IMPLICIT NONE
INTEGER                    ::I,NMU,OSTAT
PARAMETER                   (NMU=64)
REAL(KIND(0.0D0))          ::POTLONGCOORD(12),&
                             POTLONGQ4COORD(6),&
                             POTLONGQ4RELCOORD(8),&
                             X,RPUN,RPUNGEV,&
                             MUP(NMU),MUW(NMU),MU,&
                             MPIQ,MUQ,OMQ,RHOA,RHOL,RR,TQ,&
                             RHOCQ4(NMU),ETACQ4(NMU),RHOSQ4(NMU),ETASQ4(NMU),RHOTQ4(NMU),ETATQ4(NMU),ETASQ5(NMU),RHOSQ5(NMU),&
                             RHOCQ4REL(NMU),ETACQ4REL(NMU),RHOSQ4REL(NMU),ETASQ4REL(NMU),RHOTQ4REL(NMU),ETATQ4REL(NMU),&
                             RHOSLQ4REL(NMU),ETASLQ4REL(NMU),&
                             BI0,DI0,BI1,DI1,BK0,DK0,BK1,DK1,&
                             C1,C2,C3,C4,D1PD2,D3,D5,D14MD15,GATPEQ2,GATPEQ3,E14,E17,E19,E21,E22
RPUNGEV=RPUN/FAK

POTLONGCOORD=0D0
POTLONGQ4COORD=0D0
POTLONGQ4RELCOORD=0D0

X=MPI*RPUNGEV
POTLONGCOORD(2)=MPI**3/(12D0*PI)*(GAD18/(2D0*FPI))**2*EXP(-X)/X
POTLONGCOORD(1)=POTLONGCOORD(2)*(1D0+3D0/X+3D0/X**2)
X=MPIC*RPUNGEV
POTLONGCOORD(4)=MPIC**3/(12D0*PI)*(GAD18/(2D0*FPI))**2*EXP(-X)/X
POTLONGCOORD(3)=POTLONGCOORD(4)*(1D0+3D0/X+3D0/X**2)
X=MPIN*RPUNGEV
POTLONGCOORD(6)=MPIN**3/(12D0*PI)*(GAD18/(2D0*FPI))**2*EXP(-X)/X
POTLONGCOORD(5)=POTLONGCOORD(6)*(1D0+3D0/X+3D0/X**2)

IF (OSTAT .GE. 1) THEN
  GATPEQ2=GA
  GATPEQ3=GA
  IF (OSTAT .EQ. 2) THEN
    C1=C1N2LO
    C3=C3N2LO
    C4=C4N2LO
  ELSE
    IF (OSTAT .EQ. 3) THEN
      GATPEQ2=GAD18
      C1=C1N3LO
      C2=C2N3LO
      C3=C3N3LO
      C4=C4N3LO
      D1PD2=D1PD2N3LO
      D3=D3N3LO
      D5=D5N3LO
      D14MD15=D14MD15N3LO
    ELSE
      IF (OSTAT .EQ. 4) THEN
        GATPEQ2=GAD18
        GATPEQ3=GAD18
        C1=C1N4LO
        C2=C2N4LO
        C3=C3N4LO
        C4=C4N4LO
        D1PD2=D1PD2N4LO
        D3=D3N4LO
        D5=D5N4LO
        D14MD15=D14MD15N4LO
        E14=E14N4LO
        E17=E17N4LO
        E19=E19N4LO
        E21=E21N4LO
        E22=E22N4LO
      END IF 
    END IF 
  END IF
  X=MPI*RPUNGEV
  CALL IK01A(2D0*X,BI0,DI0,BI1,DI1,BK0,DK0,BK1,DK1)
  POTLONGCOORD(7)=MPI/(128D0*PI**3*FPI**4*RPUNGEV**4)*((1D0+2D0*GATPEQ2**2*(5D0+2D0*X**2)-&
                  GATPEQ2**4*(23D0+12D0*X**2))*BK1+&
                  X*(1D0+10D0*GATPEQ2**2-GATPEQ2**4*(23D0+4D0*X**2))*BK0)
  POTLONGCOORD(8)=GATPEQ2**4*MPI/(32D0*PI**3*FPI**4*RPUNGEV**4)*(3D0*X*BK0+&
                  (3D0+2D0*X**2)*BK1)
  POTLONGCOORD(9)=GATPEQ2**4*MPI/(128D0*PI**3*FPI**4*RPUNGEV**4)*(-12D0*X*BK0-&
                  (15D0+4D0*X**2)*BK1)
  POTLONGCOORD(10)=3D0*EXP(-2D0*X)*GATPEQ3**2/(32D0*FPI**4*PI**2*RPUNGEV**6)*&
                  (2D0*C1*X**2*(1D0+X)**2+C3*(6D0+X*(2D0+X)*(6D0+X*(2D0+X))))
  POTLONGCOORD(11)=C4*EXP(-2D0*X)*GATPEQ3**2/(48D0*FPI**4*PI**2*RPUNGEV**6)*&
                  (1D0+X)*(3D0+X*(3D0+2D0*X))
  POTLONGCOORD(12)=-C4*EXP(-2D0*X)*GATPEQ3**2/(48D0*FPI**4*PI**2*RPUNGEV**6)*&
                  (1D0+X)*(3D0+X*(3D0+X))
  IF (OSTAT .GE. 3) THEN
    CALL LAGZO(NMU,MUP,MUW)
    MUP=MUP/RPUNGEV+2D0*MPI
    MUW=MUW/RPUNGEV*EXP(-2D0*MPI*RPUNGEV)
    MPIQ=MPI**2
    DO I=1,NMU
      MU=MUP(I)
      MUQ=MU**2
      OMQ=-MU**2+4D0*MPI**2
      RHOA=PI/(4D0*MU)
      RHOL=-PI/(2D0*MU)*SQRT(MU**2-4D0*MPI**2)
      RR=0.5D0*SQRT(MUQ-4D0*MPIQ)
      TQ=MUQ-2D0*MPIQ
      RHOCQ4(I)=3D0/(16D0*PI**2*FPI**4)*RHOL*((C2/6D0*OMQ+C3*(2*MPIQ-MUQ)-4D0*C1*MPIQ)**2+C2**2/(45D0)*OMQ**2)&
               -3D0*GA**4*(MUQ-2D0*MPIQ)/(PI*MU*(4D0*FPI)**6)*((MPIQ-2D0*MUQ)*(2D0*MPI+(2D0*MPIQ-MUQ)/(2D0*MU)&
                                                               *LOG((MU+2D0*MPI)/(MU-2D0*MPI)))+4D0*GA**2*MPI*(2D0*MPIQ-MUQ))
      ETATQ4(I)=C4**2/(96D0*PI**2*FPI**4)*OMQ*RHOL&
               -GA**4*(MUQ-4D0*MPIQ)/(MUQ*PI*(4D0*FPI)**6)*((MPIQ-MUQ/4)*LOG((MU+2D0*MPI)/(MU-2D0*MPI))+(1D0+2D0*GA**2)*MU*MPI)
      ETASQ4(I)=ETATQ4(I)*MUQ
      RHOTQ4(I)=-1D0/MUQ*(GA**2*RR**3*MU/(8D0*FPI**4*PI)*D14MD15-2D0*GA**6*MU*RR**3/(8D0*PI*FPI**2)**3*(1D0/9D0-J1(MU)+J2(MU)))
      RHOSQ4(I)=RHOTQ4(I)*MUQ
      ETACQ4(I)=RR*TQ/(24D0*FPI**4*MU*PI)*(2D0*(GA**2-1D0)*RR**2-3D0*GA**2*TQ)*D1PD2&
               +RR**3/(60D0*FPI**4*MU*PI)*(6D0*(GA**2-1D0)*RR**2-5D0*GA**2*TQ)*D3&
               -RR*MPIQ/(6D0*FPI**4*MU*PI)*(2D0*(GA**2-1D0)*RR**2-3D0*GA**2*TQ)*D5&
               -1D0/(92160D0*FPI**6*MUQ*PI**3)*(-320D0*(1D0+2D0*GA**2)**2*MPI**6+240D0*(1D0+6D0*GA**2+8D0*GA**4)*MPI**4*MUQ&
                                                -60D0*GA**2*(8D0+15D0*GA**2)*MPIQ*MU**4&
                                                +(-4D0+29D0*GA**2+122D0*GA**4+3D0*GA**6)*MU**6)*LOG((2D0*RR+MU)/(2D0*MPI))&
               -RR/(2700D0*MU*(8D0*PI*FPI**2)**3)*(-16D0*(171D0+2D0*GA**2*(1D0+GA**2)*(327D0+49D0*GA**2))*MPI**4&
                                                   +4D0*(-73D0+1748D0*GA**2+2549D0*GA**4+726D0*GA**6)*MPIQ*MUQ&
                                                   -(-64D0+389D0*GA**2+1782D0*GA**4+1093D0*GA**6)*MU**4)&
               +2D0*RR/(3D0*MU*(8D0*PI*FPI**2)**3)*(GA**6*TQ**2*J1(MU)-2D0*GA**4*(2D0*GA**2-1D0)*RR**2*TQ*J2(MU))
      IF (OSTAT .EQ. 4) THEN
        RHOCQ4(I)=RHOCQ4(I)+2D0*((GA**2*(2D0*MPI**2 - MU**2)*(MU*(72D0*C1*(MPI**4 - 2D0*MPI**2*MU**2) + C2*(-24D0*MPI**4 + &
              53D0*MPI**2*MU**2 - 10D0*MU**4) +& 
              18D0*(C3*(-2D0*MPI**4 + 5D0*MPI**2*MU**2 - 2D0*MU**4) +& 
              128D0*FPI**2*(E14*(-2D0*MPI**2 + MU**2)**2 + MPI**2*(4D0*E19*MPI**2 - 2D0*E19*MU**2 + E22*MU**2))*Pi**2)) -& 
              6D0*(MPI**2 - 2D0*MU**2)*(24D0*C1*MPI**2 + C2*(-4D0*MPI**2 + MU**2) + 6D0*C3*(-2D0*MPI**2 + MU**2))*RR*&
              Log((MU + 2D0*RR)/(MU - 2D0*RR))))/(24576D0*FPI**6*MU**2*Pi**2))
        RHOCQ4(I)=RHOCQ4(I)+2D0*((48D0*GA**2*MPI*(MPI**2 - 2D0*MU**2)*RR**2*(6D0*(2D0*C1 - C3)*MPI**2 + 3D0*C3*MU**2 + &
              2D0*C2*RR**2) + &
              GA**4*(1536D0*(2D0*C1 - C3)*MPI**7 - 16D0*(84D0*C1 + 5D0*C2 - 42D0*C3)*MPI**6*MU - 192D0*(6D0*C1 - &
              7D0*C3)*MPI**5*MU**2 + &
              8D0*(84D0*C1 + 5D0*C2 - 84D0*C3)*MPI**4*MU**3 - 288D0*C3*MPI**3*MU**4 + (-36D0*C1 - 5D0*C2 + &
              186D0*C3)*MPI**2*MU**5 - &
              9D0*C3*MU**7 - 8D0*(64D0*C2*MPI**5 + (-12D0*C1 - 5D0*C2 + 6D0*C3)*MPI**4*MU - 40D0*C2*MPI**3*MU**2 + &
              (4D0*C2 - 3D0*C3)*MPI**2*MU**3 + C2*MU**5)*RR**2) + &
              12D0*MU*RR**2*(3D0*(4D0*C1 - C2 - 2D0*C3)*MPI**4 + 3D0*C3*MPI**2*MU**2 + &
              2D0*((12D0*C1 + C2 - 6D0*C3)*MPI**2 + 3D0*C3*MU**2)*RR**2 + 8D0*C2*RR**4))/(24576D0*FPI**6*MU*Pi**2*RR) + &
              (GA**2*(2D0*MPI**4 - 5D0*MPI**2*MU**2 + 2D0*MU**4)*RR*(6D0*(2D0*C1 - C3)*MPI**2 + 3D0*C3*MU**2 + 2D0*C2*RR**2)*&
              Log(1D0 + (4D0*MPI)/(-2D0*MPI + MU)))/(2048D0*FPI**6*MU**2*Pi**2) + &
              (MPI**2*(3D0*(-4D0*C1 + C2 + 2D0*C3)*MPI**4 - 3D0*C3*MPI**2*MU**2 + &
              2D0*GA**4*((28D0*C1 + 9D0*C2 - 14D0*C3)*MPI**4 - 4D0*C3*MU**4 + 4D0*(-8D0*C1 + C2 + 4D0*C3)*MPI**2*RR**2 - &
              MU**2*((16D0*C1 + 4D0*C2 - 15D0*C3)*MPI**2 + 8D0*C3*RR**2)))*Log((MU/2D0 + RR)/(MU/2D0 - RR)))/&
              (2048D0*FPI**6*MU*Pi**2))
        ETACQ4(I)=ETACQ4(I)+2D0*((-((-3D0*MU*RR**2*(-3D0*(-4D0*C1 + C2 + C3)*MPI**4 + 2D0*(12D0*C1 + C2 + C3)*MPI**2*RR**2 + &
              8D0*(C2 + C3)*RR**4) + &
              (C3 - C4)*GA**4*(12D0*MPI**2*(2D0*MPI - MU)*(-2D0*MPI**2 + MU**2)**2 + &
              (-192D0*MPI**5 + 87D0*MPI**4*MU + 96D0*MPI**3*MU**2 - 54D0*MPI**2*MU**3 + 6D0*MU**5)*RR**2 - &
              2D0*(16D0*MPI**3 - 19D0*MPI**2*MU + 6D0*MU**3)*RR**4 + 8D0*MU*RR**6) + &
              GA**2*RR**2*(48D0*(-C3 + C4)*MPI**3*MU**2 + 32D0*(C3 - C4)*MPI**3*(3D0*MPI**2 + RR**2) -& 
              3D0*MU**3*((24D0*C1 + 3D0*C2 - 2D0*C3 + 5D0*C4)*MPI**2 + 2D0*(3D0*C2 + 2D0*C3 + C4)*RR**2) + &
              MU*(3D0*(60D0*C1 + 3D0*C2 - 8D0*C3 + 11D0*C4)*MPI**4 + 2D0*(36D0*C1 + 21D0*C2 + 8D0*C3 + 13D0*C4)*MPI**2*RR**2 + &
              8D0*(3D0*C2 + 2D0*C3 + C4)*RR**4)))/RR) + &
              3D0*((3D0*(C2 + C3) - 12D0*C1*(1D0 + 3D0*GA**2) + GA**2*(3D0*C2 + C3*(8D0 - 35D0*GA**2) + 5D0*C4*(-1D0 + &
              7D0*GA**2)))*MPI**6 + &
              3D0*GA**2*(8D0*C1 - C2 - 2*C3 + C4 + 10D0*C3*GA**2 - 10D0*C4*GA**2)*MPI**4*MU**2 + &
              6D0*(-C3 + C4)*GA**4*MPI**2*MU**4)*&
              Log(-((MU + 2D0*RR)/(-MU + 2D0*RR))))/(9216D0*FPI**6*MU*Pi**2))
        RHOSQ5(I)=2D0*(((C3 - C4)*GA**4*MU*(-2D0*MPI**2*(-2D0*MPI + MU)**2*(2D0*MPI + MU) + &
              (16D0*MPI**3 - 9D0*MPI**2*MU + MU**3)*RR**2 - &
              2D0*MU*RR**4 + 3D0*MPI**2*(-5D0*MPI**2 + MU**2)*RR*Log(-((MU + 2D0*RR)/(-MU + &
              2D0*RR)))))/(2048D0*FPI**6*Pi**2*RR))
        RHOSQ4(I)=RHOSQ4(I)+RHOSQ5(I)
        RHOTQ4(I)=RHOTQ4(I)+(RHOSQ5(I))/MUQ
        ETASQ5(I)=2D0*((GA**2*(4D0*MPI**2 - MU**2)*(MU*(C4*(12D0*(2D0 + 9D0*GA**2)*MPI**2 - 5D0*MU**2) - &
              1152D0*FPI**2*(2D0*E17*MPI**2 + 2D0*E21*MPI**2 - E17*MU**2)*Pi**2) + 24D0*C4*RR**3*Log((MU + &
              2D0*RR)/(MU - 2D0*RR))))/ &
              (73728D0*FPI**6*Pi**2))
        ETASQ5(I)=ETASQ5(I)+2D0*((C4*GA**2*(MU*(2D0*GA**2*MPI**2*(-2D0*MPI + MU)**2*(2D0*MPI + MU) - &
              (4D0*(-3D0 + 4D0*GA**2)*MPI**3 - 9D0*GA**2*MPI**2*MU + 3D0*MPI*MU**2 + GA**2*MU**3)*RR**2 + &
              2D0*(2D0*MPI + GA**2*MU)*RR**4 &
              ) + RR**4*(3D0*(-4D0*MPI**2 + MU**2) - 4D0*RR**2)*Log(1D0 + (4D0*MPI)/(-2D0*MPI + MU)) + &
              3D0*GA**2*MPI**2*MU*(5D0*MPI**2 - MU**2)*RR*Log(-((MU + 2D0*RR)/(-MU + &
              2D0*RR)))))/(6144D0*FPI**6*Pi**2*RR))
        ETASQ4(I)=ETASQ4(I)+ETASQ5(I)
        ETATQ4(I)=ETATQ4(I)+(ETASQ5(I))/MUQ
      END IF
      RHOCQ4REL(I)=-GA**2*RHOL/(32D0*PI**2*M*FPI**4)*((C2-6D0*C3)*MU**4-4D0*(6D0*C1+C2-3D0*C3)*MPIQ*MUQ&
                                              +6D0*(C2-2D0*C3)*MPI**4+24D0*(2D0*C1+C3)*MPI**6/(4D0*MPI**2-MUQ))
      ETACQ4REL(I)=C4/(192D0*PI**2*M*FPI**4)*MUQ*OMQ*RHOL&
                  +C4*GA**2/(192D0*PI**2*M*FPI**4)*MUQ*(8D0*MPIQ-5D0*MUQ)*RHOL
      RHOTQ4REL(I)=0D0
      RHOSQ4REL(I)=0D0
      ETATQ4REL(I)=C4/(192D0*PI**2*M*FPI**4)*OMQ*RHOL&
                  -C4*GA**2/(192D0*PI**2*M*FPI**4)*(16D0*MPIQ-7D0*MUQ)*RHOL
      ETASQ4REL(I)=ETATQ4REL(I)*MUQ
      RHOSLQ4REL(I)=-C2*GA**2/(16D0*PI**2*M*FPI**4)*OMQ*RHOL
      ETASLQ4REL(I)=C4/(96D0*PI**2*M*FPI**4)*OMQ*RHOL&
                   +C4*GA**2/(96D0*PI**2*M*FPI**4)*(8D0*MPIQ-5D0*MUQ)*RHOL
      RHOCQ4REL(I)=RHOCQ4REL(I)+3D0*GA**4/(512D0*PI*M*FPI**4)*(2D0*MPI**5/OMQ-3D0*(4D0*MPI**4-MU**4)*RHOA)
      ETACQ4REL(I)=ETACQ4REL(I)+GA**2/(128D0*PI*M*FPI**4)*(3D0*GA**2*MPI**5/OMQ&
                   -(4D0*MPIQ-2D0*MUQ-GA**2*(7D0*MPIQ-4.5D0*MUQ))*(2D0*MPIQ-MUQ)*RHOA)
      RHOTQ4REL(I)=RHOTQ4REL(I)+9D0*GA**4/(512D0*PI*M*FPI**4)*(4D0*MPIQ-1.5D0*MUQ)*RHOA
      RHOSQ4REL(I)=RHOSQ4REL(I)+(9D0*GA**4/(512D0*PI*M*FPI**4)*(4D0*MPIQ-1.5D0*MUQ)*RHOA)*MUQ
      ETATQ4REL(I)=ETATQ4REL(I)-GA**2/(256D0*PI*M*FPI**4)*(8D0*MPIQ-2D0*MUQ-GA**2*(4D0*MPIQ-1.5D0*MUQ))*RHOA
      ETASQ4REL(I)=ETASQ4REL(I)+(-GA**2/(256D0*PI*M*FPI**4)*(8D0*MPIQ-2D0*MUQ-GA**2*(4D0*MPIQ-1.5D0*MUQ))*RHOA)*MUQ
      RHOSLQ4REL(I)=RHOSLQ4REL(I)-3D0*GA**4/(64D0*PI*M*FPI**4)*(2D0*MPIQ-MUQ)*RHOA
      ETASLQ4REL(I)=ETASLQ4REL(I)-GA**2*(1D0-GA**2)/(64D0*PI*M*FPI**4)*(4D0*MPIQ-MUQ)*RHOA
      RHOCQ4REL(I)=RHOCQ4REL(I)+3D0*GA**4/(512D0*PI*M*FPI**4)*(2D0*MPI**2-MU**2)**2*RHOA
      ETACQ4REL(I)=ETACQ4REL(I)-GA**4/(256D0*PI*M*FPI**4)*(2D0*MPI**2-MU**2)**2*RHOA
      RHOTQ4REL(I)=RHOTQ4REL(I)-3D0*GA**4/(1024D0*PI*M*FPI**4)*(4D0*MPI**2-MU**2)*RHOA
      RHOSQ4REL(I)=RHOSQ4REL(I)-(3D0*GA**4/(1024D0*PI*M*FPI**4)*(4D0*MPI**2-MU**2)*RHOA)*MUQ
      ETATQ4REL(I)=ETATQ4REL(I)+GA**4/(512D0*PI*M*FPI**4)*(4D0*MPI**2-MU**2)*RHOA
      ETASQ4REL(I)=ETASQ4REL(I)+(GA**4/(512D0*PI*M*FPI**4)*(4D0*MPI**2-MU**2)*RHOA)*MUQ
    END DO
    DO I=1,NMU
      POTLONGQ4COORD(1)=POTLONGQ4COORD(1)+1D0/(2D0*PI**2*RPUNGEV)*MUP(I)*RHOCQ4(I)*MUW(I)
      POTLONGQ4COORD(2)=POTLONGQ4COORD(2)+1D0/(2D0*PI**2*RPUNGEV)*MUP(I)*ETACQ4(I)*MUW(I)
      POTLONGQ4COORD(3)=POTLONGQ4COORD(3)+1D0/(3D0*PI**2*RPUNGEV)*MUP(I)*RHOSQ4(I)*MUW(I)
      POTLONGQ4COORD(4)=POTLONGQ4COORD(4)-1D0/(6D0*PI**2*RPUNGEV**3)*MUP(I)*&
                        (3D0+3D0*MUP(I)*RPUNGEV+MUP(I)**2*RPUNGEV**2)*RHOTQ4(I)*MUW(I)
      POTLONGQ4COORD(5)=POTLONGQ4COORD(5)+1D0/(3D0*PI**2*RPUNGEV)*MUP(I)*ETASQ4(I)*MUW(I)
      POTLONGQ4COORD(6)=POTLONGQ4COORD(6)-1D0/(6D0*PI**2*RPUNGEV**3)*MUP(I)*&
                        (3D0+3D0*MUP(I)*RPUNGEV+MUP(I)**2*RPUNGEV**2)*ETATQ4(I)*MUW(I)
      POTLONGQ4RELCOORD(1)=POTLONGQ4RELCOORD(1)+1D0/(2D0*PI**2*RPUNGEV)*MUP(I)*RHOCQ4REL(I)*MUW(I)
      POTLONGQ4RELCOORD(2)=POTLONGQ4RELCOORD(2)+1D0/(2D0*PI**2*RPUNGEV)*MUP(I)*ETACQ4REL(I)*MUW(I)
      POTLONGQ4RELCOORD(3)=POTLONGQ4RELCOORD(3)+1D0/(3D0*PI**2*RPUNGEV)*MUP(I)*RHOSQ4REL(I)*MUW(I)
      POTLONGQ4RELCOORD(4)=POTLONGQ4RELCOORD(4)-1D0/(6D0*PI**2*RPUNGEV**3)*MUP(I)*&
                        (3D0+3D0*MUP(I)*RPUNGEV+MUP(I)**2*RPUNGEV**2)*RHOTQ4REL(I)*MUW(I)
      POTLONGQ4RELCOORD(5)=POTLONGQ4RELCOORD(5)+1D0/(3D0*PI**2*RPUNGEV)*MUP(I)*ETASQ4REL(I)*MUW(I)
      POTLONGQ4RELCOORD(6)=POTLONGQ4RELCOORD(6)-1D0/(6D0*PI**2*RPUNGEV**3)*MUP(I)*&
                        (3D0+3D0*MUP(I)*RPUNGEV+MUP(I)**2*RPUNGEV**2)*ETATQ4REL(I)*MUW(I)
      POTLONGQ4RELCOORD(7)=POTLONGQ4RELCOORD(7)-1D0/(PI**2*RPUNGEV**3)*MUP(I)&
                                               *(1D0+MUP(I)*RPUNGEV)*RHOSLQ4REL(I)*MUW(I)
      POTLONGQ4RELCOORD(8)=POTLONGQ4RELCOORD(8)-1D0/(PI**2*RPUNGEV**3)*MUP(I)&
                                               *(1D0+MUP(I)*RPUNGEV)*ETASLQ4REL(I)*MUW(I)
    END DO
  END IF
END IF

END SUBROUTINE INITLONGRANGE
!***************************************************************************************************





!***************************************************************************************************
REAL(KIND(0.0D0))   FUNCTION J1(MUPUN)
IMPLICIT NONE
INTEGER                    ::I
REAL(KIND(0.0D0))          ::MUPUN,R,VAR

R=0.5D0*SQRT(MUPUN**2-4D0*MPI**2)
J1=0D0

DO I=1,NXP
  VAR=R*XP(I)/MPI
  IF (VAR .GE. 0.001D0) THEN
    J1=J1+(1D0/VAR**2-(1D0+1D0/VAR**2)**1.5D0*LOG(VAR+SQRT(1D0+VAR**2)))*XW(I)
  ELSE
    J1=J1+(-4D0/3D0-VAR**2/5D0+2D0*VAR**4/35D0-8D0*VAR**6/315D0)*XW(I)
  END IF
END DO
END FUNCTION J1
!***************************************************************************************************





!***************************************************************************************************
REAL(KIND(0.0D0))   FUNCTION J2(MUPUN)
IMPLICIT NONE
INTEGER                    ::I
REAL(KIND(0.0D0))          ::MUPUN,R,VAR

R=0.5D0*SQRT(MUPUN**2-4D0*MPI**2)
J2=0D0
DO I=1,NXP
  VAR=R*XP(I)/MPI
  IF (VAR .GE. 0.001D0) THEN
    J2=J2+(1D0/VAR**2-(1D0+1D0/VAR**2)**1.5D0*LOG(VAR+SQRT(1D0+VAR**2)))*XW(I)*XP(I)**2
  ELSE
    J2=J2+(-4D0/3D0-VAR**2/5D0+2D0*VAR**4/35D0-8D0*VAR**6/315D0)*XW(I)*XP(I)**2
  END IF
END DO
END FUNCTION J2
!***************************************************************************************************





!***************************************************************************************************
REAL(KIND(0.0D0))   FUNCTION REGLONGRANGE(RPUN,CUTN)
IMPLICIT NONE
INTEGER                    ::CUTN
REAL(KIND(0.0D0))          ::RPUN
REGLONGRANGE=(1D0-EXP(-(RPUN/CUTR(CUTN))**2))**6
END FUNCTION REGLONGRANGE
!***************************************************************************************************





!***************************************************************************************************
SUBROUTINE INITMOMGRID()
IMPLICIT NONE
INTEGER                    ::I
REAL(KIND(0.0D0))          ::YI,YF,Y
YI=1D0/(TYPMOMSCALE+0.001D0)**POWER
YF=1D0/(TYPMOMSCALE+LAMGRID)**POWER
DO I=1,NGRID
  Y=YI+(YF-YI)*REAL(I-1,KIND(0.0D0))/REAL(NGRID-1,KIND(0.0D0))
  QGRID(I)=1D0/Y**(1D0/POWER)-TYPMOMSCALE
END DO
END SUBROUTINE INITMOMGRID
!***************************************************************************************************






!***************************************************************************************************
        SUBROUTINE IK01A(X,BI0,DI0,BI1,DI1,BK0,DK0,BK1,DK1)
!       This subroutine has been adapted by EE
!       The original subroutine is downloaded from http://jin.ece.illinois.edu/
!
!       =========================================================
!       Purpose: Compute modified Bessel functions I0(x), I1(1),
!                K0(x) and K1(x), and their derivatives
!       Input :  x   --- Argument ( x √≤ 0 )
!       Output:  BI0 --- I0(x)
!                DI0 --- I0'(x)
!                BI1 --- I1(x)
!                DI1 --- I1'(x)
!                BK0 --- K0(x)
!                DK0 --- K0'(x)
!                BK1 --- K1(x)
!                DK1 --- K1'(x)
!       =========================================================
!
!        IMPLICIT DOUBLE PRECISION (A-H,O-Z)
!*EE
IMPLICIT NONE
REAL(KIND(0.0D0))          ::EL,X2,X,BI0,DI0,BI1,DI1,BK0,DK0,BK1,DK1,&
                             R,CA,XR,A,B,CT,W0,WW,CB,XR2,A1
INTEGER                    ::K,K0
        DIMENSION A(12),B(12),A1(8)
           DATA A/0.125D0,7.03125D-2,&
                  7.32421875D-2,1.1215209960938D-1,&
                  2.2710800170898D-1,5.7250142097473D-1,&
                  1.7277275025845D0,6.0740420012735D0,&
                  2.4380529699556D01,1.1001714026925D02,&
                  5.5133589612202D02,3.0380905109224D03/
           DATA B/-0.375D0,-1.171875D-1,&
                  -1.025390625D-1,-1.4419555664063D-1,&
                  -2.7757644653320D-1,-6.7659258842468D-1,&
                  -1.9935317337513D0,-6.8839142681099D0,&
                  -2.7248827311269D01,-1.2159789187654D02,&
                  -6.0384407670507D02,-3.3022722944809D03/
           DATA A1/0.125D0,0.2109375D0,&
                   1.0986328125D0,1.1775970458984D01,&
                   2.1461706161499D02,5.9511522710323D03,&
                   2.3347645606175D05,1.2312234987631D07/
        EL=0.5772156649015329D0
        X2=X*X
        IF (X.EQ.0.0D0) THEN
           BI0=1.0D0
           BI1=0.0D0
           BK0=1.0D+300
           BK1=1.0D+300
           DI0=0.0D0
           DI1=0.5D0
           DK0=-1.0D+300
           DK1=-1.0D+300
           RETURN
        ELSE IF (X.LE.18.0D0) THEN
           BI0=1.0D0
           R=1.0D0
           DO 15 K=1,50
              R=0.25D0*R*X2/(K*K)
              BI0=BI0+R
              IF (DABS(R/BI0).LT.1.0D-15) GO TO 20
15         CONTINUE
20         BI1=1.0D0
           R=1.0D0
           DO 25 K=1,50
              R=0.25D0*R*X2/(K*(K+1))
              BI1=BI1+R
              IF (DABS(R/BI1).LT.1.0D-15) GO TO 30
25         CONTINUE
30         BI1=0.5D0*X*BI1
        ELSE
           K0=12
           IF (X.GE.35.0) K0=9
           IF (X.GE.50.0) K0=7
           CA=DEXP(X)/DSQRT(2.0D0*PI*X)
           BI0=1.0D0
           XR=1.0D0/X
           DO 35 K=1,K0
              BI0=BI0+A(K)*XR**K
35         CONTINUE
           BI0=CA*BI0
           BI1=1.0D0
           DO 40 K=1,K0
              BI1=BI1+B(K)*XR**K
40         CONTINUE
           BI1=CA*BI1
        ENDIF
        IF (X.LE.9.0D0) THEN
           CT=-(DLOG(X/2.0D0)+EL)
           BK0=0.0D0
           W0=0.0D0
           R=1.0D0
           DO 65 K=1,50
              W0=W0+1.0D0/K
              R=0.25D0*R/(K*K)*X2
              BK0=BK0+R*(W0+CT)
              IF (DABS((BK0-WW)/BK0).LT.1.0D-15) GO TO 70
              WW=BK0
65         CONTINUE
70         BK0=BK0+CT
        ELSE
           CB=0.5D0/X
           XR2=1.0D0/X2
           BK0=1.0D0
           DO 75 K=1,8
              BK0=BK0+A1(K)*XR2**K
75         CONTINUE
           BK0=CB*BK0/BI0
        ENDIF
        BK1=(1.0D0/X-BI1*BK0)/BI0
        DI0=BI1
        DI1=BI0-BI1/X
        DK0=-BK1
        DK1=-BK0-BK1/X
        RETURN
        END SUBROUTINE IK01A
!***************************************************************************************************





!***************************************************************************************************
        SUBROUTINE LAGZO(N,X,W)
!       This subroutine has been adapted by EE
!       The original subroutine is downloaded from http://jin.ece.illinois.edu/
!
!       =========================================================
!       Purpose : Compute the zeros of Laguerre polynomial Ln(x)
!                 in the interval [0,√¨], and the corresponding
!                 weighting coefficients for Gauss-Laguerre
!                 integration
!       Input :   n    --- Order of the Laguerre polynomial
!                 X(n) --- Zeros of the Laguerre polynomial
!                 W(n) --- Corresponding weighting coefficients
!       =========================================================
!
!        IMPLICIT DOUBLE PRECISION (A-H,O-Z)
!*EE
IMPLICIT NONE
REAL(KIND(0.0D0))          ::X,W,HN,Z,Z0,P,F0,F1,PF,PD,FD,Q,WP,GD
INTEGER                    ::N,NRR,IT,K,J,I

        DIMENSION X(N),W(N)
        HN=1.0D0/N
        DO 35 NRR=1,N
           IF (NRR.EQ.1) Z=HN
           IF (NRR.GT.1) Z=X(NRR-1)+HN*NRR**1.27
           IT=0
10         IT=IT+1
           Z0=Z
           P=1.0D0
           DO 15 I=1,NRR-1
              P=P*(Z-X(I))
15         CONTINUE
           F0=1.0D0
           F1=1.0D0-Z
           DO 20 K=2,N
              PF=((2.0D0*K-1.0D0-Z)*F1-(K-1.0D0)*F0)/K
              PD=K/Z*(PF-F1)
              F0=F1
              F1=PF
20         CONTINUE
           FD=PF/P
           Q=0.0D0
           DO 30 I=1,NRR-1
              WP=1.0D0
              DO 25 J=1,NRR-1
                 IF (J.EQ.I) GO TO 25
                 WP=WP*(Z-X(J))
25            CONTINUE
              Q=Q+WP
30         CONTINUE
           GD=(PD-Q*FD)/P
           Z=Z-FD/GD
           IF (IT.LE.40.AND.DABS((Z-Z0)/Z).GT.1.0D-15) GO TO 10
           X(NRR)=Z
           W(NRR)=1.0D0/(Z*PD*PD)
35      CONTINUE
        RETURN
        END SUBROUTINE LAGZO
!***************************************************************************************************






!***************************************************************************************************
      SUBROUTINE SPLFAKCH(X,N,fak1,fak2,fak3)
!============================
!      IMPLICIT REAL(KIND(0.0D0)) (A-Z)
!     DIE 2.ABLEITUNGEN AN DEN RAENDERN MUESSEN = 0 SEIN !
!     MIT DEN N STUETZSTELLEN X WIRD DER SPLINE AUFGEBAUT
IMPLICIT NONE 
INTEGER               :: n,n1,i,j,n2,n3,k,l,j1
REAL(KIND(0.0D0))     :: fak1(n,n),fak2(n,n),fak3(n,n),X(N),&
                         HI(N+20),U(N+20),Q(N+20,N+20),C(N+20,N+20),&
                         ax,bx,am,al,pi,h1,h2,h3,cx

      IF (N.LE.0) STOP 'SPLFAK2: N.LE.0'
      U(1)=0D0
      HI(2)=X(2)-X(1)
      N1=N-1
      DO 10 I=2,N1
      AX=X(I+1)-X(I)
      HI(I+1)=AX
      BX=X(I+1)-X(I-1)
      CX=X(I)-X(I-1)
      AL=AX/BX
      AM=1D0-AL
      PI=1D0/(2D0-AM*U(I-1))
      U(I)=AL*PI
      DO 20 J=1,N
      Q(1,J)=0D0
      H1=0D0
      H2=0D0
      H3=0D0
      IF(J.EQ.I-1) H1=1D0/(CX*BX)
      IF(J.EQ.I) H2=1D0/(CX*AX)
      IF(J.EQ.I+1) H3=1D0/(AX*BX)
      Q(I,J)=-PI*(AM*Q(I-1,J)-H1+H2-H3)
  20  CONTINUE
  10  CONTINUE
      N2=N+1
      N3=N+2
      DO 30 K=3,N2
      J1=N3-K
      H1=1D0/HI(J1+1)
      DO 40 L=1,N
      C(N,L)=0D0
      C(J1,L)=Q(J1,L)-C(J1+1,L)*U(J1)
      FAK1(J1,L)=-HI(J1+1)*(2D0*C(J1,L)+C(J1+1,L))
      IF(L.EQ.J1) FAK1(J1,L)=FAK1(J1,L)-H1
      IF(L.EQ.J1+1) FAK1(J1,L)=FAK1(J1,L)+H1
      FAK2(J1,L)=3D0*C(J1,L)
      FAK3(J1,L)=(C(J1+1,L)-C(J1,L))*H1
      FAK1(N,L)=0D0
      FAK2(N,L)=0D0
      FAK3(N,L)=0D0
  40  CONTINUE
  30  CONTINUE
      RETURN
      END SUBROUTINE SPLFAKCH
!***************************************************************************************************






!***************************************************************************************************
        SUBROUTINE CUBBASISCH(XOLD,N,XNEW,M,SPL)
! *** Die Routine bereitet Basissplines mit Hilfe der SPLMOD und SPLFAK vor.
! *** Die Parameter sind wie bei cubherm definiert
! *** Die Dimension ist jetzt anders : spl(m,n) statt spl(m,4)
! *** Der Parameter index ist nicht noetig !

         IMPLICIT NONE

         INTEGER            :: n,m
         REAL(KIND(0.0D0))  :: xold(n),xnew(m),spl(m,n)
       
         REAL(KIND(0.0D0))  :: pspl(n)
         INTEGER            :: i,j

!         CALL splfak(xold,n,fak1,fak2,fak3)

         DO i=1,m
          IF((xnew(i).GE.xold(1)).AND.(xnew(i).LE.xold(n))) THEN
            CALL splmodch(xold,n,xnew(i),pspl,fak1,fak2,fak3)
            DO j=1,n
!***  hier kann Interpolation aendern
             spl(i,j)=pspl(j)
!      X           *xold(j)/xnew(i)
            END DO
           ELSE
            DO j=1,n
             spl(i,j)=0.0
            END DO
!            IF(xnew(i).GE.xold(n)) THEN
!              spl(i,n)=(xnew(i)-xold(n-1))/(xold(n)-xold(n-1))
!!     X                      *xold(1)/xnew(i)
!              spl(i,2)=(xold(n)-xnew(i))/(xold(n)-xold(n-1))
!!     X                      *xold(2)/xnew(i)
!            END IF
            IF(xnew(i).LE.xold(1)) THEN
              spl(i,1)=(xold(2)-xnew(i))/(xold(2)-xold(1))
!      X                     *xold(1)/xnew(i)
              spl(i,2)=(xnew(i)-xold(1))/(xold(2)-xold(1))
!      X                     *xold(2)/xnew(i)
            END IF
          END IF   
         END DO

        END SUBROUTINE cubbasisch
!***************************************************************************************************





!***************************************************************************************************      
      SUBROUTINE SPLMODCH(X,N,XA,SPL,fak1,fak2,fak3)
!==================================
      IMPLICIT NONE
!     MITTELS N STUETZSTELLEN X WERDEN DIE FUNKTIONSWERTE SPL
!     AN BELIEBIGEN STELLEN XA INTERPOLIERT
!     IM HP MUSS ZUR ENDGUELTIGEN RECHNUNG NOCH
!     SUMME UEBER J SPL(J)*Y(J) GEBILDET WERDEN
INTEGER               :: i,n,j,i1
REAL(KIND(0.0D0))     :: fak1(n,n),fak2(n,n),fak3(n,n),x(n),spl(n),xa,dx

      IF (N.LE.0) STOP 'SPLMOD2: N.LE.0'
   1  I=0
   2  I=I+1
      IF(I.GT.N) GO TO 3
      IF(XA.GE.X(I)) GO TO 2
   3  I1=I-1
      IF(I1.EQ.0) I1=1
      DX=XA-X(I1)
      DO 10 J=1,N
      SPL(J)=((FAK3(I1,J)*DX+FAK2(I1,J))*DX+FAK1(I1,J))*DX
      IF(J.EQ.I1) SPL(J)=SPL(J)+1.
  10  CONTINUE
      RETURN
      END SUBROUTINE
!***************************************************************************************************





!***************************************************************************************************
SUBROUTINE TRNSCH(NP1,NP2,NP,P1,P2,P3,XP,AP)
!     ===============
!
!     TRNS BELEGT DIE FELDER XP UND AP MIT TRANSFORMIERTEN
!     GAUSS-LEGENDRE-PUNKTEN UND GEWICHTEN
!
!     NP1 PUNKTE WERDEN UEBER DIE HYPERBOLISCHE TRANSFORMATION
!
!     X --> (1.+X) / (1./P1-(1./P1-2./P2)*X)
!
!     AUF DAS INTERVALL (0.;P2) ABGEBILDET, WOBEI
!     NP1/2 PUNKTE IN (0.;P1) UND
!     NP1/2 PUNKTE IN (P1;P2) LIEGEN
!
!     NP2 PUNKTE WERDEN UEBER DIE LINEARE TRANSFORMATION
!
!     X --> (P3+P2)/2. + (P3-P2)/2.*X
!
!     AUF DAS INTERVALL (P2;P3) ABGEBILDET
!
!     NP = NP1 + NP2
!
      IMPLICIT NONE 
      INTEGER NP,NP1,NP2,I
      REAL(KIND(0.0D0))  XP1(5000),AP1(5000),XP2(5000),AP2(5000)
      REAL(KIND(0.0D0))  XP(NP),AP(NP),P1,P2,P3,X,A
      REAL(KIND(0.0D0))  XX,DELPH

      IF(NP1.GT.5000) STOP 'NP1 in TRNS'
      IF(NP2.GT.5000) STOP 'NP2 in TRNS'

      CALL gaulegch(-1.0D0,1.0D0,XP1,AP1,NP1)

      DO 1 I=1,NP1
      X=XP1(I)
      A=AP1(I)
      XX=1D0/P1-(1D0/P1-2D0/P2)*X
      XP1(I)=(1D0+X) / XX
      AP1(I)=(2D0/P1-2D0/P2)*A / XX**2
1     CONTINUE
!
      IF(NP2 .NE. 0) THEN

      CALL gaulegch(-1.0D0,1.0D0,XP2,AP2,NP2)

      DO 2 I=1,NP2
      X=XP2(I)
      A=AP2(I)
      DELPH=(P3-P2)/2D0
      XP2(I)=(P3+P2)/2D0 + DELPH*X
      AP2(I)=DELPH*A
2     CONTINUE
      ENDIF
!
      DO 3 I=1,NP1
      XP(I)=XP1(I)
      AP(I)=AP1(I)
3     CONTINUE
!
      IF(NP2 .NE. 0) THEN
      DO 4 I=1,NP2
      XP(I+NP1)=XP2(I)
      AP(I+NP1)=AP2(I)
4     CONTINUE
      ENDIF
!
      RETURN
      END SUBROUTINE
!***************************************************************************************************






!***************************************************************************************************
      SUBROUTINE GAULEGCH(X1,X2,X,W,N)
      IMPLICIT NONE 
      INTEGER N,M,I,J
      REAL(KIND(0.0D0)) X1,X2,X(N),W(N),EPS,XM,XL,Z,P1,P2,P3,PP,Z1
      PARAMETER (EPS=3.0D-14)
      M=(N+1)/2
      XM=0.5D0*(X2+X1)
      XL=0.5D0*(X2-X1)
      DO 12 I=1,M

        Z=COS(3.141592653589793238D0*(REAL(I,KIND(0.0D0))-0.25D0)/(REAL(N,KIND(0.0D0))+0.5D0))
1       CONTINUE
          P1=1D0
          P2=0D0
          DO 11 J=1,N
            P3=P2
            P2=P1
            P1=((2.0D0*J-1D0)*Z*P2-(J-1D0)*P3)/J
11        CONTINUE
          PP=N*(Z*P1-P2)/(Z*Z-1D0)
          Z1=Z
          Z=Z1-P1/PP
        IF(ABS(Z-Z1).GT.EPS)GO TO 1
        X(I)=XM-XL*Z
        X(N+1-I)=XM+XL*Z
        W(I)=2.0D0*XL/((1.0D0-Z*Z)*PP*PP)
        W(N+1-I)=W(I)
12    CONTINUE
      END SUBROUTINE GAULEGCH
!***************************************************************************************************




!***************************************************************************************************
!---------------------------------------------------------------------
        SUBROUTINE SBESJY  (X,LMAX, J,Y,JP,YP, IFAIL )
!---------------------------------------------------------------------
!   REAL SPHERICAL BESSEL FUNCTIONS AND X DERIVATIVES
!            j , y , j', y'                    FROM L=0 TO L=LMAX
!        FOR REAL X > SQRT(ACCUR) (E.G. 1D-7)    AND INTEGER LMAX
! 
!  J (L)  =      j/L/(X) STORES   REGULAR SPHERICAL BESSEL FUNCTION:
!  JP(L)  = D/DX j/L/(X)            j(0) =  SIN(X)/X
!  Y (L)  =      y/L/(X) STORES IRREGULAR SPHERICAL BESSEL FUNCTION:
!  YP(L)  = D/DX y/L/(X)            y(0) = -COS(X)/X
!                                                
!    IFAIL = -1 FOR ARGUMENTS OUT OF RANGE
!          =  0 FOR ALL RESULTS SATISFACTORY
! 
!   USING LENTZ-THOMPSON EVALUATION OF CONTINUED FRACTION CF1,
!   AND TRIGONOMETRIC FORMS FOR L = 0 SOLUTIONS.
!   LMAX IS LARGEST L NEEDED AND MUST BE <= MAXL, THE ARRAY INDEX.
!   MAXL CAN BE DELETED AND ALL THE ARRAYS DIMENSIONED (0:*)
!   SMALL IS MACHINE DEPENDENT, ABOUT SQRT(MINIMUM REAL NUMBER),
!         SO 1D-150 FOR DOUBLE PRECISION ON VAX, PCS ETC.
!   PRECISION:  RESULTS TO WITHIN 2-3 DECIMALS OF "MACHINE ACCURACY"
!   IN OSCILLATING REGION X .GE.  [ SQRT{LMAX*(LMAX+1)} ]
!   I.E. THE TARGET ACCURACY ACCUR SHOULD BE 100 * ACC8 WHERE ACC8
!   IS THE SMALLEST NUMBER WITH 1+ACC8.NE.1 FOR OUR WORKING PRECISION
!   THIS RANGES BETWEEN 4E-15 AND 2D-17 ON CRAY, VAX, SUN, PC FORTRANS
!   SO CHOOSE A SENSIBLE  ACCUR = 1.0D-14
!   IF X IS SMALLER THAN [ ] ABOVE THE ACCURACY BECOMES STEADILY WORSE:
!   THE VARIABLE ERR IN COMMON /STEED/ HAS AN ESTIMATE OF ACCURACY.
!
!   NOTE: FOR X=1 AND L=100  J = 7.4 E-190     Y = -6.7+E186    1.4.94
!---------------------------------------------------------------------
!   AUTHOR :   A.R.BARNETT       MANCHESTER    12 MARCH 1990/95
!                                AUCKLAND      12 MARCH 1991
!---------------------------------------------------------------------  
        IMPLICIT    NONE
        INTEGER     LIMIT,         MAXL,       LMAX, IFAIL, NFP, L
        PARAMETER ( LIMIT = 20000, MAXL = 1001 )
        DOUBLE PRECISION  J(0:MAXL), Y(0:MAXL), JP(0:MAXL), YP(0:MAXL)
        DOUBLE PRECISION  ZERO,ONE,TWO,THREE,SMALL, ACCUR, TK,SL, ERR
        DOUBLE PRECISION  X,XINV, CF1,DCF1, DEN, C,D, OMEGA, TWOXI
        PARAMETER ( ZERO  = 0.0D0  , ONE   = 1.0D0 , TWO = 2.0D0 )
        PARAMETER ( SMALL = 1.D-150, THREE = 3.0D0 )
        COMMON /STEDE/    ERR,NFP       ! not required in code        
!-------
        ACCUR = 1.D-14                  ! suitable for double precision
        IFAIL = -1                      ! user to check on exit
        IF (X .LT. DSQRT(ACCUR) )       GOTO 50
!-------TAKES CARE OF NEGATIVE X ... USE REFLECTION FORMULA
!-------BEGIN CALCULATION OF CF1 UNLESS LMAX = 0, WHEN SOLUTIONS BELOW
            XINV  = ONE / X
        IF (LMAX .GT. 0) THEN
            TWOXI =     XINV + XINV
            SL  =  REAL(LMAX)* XINV     ! used also in do loop 3
            TK  =  TWO * SL  + XINV * THREE     
            CF1 =  SL                   ! initial value of CF1
            DEN =  ONE                  ! unnormalised j(Lmax,x)
            IF ( ABS(CF1) .LT. SMALL ) CF1 = SMALL
            C   = CF1                   ! inverse ratio of A convergents
            D   = ZERO                  ! direct  ratio of B convergents   
            DO 10 L = 1,LIMIT
                C   = TK - ONE / C
                D   = TK - D
                        IF ( ABS(C) .LT. SMALL ) C = SMALL
                        IF ( ABS(D) .LT. SMALL ) D = SMALL
                D   = ONE / D
                DCF1= D   * C
                CF1 = CF1 * DCF1
                        IF ( D .LT. ZERO ) DEN = - DEN
                        IF ( ABS(DCF1 - ONE) .LE. ACCUR ) GOTO 20
               TK   = TK + TWOXI
               NFP  = L                 ! ie number in loop
   10       CONTINUE
                    GOTO 50             ! error exit, no convergence
   20       CONTINUE
            ERR = ACCUR * DSQRT(DBLE(NFP))    ! error estimate
                    J (LMAX) = DEN      ! lower-case j's  really
                    JP(LMAX) = CF1 * DEN                         
!------ DOWNWARD RECURSION TO L=0  AS SPHERICAL BESSEL FUNCTIONS
            DO 30  L =  LMAX , 1, -1
                   J (L-1)  = (SL + XINV) * J(L)   + JP(L)
                        SL  =  SL - XINV
                   JP(L-1)  =  SL * J(L-1)          - J(L)
   30       CONTINUE
            DEN = J(0)
        ENDIF                           ! end loop for Lmax GT 0
!------ CALCULATE THE L=0 SPHERICAL BESSEL FUNCTIONS DIRECTLY
        J (0)   =  XINV * DSIN(X)
        Y (0)   = -XINV * DCOS(X)
        JP(0)   = -Y(0) - XINV * J(0)
        YP(0)   =  J(0) - XINV * Y(0)
        IF (LMAX .GT. 0) THEN
                   OMEGA  =  J(0) / DEN
                      SL  = ZERO
            DO 40 L = 1 , LMAX
                    J (L) = OMEGA * J (L)
                    JP(L) = OMEGA * JP(L)
                    Y (L) = SL * Y(L-1)   -   YP(L-1)
                      SL  = SL + XINV
                    YP(L) = Y(L-1)  -  (SL + XINV) * Y(L)
   40       CONTINUE
        ENDIF
        IFAIL = 0                       ! calculations successful
        RETURN
!---------------------------------------------------------------------
!       ERROR TRAPS
!---------------------------------------------------------------------
   50   IF (X .LT. ZERO) THEN
                WRITE(6,1000) X
          ELSEIF (X .EQ. ZERO) THEN
                       IFAIL = 0
                        J(0) = ONE
                DO 60 L = 1, LMAX
                        J(L) = ZERO     ! remaining arrays untouched
   60           CONTINUE            
          ELSE                          ! x .le. sqrt(accur), e.g. 1D-7
                WRITE(6,1001) X
          ENDIF
 1000   FORMAT(' X NEGATIVE !',1PE15.5,'    USE REFLECTION FORMULA'/)
 1001   FORMAT(' WITH X = ',1PE15.5,'    TRY SMALL-X SOLUTIONS',/,&
       '    j/L/(X)  ->   X**L / (2L+1)!!          AND',/,&
       '    y/L/(X)  ->  -(2L-1)!! / X**(L+1)'/)
        RETURN
!        END
!---------------------------------------------------------------------
       END SUBROUTINE SBESJY 
!---------------------------------------------------------------------
!***************************************************************************************************





!***************************************************************************************************
SUBROUTINE PARCCH(POT,POTEN,JMOM)
IMPLICIT NONE
INTEGER                    ::K,JMOM
REAL(KIND(0.0D0))          ::SUM(6),POTEN(NZPUN),POT(6)
INTENT(IN)                 ::POTEN,JMOM
INTENT(OUT)                ::POT

SUM=0.0D0
IF (JMOM == 0) THEN
  DO K=1,NZPUN
    SUM(1)=SUM(1)+POTEN(K)*ZWEI(K)*PL(K)
    SUM(3)=SUM(3)+POTEN(K)*ZPUN(K)*ZWEI(K)*PL(K)
  END DO
ELSE
  DO K=1,NZPUN      
    SUM(1)=SUM(1)+POTEN(K)*ZWEI(K)*PL(K)       
    SUM(2)=SUM(2)+POTEN(K)*ZWEI(K)*PL(K)       
    SUM(3)=SUM(3)+POTEN(K)*ZWEI(K)*PLP(K)       
    SUM(4)=SUM(4)+POTEN(K)*ZWEI(K)*PLM(K)       
  END DO
END IF
POT=2.0D0*PI*SUM
END SUBROUTINE PARCCH
!***************************************************************************************************





!***************************************************************************************************
SUBROUTINE PARSIGCH(POT,POTEN,JMOM)
IMPLICIT NONE
INTEGER                    ::K,JMOM
REAL(KIND(0.0D0))          ::SUM(6),POTEN(NZPUN),POT(6)
INTENT(IN)                 ::POTEN,JMOM
INTENT(OUT)                ::POT

SUM=0.0D0
IF(JMOM == 0) THEN 
  DO K=1,NZPUN
    SUM(1)=SUM(1)-3.0D0*POTEN(K)*ZWEI(K)*PL(K)
    SUM(3)=SUM(3)+POTEN(K)*ZPUN(K)*ZWEI(K)*PL(K)
  END DO
ELSE
  DO K=1,NZPUN      
    SUM(1)=SUM(1)-3.0D0*POTEN(K)*ZWEI(K)*PL(K)       
    SUM(2)=SUM(2)+POTEN(K)*ZWEI(K)*PL(K)       
    SUM(3)=SUM(3)+POTEN(K)*ZWEI(K)*PLP(K)       
    SUM(4)=SUM(4)+POTEN(K)*ZWEI(K)*PLM(K)       
  END DO
END IF 
POT=2.0D0*PI*SUM
END SUBROUTINE PARSIGCH
!***************************************************************************************************





!***************************************************************************************************
SUBROUTINE PARSIGDCH(POT,POTEN,JMOM,QPUN,QPUNP)
IMPLICIT NONE
INTEGER                    ::K,L,JMOM
REAL(KIND(0.0D0))          ::SUM(6),POTEN(NZPUN),&
                             QPUN,QPUNP,POT(6),LLDUM
INTENT(IN)                 ::POTEN,JMOM,QPUN,QPUNP
INTENT(OUT)                ::POT

L=JMOM
SUM=0.0D0
IF (JMOM == 0) THEN
  DO K=1,NZPUN
      SUM(1)=SUM(1)+POTEN(K)*ZWEI(K)*(-QPUN**2-QPUNP**2+2.0D0*QPUN*QPUNP*&
           ZPUN(K))*PL(K)
      SUM(3)=SUM(3)-POTEN(K)*ZWEI(K)*((QPUN**2+QPUNP**2)*ZPUN(K)-2.0D0*QPUN*&
           QPUNP)*PL(K)
  END DO
ELSE
  DO K=1,NZPUN      
        SUM(1)=SUM(1)+POTEN(K)*ZWEI(K)*(-QPUN**2-QPUNP**2+2.0D0*QPUN*QPUNP*&
           ZPUN(K))*PL(K)     
        SUM(2)=SUM(2)+POTEN(K)*ZWEI(K)*((QPUN**2+QPUNP**2)*PL(K)-&
             2.0D0*QPUN*QPUNP/REAL(2*L+1,KIND(0.0D0))*(REAL(L,KIND(0.0D0))*PLP(K)+&
             REAL(L+1,KIND(0.0D0))*PLM(K)))   
        SUM(3)=SUM(3)+POTEN(K)*ZWEI(K)/REAL(2*L+1,KIND(0.0D0))*(-(QPUN**2+QPUNP**2)*&
             PLP(K)+2.0D0*QPUN*QPUNP*PL(K)) 
        SUM(4)=SUM(4)+POTEN(K)*ZWEI(K)/REAL(2*L+1,KIND(0.0D0))*((QPUN**2+QPUNP**2)*&
             PLM(K)-2.0D0*QPUN*QPUNP*PL(K))        
        LLDUM=REAL(L*(L+1),KIND(0.0D0))
        SUM(5)=SUM(5)+2.0D0*POTEN(K)*ZWEI(K)*SQRT(LLDUM)/&
             REAL(2*L+1,KIND(0.0D0))*(QPUNP**2*PLP(K)+&
             QPUN**2*PLM(K)-2.0D0*QPUN*QPUNP*PL(K))
        SUM(6)=SUM(6)+2.0D0*POTEN(K)*ZWEI(K)*SQRT(LLDUM)/&
             REAL(2*L+1,KIND(0.0D0))*(QPUNP**2*PLM(K)+&
             QPUN**2*PLP(K)-2.0D0*QPUN*QPUNP*PL(K))
  END DO
END IF
POT=2.0D0*PI*SUM
END SUBROUTINE PARSIGDCH
!***************************************************************************************************





!***************************************************************************************************
SUBROUTINE PARSLCH(POT,POTEN,JMOM,QPUN,QPUNP)
IMPLICIT NONE
INTEGER                    ::K,JMOM
REAL(KIND(0.0D0))          ::SUM(6),POTEN(NZPUN),&
                             QPUN,QPUNP,POT(6)
INTENT(IN)                 ::POTEN,JMOM,QPUN,QPUNP
INTENT(OUT)                ::POT

SUM=0.0D0
IF (JMOM == 0) THEN
  DO K=1,NZPUN
     SUM(3)=SUM(3)+POTEN(K)*QPUN*QPUNP*(ZPUN(K)**2-1.0D0)*ZWEI(K)*PL(K)
  END DO
ELSE
  DO K=1,NZPUN      
    SUM(2)=SUM(2)+POTEN(K)*QPUNP*QPUN/REAL(2*JMOM+1,KIND(0.0D0))*ZWEI(K)*(PLP(K)-&
         PLM(K))       
    SUM(3)=SUM(3)-POTEN(K)*QPUNP*QPUN*ZWEI(K)*(PL(K)-ZPUN(K)*PLP(K))       
    SUM(4)=SUM(4)-POTEN(K)*QPUNP*QPUN*ZWEI(K)*(PL(K)-ZPUN(K)*PLM(K))     
  END DO
END IF
POT=2.0D0*PI*SUM
END SUBROUTINE PARSLCH
!***************************************************************************************************





!***************************************************************************************************
REAL(KIND(0.0D0))   function plff(x,n)
!======================================
! calculates Legendre polynomials Pn(x)
! using the recurrence relation
! if n > 100 the function retuns 0.0
!======================================
double precision x
integer n, k
double precision pln(0:n)

pln(0) = 1.0

pln(0) = 1.0
if(n>0) then
 pln(1) = x
end if

if (n <= 1) then
  plff = pln(n)
  else
  do k=1,n-1
    pln(k+1) = ((2.0*k+1.0)*x*pln(k) - float(k)*pln(k-1))/(float(k+1))
  end do
  plff = pln(n)
end if
return
end function plff
!***************************************************************************************************

END MODULE ICHIRAL
