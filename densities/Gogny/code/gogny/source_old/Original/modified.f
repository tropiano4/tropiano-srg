!---------------------------------------------------------------------!
!                                                                     !
!     MODULE TO CALCULATE CLEBSCH-GORDAN COEFFICIENTS (3J-SYMBOLS)    !                
!                                                                     !
!---------------------------------------------------------------------!

 MODULE angmom

	USE input
	USE lgfactor
	USE math

	IMPLICIT NONE

	DOUBLE PRECISION, DIMENSION(:, :, :), ALLOCATABLE :: TJ

	PRIVATE TJ

 CONTAINS

        ! Function calculating the Delta(abc) function as defined in 
	! Varshalovitch, Sec. 8.2, Eq. (1), page 237

	FUNCTION DELTA(a, b, c)
		DOUBLE PRECISION DELTA
		INTEGER, INTENT(IN) :: a, b, c

		DELTA = EXP(0.5 * &
			(DDLogFactorials((a + b - c) / 2) + &
			 DDLogFactorials((a + c - b) / 2) + &
			 DDLogFactorials((b + c - a) / 2) - &
			 DDLogFactorials((a + b + c + 2 ) / 2)))
		RETURN
	END FUNCTION DELTA

        !  "Create" a new 3j-symbol by allocating the required memory
	!  and initializing all coefficients to 0

	SUBROUTINE ThreeJSymbols_new

		INTEGER u1, u2, u3

		ALLOCATE(TJ (0:(2 * N_0), 0:(2 * N_0), 0:(2 * N_0)))
		DO u1 = 0, 2 * N_0
			DO u2 = 0, u1
				DO u3 = 0, u2
					TJ(u1, u2, u3) = 0.0
				END DO
			END DO
		END DO
		RETURN
	END SUBROUTINE

        !  Calculating the 3j-symbol for all m equal to  

	FUNCTION ThreeJSymbols_get(j_1, j2, j_3)
		DOUBLE PRECISION ThreeJSymbols_get
		INTEGER, INTENT(IN) :: j_1, j2, j_3

		INTEGER j1, j3
		INTEGER u1, u2, u3, p

		ThreeJSymbols_get = 0.0

		p = (j_1 + j2 + j_3) / 2
		IF (MOD(p, 2) .EQ. 1) RETURN ! is odd?

		IF (j_3 .GT. j_1) THEN
			j1 = j_3
			j3 = j_1
		ELSE
			j1 = j_1
			j3 = j_3
		END IF

		ThreeJSymbols_get = TJ(j1 / 2, j3 / 2, (j2 - ABS(j1 - j3)) / 2)
		
		IF (ThreeJSymbols_get .NE. 0.0) RETURN

		u1 = ( j1 + j2 - j3) / 2
		u2 = ( j1 - j2 + j3) / 2
		u3 = (-j1 + j2 + j3) / 2
		
		ThreeJSymbols_get = PAR(p / 2) * DELTA(j1, j2, j3) * &
			      EXP(DDLogFactorials(p / 2) &
				-(DDLogFactorials((p - j1) / 2) &
				+ DDLogFactorials((p - j2) / 2) &
				+ DDLogFactorials((p - j3) / 2)))

		TJ(j1 / 2, j3 / 2, (j2 - ABS(j1 - j3)) / 2) = ThreeJSymbols_get
		RETURN
	END FUNCTION ThreeJSymbols_get

END MODULE angmom
	DOUBLE PRECISION, DIMENSION(0:1, 0:1658) :: Nucleus_AtomicMass
	DATA Nucleus_AtomicMass / &
		001008664.914, 0000.008, 001007825.033, 0000.007, &
		002014101.775, 0000.015, 003016049.265, 0000.023, &
		003016029.297, 0000.023, 004027740.000, 0410.000, &
		004002603.230, 0000.030, 004026970.000, 0320.000, &
		005012220.000, 0050.000, 005012540.000, 0050.000, &
		006018886.300, 0001.000, 006015121.500, 0000.700, &
		006019725.000, 0006.000, 007028030.000, 0030.000, &
		007016003.200, 0000.800, 007016928.500, 0000.800, &
		007029920.000, 0080.000, 008033922.000, 0008.000, &
		008022485.900, 0000.800, 008005305.100, 0000.080, &
		008024605.900, 0001.300, 008037674.000, 0026.000, &
		009043810.000, 0130.000, 009026789.100, 0002.100, &
		009012182.200, 0000.400, 009013328.900, 0001.200, &
		009031040.100, 0002.500, 010036320.000, 0270.000, &
		010013534.100, 0000.400, 010012937.160, 0000.290, &
		010016853.500, 0000.400, 011043910.000, 0110.000, &
		011021658.000, 0007.000, 011009305.600, 0000.400, &
		011011433.600, 0001.000, 011026720.000, 0150.000, &
		012026921.000, 0016.000, 012014352.600, 0001.400, &
		012000000.000, 0000.000, 012018613.000, 0001.100, &
		012034420.000, 0050.000, 013037570.000, 0540.000, &
		013017780.400, 0001.100, 013003354.834, 0000.011, &
		013005738.600, 0000.290, 013024812.000, 0010.000, &
		014043050.000, 0140.000, 014025404.000, 0023.000, &
		014003241.979, 0000.017, 014003073.998, 0000.016, &
		014008595.310, 0000.090, 015031100.000, 0024.000, &
		015010599.200, 0000.900, 015000108.960, 0000.026, &
		015003065.400, 0000.600, 015018000.000, 0140.000, &
		016014701.000, 0004.000, 016006099.900, 0002.500, &
		015994914.620, 0000.030, 016011466.000, 0009.000, &
		016025753.000, 0021.000, 017022582.000, 0019.000, &
		017008450.000, 0016.000, 016999131.420, 0000.270, &
		017002095.310, 0000.270, 017017690.000, 0050.000, &
		018026760.000, 0030.000, 018014082.000, 0021.000, &
		017999160.300, 0000.900, 018000937.600, 0000.700, &
		018005710.000, 0005.000, 019017038.000, 0020.000, &
		019003577.000, 0003.000, 018998403.200, 0000.090, &
		019001879.700, 0000.600, 019013879.000, 0013.000, &
		020004076.100, 0001.300, 019999981.370, 0000.180, &
		019992434.000, 0002.000, 020007342.000, 0008.000, &
		020018862.000, 0029.000, 021008660.000, 0016.000, &
		020999949.000, 0001.900, 020993840.700, 0001.900, &
		020997649.100, 0002.100, 021011716.000, 0018.000, &
		022010140.000, 0090.000, 022003030.000, 0030.000, &
		021991382.500, 0001.600, 021994433.500, 0001.700, &
		021999573.800, 0001.600, 022019420.000, 0080.000, &
		023003600.000, 0180.000, 022994464.800, 0002.700, &
		022989766.700, 0000.800, 022994123.800, 0001.500, &
		023007265.000, 0027.000, 023993612.000, 0011.000, &
		023990960.400, 0000.800, 023985041.900, 0000.700, &
		023999941.000, 0004.000, 024011546.000, 0021.000, &
		024997790.000, 0050.000, 024989951.400, 0001.500, &
		024985837.000, 0000.700, 024990428.500, 0001.000, &
		025004109.000, 0011.000, 026000470.000, 0080.000, &
		025992588.000, 0017.000, 025982593.500, 0000.700, &
		025986891.700, 0000.700, 025992330.000, 0003.000, &
		026993990.000, 0040.000, 026984341.100, 0000.900, &
		026981538.200, 0000.600, 026986703.900, 0000.600, &
		026999190.000, 0040.000, 027998780.000, 0150.000, &
		027983876.400, 0002.200, 027981909.900, 0000.600, &
		027976926.600, 0000.600, 027992312.000, 0004.000, &
		028004440.000, 0170.000, 029002850.000, 0160.000, &
		028988560.000, 0030.000, 028980444.600, 0001.400, &
		028976494.500, 0000.600, 028981801.500, 0001.000, &
		028996610.000, 0050.000, 030008810.000, 0260.000, &
		029990230.000, 0230.000, 029982940.000, 0040.000, &
		029973769.700, 0000.600, 029978313.600, 0000.700, &
		029984903.000, 0003.000, 031012700.000, 0620.000, &
		030983840.000, 0070.000, 030975361.700, 0000.600, &
		030973761.500, 0000.500, 030979554.100, 0001.600, &
		030992420.000, 0050.000, 032017760.000, 0800.000, &
		031998120.000, 1700.000, 031974148.100, 0001.000, &
		031973907.200, 0000.500, 031972070.500, 0000.175, &
		031985690.000, 0008.000, 031997660.000, 0050.000, &
		033023050.000, 1220.000, 032978001.000, 0017.000, &
		032971725.100, 0001.200, 032971458.301, 0000.147, &
		032977451.600, 0000.600, 032989930.000, 0030.000, &
		034028610.000, 3830.000, 033978574.000, 0016.000, &
		033973636.400, 0001.300, 033967866.535, 0000.137, &
		033973762.717, 0000.198, 033980270.000, 0003.000, &
		034984630.000, 0050.000, 034973314.100, 0002.000, &
		034969031.813, 0000.136, 034968852.716, 0000.043, &
		034975256.200, 0001.400, 034988012.000, 0021.000, &
		035004778.000, 0060.000, 035978260.000, 0014.000, &
		035967080.832, 0000.258, 035968306.971, 0000.084, &
		035967546.250, 0000.281, 035981293.000, 0009.000, &
		035993090.000, 0040.000, 036971125.666, 0000.275, &
		036965902.595, 0000.075, 036966775.500, 0000.500, &
		036973377.700, 0001.500, 036985874.000, 0024.000, &
		037971163.000, 0008.000, 037968010.502, 0000.131, &
		037962732.100, 0000.900, 037969080.000, 0001.000, &
		037976319.000, 0005.000, 038968005.600, 0002.700, &
		038964314.000, 0005.000, 038963707.700, 0001.000, &
		038970718.600, 0002.100, 038984650.000, 0050.000, &
		039975830.000, 0040.000, 039970450.000, 0040.000, &
		039962384.300, 0001.200, 039963999.500, 0001.000, &
		039962591.500, 0001.100, 039977964.000, 0005.000, &
		039990270.000, 0012.000, 040970590.000, 0160.000, &
		040964501.900, 0001.300, 040961826.800, 0001.100, &
		040962278.700, 0001.100, 040969250.800, 0001.600, &
		040983156.000, 0014.000, 041963050.000, 0040.000, &
		041962403.800, 0001.100, 041958618.500, 0001.200, &
		041965516.000, 0001.400, 041973032.000, 0006.000, &
		042975170.000, 0060.000, 042965670.000, 0080.000, &
		042960716.000, 0010.000, 042958767.000, 0001.200, &
		042961151.200, 0002.300, 042968524.000, 0008.000, &
		043965368.000, 0022.000, 043961560.000, 0040.000, &
		043955481.300, 0001.300, 043959403.300, 0002.200, &
		043959690.600, 0001.300, 043985560.000, 0030.000, &
		044968100.000, 0060.000, 044960694.000, 0011.000, &
		044956186.100, 0001.300, 044955910.500, 0001.400, &
		044958125.300, 0001.500, 044965782.000, 0018.000, &
		044979160.000, 0110.000, 045968090.000, 0040.000, &
		045961978.000, 0017.000, 045953686.900, 0002.700, &
		045955170.500, 0001.400, 045952629.800, 0001.300, &
		045960198.700, 0001.500, 045968361.000, 0022.000, &
		046972190.000, 0110.000, 046961679.000, 0009.000, &
		046954540.600, 0002.700, 046952409.700, 0002.300, &
		046951764.100, 0001.100, 046954907.300, 0001.300, &
		046962906.000, 0015.000, 047965516.000, 0026.000, &
		047952535.000, 0004.000, 047952236.000, 0006.000, &
		047947947.400, 0001.100, 047952254.800, 0002.800, &
		047954034.000, 0008.000, 047968641.000, 0023.000, &
		047980540.000, 0120.000, 048966970.000, 0320.000, &
		048955675.000, 0004.000, 048950018.000, 0004.000, &
		048947871.200, 0001.100, 048948517.300, 0001.400, &
		048951338.500, 0002.900, 048959624.000, 0026.000, &
		048973610.000, 0170.000, 049957520.000, 0010.000, &
		049952188.000, 0017.000, 049944792.400, 0001.100, &
		049947161.700, 0001.600, 049946047.000, 0001.600, &
		049954240.200, 0001.700, 049962990.000, 0060.000, &
		050962410.000, 0090.000, 050953604.000, 0022.000, &
		050946616.400, 0001.500, 050943962.500, 0001.600, &
		050944769.000, 0001.600, 050948213.800, 0001.600, &
		050956825.000, 0016.000, 051946899.000, 0008.000, &
		051944778.600, 0001.700, 051940510.700, 0001.600, &
		051945568.600, 0002.600, 051948115.000, 0011.000, &
		051963192.000, 0024.000, 051975690.000, 0080.000, &
		052949730.000, 0110.000, 052944341.000, 0004.000, &
		052940652.300, 0001.600, 052941291.700, 0001.700, &
		052945310.700, 0002.300, 052954225.000, 0019.000, &
		052968460.000, 0170.000, 053946443.000, 0016.000, &
		053938883.500, 0001.600, 053940361.800, 0002.000, &
		053939613.300, 0001.500, 053948461.800, 0001.500, &
		053957910.000, 0050.000, 054947240.000, 0110.000, &
		054940842.800, 0001.700, 054938048.100, 0001.600, &
		054938296.500, 0001.500, 054942001.600, 0001.500, &
		054951337.000, 0012.000, 055940644.000, 0010.000, &
		055938907.800, 0001.600, 055934939.800, 0001.600, &
		055939841.500, 0002.700, 055942135.000, 0012.000, &
		055958578.000, 0018.000, 055971950.000, 0090.000, &
		056938286.000, 0004.000, 056935396.200, 0001.600, &
		056936293.600, 0001.600, 056939799.000, 0003.000, &
		056949170.000, 0050.000, 056964900.000, 0130.000, &
		057940060.000, 0030.000, 057933277.800, 0001.600, &
		057935755.200, 0001.900, 057935346.300, 0001.600, &
		057944538.700, 0002.600, 057954690.000, 0110.000, &
		058940440.000, 0030.000, 058934877.800, 0001.600, &
		058933197.900, 0001.600, 058934349.500, 0001.600, &
		058939502.500, 0001.900, 058949270.000, 0040.000, &
		059943210.000, 0110.000, 059934078.000, 0004.000, &
		059933820.000, 0001.600, 059930788.300, 0001.600, &
		059937365.700, 0002.800, 059941830.000, 0011.000, &
		060936749.000, 0022.000, 060932477.800, 0001.800, &
		060931057.900, 0001.600, 060933460.100, 0002.000, &
		060939514.000, 0018.000, 061936773.000, 0016.000, &
		061934060.000, 0020.000, 061928346.300, 0001.600, &
		061932585.000, 0005.000, 061934332.000, 0011.000, &
		061944177.000, 0030.000, 062940750.000, 0060.000, &
		062933614.000, 0022.000, 062929669.700, 0001.600, &
		062929598.800, 0001.600, 062933213.300, 0002.300, &
		062939140.000, 0110.000, 063935812.000, 0022.000, &
		063927967.900, 0001.700, 063929765.500, 0001.600, &
		063929144.300, 0001.800, 063936836.000, 0004.000, &
		063941570.000, 0270.000, 064936490.000, 0050.000, &
		064930086.200, 0001.700, 064927791.700, 0001.900, &
		064929242.800, 0001.900, 064932737.800, 0002.100, &
		064939440.000, 0110.000, 065929116.000, 0017.000, &
		065928871.100, 0001.900, 065926034.600, 0001.700, &
		065931590.000, 0004.000, 065933840.000, 0030.000, &
		065944100.000, 0060.000, 066931570.000, 0020.000, &
		066927748.000, 0009.000, 066927128.800, 0001.700, &
		066928203.400, 0001.800, 066932736.000, 0005.000, &
		066939190.000, 0110.000, 067931849.000, 0019.000, &
		067929640.000, 0050.000, 067924845.500, 0001.800, &
		067927981.500, 0002.200, 067928096.000, 0007.000, &
		067936790.000, 0110.000, 068935090.000, 0160.000, &
		068929425.000, 0009.000, 068926551.600, 0001.800, &
		068925580.000, 0003.000, 068927969.000, 0004.000, &
		068932280.000, 0030.000, 068939560.000, 0040.000, &
		069931950.000, 0120.000, 069925324.000, 0003.000, &
		069926027.000, 0003.000, 069924249.400, 0001.600, &
		069930930.000, 0050.000, 070927727.000, 0011.000, &
		070924702.800, 0002.000, 070924953.200, 0002.000, &
		070927114.000, 0005.000, 071926859.000, 0007.000, &
		071926367.000, 0002.200, 071922078.900, 0001.500, &
		071926755.000, 0005.000, 071927110.000, 0013.000, &
		072929780.000, 0040.000, 072925169.000, 0007.000, &
		072923462.100, 0001.500, 072923827.000, 0004.000, &
		072926768.000, 0011.000, 072931720.000, 0240.000, &
		072938930.000, 0160.000, 073929460.000, 0020.000, &
		073926940.000, 0080.000, 073921177.100, 0001.500, &
		073923927.700, 0002.300, 073922474.300, 0001.600, &
		073929897.000, 0016.000, 073933300.000, 0060.000, &
		073944540.000, 0500.000, 074932870.000, 0100.000, &
		074926499.000, 0007.000, 074922857.800, 0001.800, &
		074921593.900, 0001.700, 074922521.300, 0001.600, &
		074925774.000, 0015.000, 074931064.000, 0021.000, &
		074938580.000, 0110.000, 075933120.000, 0180.000, &
		075928670.000, 0160.000, 075921401.300, 0001.700, &
		075922393.600, 0001.900, 075919211.700, 0001.600, &
		075924540.000, 0010.000, 075925964.000, 0013.000, &
		075935020.000, 0070.000, 076923547.100, 0002.000, &
		076920645.600, 0002.400, 076919912.200, 0001.600, &
		076921378.000, 0003.000, 076924644.000, 0019.000, &
		076930310.000, 0030.000, 076937860.000, 0160.000, &
		077922853.000, 0004.000, 077921826.000, 0011.000, &
		077917307.300, 0001.600, 077921144.000, 0004.000, &
		077920401.000, 0009.000, 077928100.000, 0040.000, &
		078932670.000, 0130.000, 078925400.000, 0100.000, &
		078920946.000, 0006.000, 078918497.200, 0001.700, &
		078918335.500, 0002.500, 078920081.000, 0004.000, &
		078923952.000, 0025.000, 079944300.000, 0390.000, &
		079936260.000, 0320.000, 079925520.000, 0030.000, &
		079922528.000, 0026.000, 079916519.200, 0001.900, &
		079918527.700, 0002.500, 079916378.000, 0007.000, &
		079922516.000, 0020.000, 079924650.000, 0030.000, &
		080937750.000, 0210.000, 080928820.000, 0130.000, &
		080922130.000, 0006.000, 080917990.300, 0002.000, &
		080916288.000, 0006.000, 080916589.000, 0006.000, &
		080918992.000, 0022.000, 080923280.000, 0040.000, &
		080929200.000, 0080.000, 080936880.000, 0320.000, &
		081929810.000, 0150.000, 081924769.000, 0027.000, &
		081916697.400, 0002.200, 081916802.000, 0006.000, &
		081913482.000, 0006.000, 081918193.000, 0019.000, &
		081918413.000, 0009.000, 081926800.000, 0110.000, &
		081931100.000, 0550.000, 082924980.000, 0240.000, &
		082919117.000, 0004.000, 082915179.000, 0005.000, &
		082914137.000, 0004.000, 082915138.000, 0023.000, &
		082917573.000, 0023.000, 082922310.000, 0060.000, &
		082928770.000, 0110.000, 083918462.000, 0016.000, &
		083916505.000, 0027.000, 083911509.000, 0003.000, &
		083914388.000, 0004.000, 083913429.000, 0004.000, &
		083920310.000, 0180.000, 084922260.000, 0110.000, &
		084915612.000, 0021.000, 084912531.000, 0004.000, &
		084911793.600, 0003.000, 084912937.000, 0004.000, &
		084916431.000, 0027.000, 084921470.000, 0110.000, &
		085924270.000, 0140.000, 085918800.000, 0060.000, &
		085910615.000, 0005.000, 085911171.200, 0002.900, &
		085909266.100, 0002.700, 085914891.000, 0015.000, &
		086920713.000, 0027.000, 086913359.000, 0005.000, &
		086909186.000, 0003.000, 086908883.100, 0002.700, &
		086910881.000, 0003.000, 086914817.000, 0009.000, &
		086920370.000, 0070.000, 086927600.000, 0340.000, &
		087924080.000, 0140.000, 087914452.000, 0015.000, &
		087911325.000, 0004.000, 087905618.200, 0002.700, &
		087909507.000, 0003.000, 087910224.000, 0011.000, &
		088917630.000, 0060.000, 088912282.000, 0008.000, &
		088907450.000, 0004.000, 088905847.700, 0002.700, &
		088908888.000, 0004.000, 088913490.000, 0040.000, &
		088919479.000, 0017.000, 089930600.000, 0130.000, &
		089919541.000, 0029.000, 089914815.000, 0014.000, &
		089907737.000, 0003.000, 089907151.100, 0002.700, &
		089904701.700, 0002.500, 089911262.000, 0005.000, &
		089913934.000, 0007.000, 090923390.000, 0090.000, &
		090916493.000, 0010.000, 090910197.000, 0009.000, &
		090907301.000, 0003.000, 090905643.000, 0002.400, &
		090906989.000, 0004.000, 090911747.000, 0013.000, &
		090918420.000, 0220.000, 091926300.000, 0090.000, &
		091919687.000, 0012.000, 091910979.000, 0014.000, &
		091908929.000, 0011.000, 091905037.800, 0002.400, &
		091907191.200, 0003.000, 091906807.000, 0004.000, &
		091915256.000, 0028.000, 092931120.000, 0130.000, &
		092921967.000, 0016.000, 092913946.000, 0018.000, &
		092909560.000, 0012.000, 092906473.400, 0002.400, &
		092906376.200, 0002.600, 092906812.000, 0004.000, &
		092910245.000, 0004.000, 092917050.000, 0090.000, &
		093926444.000, 0021.000, 093915367.000, 0008.000, &
		093911596.000, 0006.000, 093906314.300, 0002.600, &
		093907280.400, 0002.600, 093905085.200, 0002.500, &
		093909654.000, 0005.000, 093911359.000, 0014.000, &
		093921700.000, 0480.000, 094929348.000, 0025.000, &
		094919430.000, 0050.000, 094912813.000, 0006.000, &
		094908041.400, 0002.600, 094906834.400, 0002.200, &
		094905840.700, 0002.100, 094907656.000, 0007.000, &
		094910413.000, 0013.000, 094915900.000, 0160.000, &
		095934350.000, 0030.000, 095921760.000, 0050.000, &
		095915950.000, 0050.000, 095908275.000, 0003.000, &
		095908099.000, 0004.000, 095904678.100, 0002.100, &
		095907870.000, 0006.000, 095907598.000, 0009.000, &
		095914519.000, 0014.000, 095918220.000, 0160.000, &
		096937420.000, 0040.000, 096926130.000, 0080.000, &
		096918120.000, 0070.000, 096910950.000, 0003.000, &
		096908096.500, 0002.900, 096906020.300, 0002.100, &
		096906364.000, 0005.000, 096907555.000, 0009.000, &
		096911340.000, 0040.000, 096916480.000, 0320.000, &
		097941930.000, 0060.000, 097928740.000, 0060.000, &
		097922150.000, 0170.000, 097912740.000, 0021.000, &
		097910330.000, 0006.000, 097905407.200, 0002.100, &
		097907215.000, 0004.000, 097905287.000, 0007.000, &
		097910716.000, 0013.000, 097912721.000, 0023.000, &
		098945400.000, 0120.000, 098933270.000, 0110.000, &
		098924670.000, 0080.000, 098916490.000, 0040.000, &
		098911618.000, 0014.000, 098907711.200, 0002.100, &
		098906254.300, 0002.200, 098905939.300, 0002.300, &
		098908192.000, 0010.000, 098911763.000, 0017.000, &
		098917590.000, 0160.000, 099935370.000, 0220.000, &
		099927760.000, 0160.000, 099917770.000, 0040.000, &
		099914194.000, 0030.000, 099907477.000, 0006.000, &
		099907657.300, 0002.400, 099904219.500, 0002.300, &
		099908116.000, 0022.000, 099908513.000, 0014.000, &
		099916080.000, 0100.000, 100921220.000, 0070.000, &
		100915240.000, 0040.000, 100910345.000, 0006.000, &
		100907314.000, 0026.000, 100905582.100, 0002.300, &
		100906162.000, 0019.000, 100908288.000, 0019.000, &
		100912840.000, 0130.000, 100918780.000, 0190.000, &
		101922950.000, 0070.000, 101918030.000, 0050.000, &
		101910297.000, 0022.000, 101909212.000, 0010.000, &
		101904348.700, 0002.400, 101906795.000, 0018.000, &
		101905617.000, 0009.000, 101911880.000, 0060.000, &
		102926690.000, 0140.000, 102919230.000, 0090.000, &
		102913310.000, 0080.000, 102909178.000, 0011.000, &
		102906322.900, 0002.400, 102905503.000, 0003.000, &
		102906097.000, 0009.000, 102908978.000, 0018.000, &
		102913420.000, 0017.000, 102919907.000, 0027.000, &
		103922430.000, 0130.000, 103913720.000, 0070.000, &
		103911440.000, 0050.000, 103905429.000, 0004.000, &
		103906654.000, 0003.000, 103904033.000, 0005.000, &
		103908627.000, 0007.000, 103909847.000, 0010.000, &
		104923850.000, 0120.000, 104916950.000, 0100.000, &
		104911600.000, 0060.000, 104907749.000, 0004.000, &
		104905691.000, 0005.000, 104905082.000, 0005.000, &
		104906519.000, 0010.000, 104909459.000, 0011.000, &
		104914661.000, 0017.000, 104921380.000, 0080.000, &
		105918130.000, 0100.000, 105914350.000, 0060.000, &
		105907326.000, 0008.000, 105907284.000, 0008.000, &
		105903482.000, 0005.000, 105906666.000, 0006.000, &
		105906457.000, 0006.000, 105913455.000, 0014.000, &
		105916850.000, 0070.000, 106910130.000, 0320.000, &
		106906750.000, 0020.000, 106905127.000, 0007.000, &
		106905092.000, 0006.000, 106906613.000, 0007.000, &
		106910287.000, 0014.000, 107910080.000, 0240.000, &
		107908670.000, 0220.000, 107903894.000, 0004.000, &
		107905953.000, 0006.000, 107904184.000, 0006.000, &
		107909700.000, 0030.000, 107911910.000, 0040.000, &
		108908727.000, 0022.000, 108905953.000, 0004.000, &
		108904755.000, 0004.000, 108904984.000, 0005.000, &
		108907153.000, 0007.000, 108911291.000, 0011.000, &
		108918140.000, 0020.000, 108927410.000, 0080.000, &
		109910960.000, 0240.000, 109905159.000, 0016.000, &
		109906110.000, 0004.000, 109903005.000, 0004.000, &
		109907230.000, 0220.000, 109907854.000, 0017.000, &
		109922380.000, 0070.000, 110907640.000, 0040.000, &
		110905295.000, 0004.000, 110904182.000, 0004.000, &
		110905109.000, 0006.000, 110907737.000, 0008.000, &
		110921120.000, 0080.000, 111907318.000, 0021.000, &
		111907006.000, 0018.000, 111902758.000, 0003.000, &
		111905534.000, 0005.000, 111904823.000, 0005.000, &
		111912396.000, 0025.000, 111917050.000, 0180.000, &
		112910170.000, 0160.000, 112906559.000, 0022.000, &
		112904402.000, 0003.000, 112904060.000, 0004.000, &
		112905175.000, 0005.000, 112909368.000, 0026.000, &
		112923650.000, 0060.000, 112933340.000, 0090.000, &
		113910400.000, 0030.000, 113908800.000, 0070.000, &
		113903358.000, 0003.000, 113904916.000, 0003.000, &
		113902781.000, 0003.000, 113909090.000, 0220.000, &
		114908800.000, 0080.000, 114905431.000, 0003.000, &
		114903876.000, 0005.000, 114903345.000, 0003.000, &
		114906598.000, 0022.000, 114911590.000, 0240.000, &
		115913960.000, 0160.000, 115911160.000, 0120.000, &
		115904756.000, 0004.000, 115905258.000, 0005.000, &
		115901743.000, 0003.000, 115906797.000, 0006.000, &
		115908440.000, 0100.000, 115916750.000, 0160.000, &
		115933130.000, 0310.000, 116911710.000, 0060.000, &
		116907230.000, 0014.000, 116904514.000, 0005.000, &
		116902953.000, 0003.000, 116904838.000, 0010.000, &
		116908631.000, 0021.000, 116928870.000, 0190.000, &
		117914570.000, 0110.000, 117906915.000, 0022.000, &
		117906353.000, 0009.000, 117901606.000, 0003.000, &
		117905531.000, 0004.000, 117905901.000, 0024.000, &
		117926710.000, 0140.000, 118915630.000, 0080.000, &
		118909890.000, 0060.000, 118905815.000, 0008.000, &
		118903309.000, 0003.000, 118903946.000, 0009.000, &
		118906407.000, 0009.000, 118910060.000, 0100.000, &
		118915460.000, 0150.000, 118922450.000, 0110.000, &
		119918650.000, 0110.000, 119909852.000, 0020.000, &
		119907890.000, 0180.000, 119902196.800, 0002.800, &
		119905074.000, 0008.000, 119904041.000, 0021.000, &
		119910069.000, 0026.000, 119912170.000, 0050.000, &
		119920760.000, 0080.000, 120919970.000, 0210.000, &
		120913100.000, 0160.000, 120907847.000, 0030.000, &
		120904236.500, 0002.700, 120903820.300, 0002.600, &
		120904938.000, 0028.000, 120907387.000, 0021.000, &
		120911430.000, 0060.000, 120917220.000, 0060.000, &
		121910280.000, 0050.000, 121903439.800, 0002.800, &
		121905177.900, 0002.600, 121903052.100, 0002.900, &
		121907597.000, 0006.000, 121908700.000, 0150.000, &
		121916110.000, 0070.000, 122910450.000, 0040.000, &
		122905721.600, 0002.800, 122904215.000, 0002.200, &
		122904271.400, 0002.000, 122905596.000, 0005.000, &
		122908472.000, 0017.000, 122912970.000, 0050.000, &
		123912980.000, 0050.000, 123905274.100, 0001.500, &
		123905936.900, 0002.200, 123902818.100, 0001.700, &
		123906207.000, 0005.000, 123905894.300, 0002.100, &
		123912250.000, 0040.000, 124913670.000, 0090.000, &
		124907785.000, 0002.100, 124905252.000, 0003.000, &
		124904428.700, 0002.400, 124904620.500, 0002.700, &
		124906396.800, 0002.200, 124909702.000, 0019.000, &
		124914600.000, 0270.000, 125916470.000, 0090.000, &
		125907653.000, 0011.000, 125907250.000, 0030.000, &
		125903309.700, 0002.400, 125905619.000, 0006.000, &
		125904269.000, 0008.000, 125909450.000, 0026.000, &
		126917320.000, 0080.000, 126910355.000, 0027.000, &
		126906919.000, 0007.000, 126905222.000, 0004.000, &
		126904475.000, 0005.000, 126905186.000, 0005.000, &
		126907415.000, 0013.000, 126911120.000, 0110.000, &
		127920540.000, 0180.000, 127910540.000, 0050.000, &
		127909170.000, 0040.000, 127904464.000, 0003.000, &
		127905812.000, 0005.000, 127903531.200, 0001.700, &
		127907753.000, 0006.000, 127908245.000, 0019.000, &
		127915380.000, 0430.000, 128921610.000, 0180.000, &
		128913450.000, 0130.000, 128909153.000, 0023.000, &
		128906596.000, 0004.000, 128904985.000, 0004.000, &
		128904779.500, 0002.000, 128906059.000, 0005.000, &
		128908664.000, 0012.000, 128912660.000, 0050.000, &
		129924840.000, 0210.000, 129913970.000, 0080.000, &
		129911620.000, 0080.000, 129906229.000, 0004.000, &
		129906712.000, 0011.000, 129903509.000, 0001.600, &
		129906761.000, 0008.000, 129906289.000, 0008.000, &
		130926480.000, 0150.000, 130916930.000, 0080.000, &
		130911950.000, 0080.000, 130908528.000, 0004.000, &
		130906112.000, 0004.000, 130905069.000, 0004.000, &
		130905447.000, 0007.000, 130906910.000, 0008.000, &
		130910090.000, 0110.000, 130914400.000, 0440.000, &
		131917750.000, 0090.000, 131914400.000, 0080.000, &
		131908511.000, 0013.000, 131907981.000, 0012.000, &
		131904141.000, 0004.000, 131906419.000, 0005.000, &
		131905049.000, 0008.000, 131910100.000, 0050.000, &
		132923570.000, 0240.000, 132915170.000, 0230.000, &
		132910930.000, 0080.000, 132907796.000, 0028.000, &
		132905895.000, 0006.000, 132905436.000, 0005.000, &
		132905990.000, 0005.000, 133920540.000, 0170.000, &
		133911500.000, 0120.000, 133909830.000, 0060.000, &
		133905395.000, 0008.000, 133906703.000, 0005.000, &
		133904493.000, 0005.000, 133908479.000, 0028.000, &
		133909020.000, 0220.000, 134916410.000, 0100.000, &
		134910016.000, 0025.000, 134907132.000, 0011.000, &
		134905892.000, 0007.000, 134905672.000, 0005.000, &
		134906960.000, 0012.000, 134909134.000, 0013.000, &
		134913130.000, 0160.000, 135920060.000, 0050.000, &
		135914600.000, 0040.000, 135907215.000, 0008.000, &
		135907296.000, 0005.000, 135904560.000, 0005.000, &
		135907640.000, 0080.000, 135907140.000, 0050.000, &
		135912650.000, 0050.000, 135915020.000, 0060.000, &
		136925410.000, 0320.000, 136917870.000, 0030.000, &
		136911559.000, 0008.000, 136907079.000, 0005.000, &
		136905817.000, 0005.000, 136906470.000, 0050.000, &
		136907780.000, 0050.000, 136910680.000, 0050.000, &
		136914440.000, 0080.000, 136920530.000, 0160.000, &
		137922390.000, 0090.000, 137913990.000, 0040.000, &
		137911008.000, 0024.000, 137905237.000, 0005.000, &
		137907106.000, 0005.000, 137905986.000, 0011.000, &
		137910749.000, 0016.000, 138926060.000, 0130.000, &
		138918740.000, 0060.000, 138913355.000, 0007.000, &
		138908831.000, 0005.000, 138906347.000, 0004.000, &
		138906632.000, 0014.000, 138908917.000, 0014.000, &
		138911910.000, 0040.000, 138916760.000, 0060.000, &
		138922620.000, 0130.000, 139921640.000, 0070.000, &
		139917281.000, 0018.000, 139910603.000, 0013.000, &
		139909472.000, 0004.000, 139905434.000, 0004.000, &
		139909071.000, 0007.000, 139909318.000, 0022.000, &
		139915850.000, 0040.000, 140926650.000, 0100.000, &
		140920052.000, 0018.000, 140914405.000, 0022.000, &
		140910914.000, 0026.000, 140908271.000, 0004.000, &
		140907648.000, 0004.000, 140909605.000, 0005.000, &
		140913610.000, 0030.000, 140918473.000, 0013.000, &
		140924870.000, 0040.000, 141929690.000, 0110.000, &
		141924275.000, 0021.000, 141916428.000, 0021.000, &
		141914089.000, 0008.000, 141909241.000, 0004.000, &
		141910040.000, 0004.000, 141907719.000, 0003.000, &
		141912950.000, 0050.000, 141915205.000, 0017.000, &
		141923150.000, 0110.000, 142927270.000, 0030.000, &
		142920581.000, 0030.000, 142916050.000, 0018.000, &
		142912382.000, 0004.000, 142910813.000, 0004.000, &
		142909810.000, 0003.000, 142910929.000, 0004.000, &
		142914626.000, 0005.000, 142920160.000, 0040.000, &
		143931970.000, 0040.000, 143922880.000, 0050.000, &
		143919550.000, 0070.000, 143913643.000, 0004.000, &
		143913301.000, 0004.000, 143910083.000, 0003.000, &
		143912588.000, 0004.000, 143911997.000, 0004.000, &
		143918792.000, 0023.000, 144935360.000, 0060.000, &
		144926870.000, 0080.000, 144921610.000, 0080.000, &
		144917220.000, 0040.000, 144914507.000, 0008.000, &
		144912570.000, 0003.000, 144912746.000, 0004.000, &
		144913408.000, 0004.000, 144916264.000, 0005.000, &
		144921690.000, 0040.000, 145940210.000, 0080.000, &
		145930160.000, 0080.000, 145925710.000, 0080.000, &
		145918700.000, 0070.000, 145917600.000, 0060.000, &
		145913113.000, 0003.000, 145914699.000, 0006.000, &
		145913044.000, 0005.000, 145917203.000, 0008.000, &
		145918305.000, 0012.000, 145927150.000, 0160.000, &
		146943850.000, 0120.000, 146933980.000, 0100.000, &
		146927810.000, 0090.000, 146922500.000, 0070.000, &
		146918980.000, 0040.000, 146916096.000, 0003.000, &
		146915135.000, 0003.000, 146914894.000, 0003.000, &
		146916742.000, 0004.000, 146919091.000, 0004.000, &
		146923910.000, 0060.000, 146930940.000, 0110.000, &
		147948920.000, 0390.000, 147931500.000, 0170.000, &
		147924400.000, 0130.000, 147922180.000, 0240.000, &
		147916889.000, 0004.000, 147917473.000, 0012.000, &
		147914819.000, 0003.000, 147918155.000, 0019.000, &
		147918113.000, 0004.000, 147924120.000, 0050.000, &
		147927000.000, 0060.000, 148928290.000, 0080.000, &
		148923792.000, 0011.000, 148920145.000, 0004.000, &
		148918332.000, 0005.000, 148917181.000, 0003.000, &
		148917923.000, 0006.000, 148919340.000, 0005.000, &
		148923243.000, 0006.000, 148941010.000, 0970.000, &
		149930230.000, 0130.000, 149927000.000, 0090.000, &
		149920888.000, 0004.000, 149920981.000, 0022.000, &
		149917273.000, 0003.000, 149919699.000, 0008.000, &
		149918657.000, 0008.000, 149923658.000, 0009.000, &
		149925578.000, 0012.000, 149933210.000, 0170.000, &
		150923826.000, 0004.000, 150921204.000, 0006.000, &
		150919928.000, 0003.000, 150919846.000, 0003.000, &
		150920345.000, 0004.000, 150923099.000, 0005.000, &
		150926179.000, 0005.000, 150931600.000, 0060.000, &
		151924680.000, 0030.000, 151923490.000, 0080.000, &
		151919729.000, 0003.000, 151921740.000, 0003.000, &
		151919788.000, 0003.000, 151924030.000, 0080.000, &
		151924717.000, 0006.000, 151931560.000, 0060.000, &
		151934900.000, 0060.000, 152924135.000, 0017.000, &
		152922095.000, 0003.000, 152921226.000, 0003.000, &
		152921746.000, 0003.000, 152923433.000, 0005.000, &
		152925763.000, 0005.000, 152930196.000, 0008.000, &
		153926560.000, 0120.000, 153922206.000, 0003.000, &
		153922976.000, 0003.000, 153920862.000, 0003.000, &
		153924690.000, 0050.000, 153924424.000, 0009.000, &
		153930599.000, 0010.000, 153932773.000, 0013.000, &
		153941280.000, 0170.000, 154924636.000, 0003.000, &
		154922889.000, 0003.000, 154922619.000, 0003.000, &
		154923499.000, 0013.000, 154925748.000, 0013.000, &
		154929078.000, 0025.000, 154933200.000, 0050.000, &
		154939100.000, 0070.000, 155925525.000, 0011.000, &
		155924749.000, 0007.000, 155922119.000, 0003.000, &
		155924743.000, 0005.000, 155924277.000, 0007.000, &
		155938830.000, 0070.000, 155942670.000, 0060.000, &
		156928210.000, 0210.000, 156925419.000, 0007.000, &
		156923957.000, 0003.000, 156924024.000, 0003.000, &
		156925460.000, 0007.000, 156928190.000, 0050.000, &
		156931910.000, 0100.000, 157927840.000, 0080.000, &
		157924100.000, 0003.000, 157925411.000, 0003.000, &
		157924403.000, 0004.000, 157928930.000, 0030.000, &
		157939859.000, 0017.000, 157949020.000, 0180.000, &
		158929085.000, 0009.000, 158926386.000, 0004.000, &
		158925344.000, 0003.000, 158925737.000, 0004.000, &
		158927710.000, 0005.000, 158930682.000, 0005.000, &
		158946570.000, 0080.000, 159927050.000, 0003.000, &
		159927165.000, 0003.000, 159925194.000, 0004.000, &
		159928727.000, 0012.000, 159929080.000, 0030.000, &
		159935090.000, 0320.000, 159950530.000, 0060.000, &
		160929666.000, 0004.000, 160927567.000, 0003.000, &
		160926931.000, 0003.000, 160927851.000, 0004.000, &
		160930002.000, 0010.000, 160933330.000, 0210.000, &
		161931040.000, 0120.000, 161929490.000, 0040.000, &
		161926796.000, 0003.000, 161929093.000, 0005.000, &
		161928776.000, 0004.000, 161933920.000, 0040.000, &
		161947205.000, 0018.000, 161956990.000, 0190.000, &
		162930540.000, 0050.000, 162928729.000, 0003.000, &
		162928732.000, 0003.000, 162930031.000, 0006.000, &
		162932649.000, 0007.000, 162936270.000, 0110.000, &
		162941210.000, 0240.000, 162954270.000, 0100.000, &
		163933350.000, 0110.000, 163929173.000, 0003.000, &
		163930231.000, 0004.000, 163929199.000, 0004.000, &
		163933452.000, 0022.000, 163958800.000, 0060.000, &
		164931701.000, 0003.000, 164930320.000, 0003.000, &
		164930724.000, 0004.000, 164932433.000, 0004.000, &
		164935400.000, 0022.000, 164939610.000, 0090.000, &
		165932804.000, 0003.000, 165932282.000, 0003.000, &
		165930292.000, 0003.000, 165933555.000, 0012.000, &
		165933882.000, 0009.000, 165939760.000, 0170.000, &
		165955021.000, 0019.000, 165965510.000, 0190.000, &
		166935650.000, 0060.000, 166933129.000, 0006.000, &
		166932047.000, 0003.000, 166932850.000, 0004.000, &
		166934948.000, 0006.000, 166938310.000, 0110.000, &
		166962520.000, 0110.000, 167935310.000, 0110.000, &
		167932370.000, 0003.000, 167934171.000, 0004.000, &
		167933897.000, 0005.000, 167938710.000, 0060.000, &
		167967650.000, 0060.000, 168936871.000, 0022.000, &
		168934590.000, 0003.000, 168934213.000, 0003.000, &
		168935189.000, 0005.000, 168937651.000, 0006.000, &
		168941160.000, 0090.000, 169939620.000, 0050.000, &
		169935463.000, 0004.000, 169935800.000, 0003.000, &
		169934761.000, 0003.000, 169938474.000, 0020.000, &
		169963572.000, 0019.000, 169974730.000, 0200.000, &
		170938028.000, 0004.000, 170936428.000, 0003.000, &
		170936325.000, 0003.000, 170937913.000, 0004.000, &
		170971640.000, 0120.000, 171939355.000, 0005.000, &
		171938399.000, 0007.000, 171936380.000, 0003.000, &
		171939086.000, 0004.000, 171939460.000, 0050.000, &
		171944740.000, 0200.000, 171977190.000, 0060.000, &
		172939597.000, 0006.000, 172938209.000, 0003.000, &
		172938931.000, 0004.000, 173942170.000, 0050.000, &
		173938861.000, 0003.000, 173940338.000, 0004.000, &
		173940042.000, 0004.000, 173972814.000, 0020.000, &
		173984620.000, 0200.000, 174943850.000, 0050.000, &
		174941275.000, 0003.000, 174940771.000, 0003.000, &
		174941505.000, 0004.000, 174981520.000, 0120.000, &
		175942565.000, 0003.000, 175942680.000, 0003.000, &
		175941404.000, 0003.000, 175944740.000, 0110.000, &
		175987230.000, 0060.000, 176945254.000, 0004.000, &
		176943753.000, 0003.000, 176943218.300, 0003.000, &
		176944470.000, 0004.000, 177946640.000, 0011.000, &
		177945960.000, 0026.000, 177943696.800, 0002.900, &
		177945750.000, 0110.000, 177945850.000, 0110.000, &
		177950850.000, 0220.000, 177982479.000, 0021.000, &
		178947270.000, 0040.000, 178945813.200, 0002.900, &
		178945931.000, 0006.000, 178947068.000, 0017.000, &
		178949960.000, 0060.000, 179949880.000, 0080.000, &
		179946546.600, 0002.900, 179947463.000, 0004.000, &
		179946703.000, 0005.000, 179950780.000, 0040.000, &
		180949097.000, 0003.000, 180947993.000, 0003.000, &
		180948195.000, 0006.000, 181950551.000, 0007.000, &
		181950150.000, 0003.000, 181948202.000, 0003.000, &
		181951210.000, 0110.000, 181952183.000, 0027.000, &
		181992621.000, 0030.000, 182953530.000, 0030.000, &
		182951370.000, 0003.000, 182950221.000, 0003.000, &
		182950818.000, 0009.000, 183955440.000, 0040.000, &
		183954006.000, 0028.000, 183950929.000, 0003.000, &
		183952528.000, 0006.000, 183952487.000, 0003.000, &
		183957550.000, 0270.000, 184955553.000, 0016.000, &
		184953417.000, 0003.000, 184952952.000, 0003.000, &
		184954039.000, 0003.000, 185958550.000, 0060.000, &
		185954358.000, 0003.000, 185954983.000, 0003.000, &
		185953835.000, 0003.000, 185957948.000, 0022.000, &
		185959430.000, 0030.000, 186957155.000, 0003.000, &
		186955747.000, 0003.000, 186955744.000, 0003.000, &
		187958483.000, 0005.000, 187958109.000, 0003.000, &
		187955832.000, 0003.000, 187958848.000, 0008.000, &
		187959391.000, 0006.000, 188961910.000, 0210.000, &
		188959222.000, 0010.000, 188958140.000, 0004.000, &
		188958710.000, 0014.000, 188960826.000, 0012.000, &
		189963170.000, 0170.000, 189961800.000, 0160.000, &
		189958439.000, 0004.000, 189960590.000, 0210.000, &
		189959924.000, 0007.000, 189964692.000, 0017.000, &
		190963114.000, 0012.000, 190960922.000, 0004.000, &
		190960585.000, 0004.000, 190961674.000, 0006.000, &
		190963640.000, 0050.000, 190967050.000, 0090.000, &
		191961469.000, 0004.000, 191962594.000, 0004.000, &
		191961028.000, 0005.000, 191964802.000, 0017.000, &
		192964138.000, 0004.000, 192962916.000, 0004.000, &
		192962977.000, 0004.000, 192970540.000, 0210.000, &
		193965172.000, 0005.000, 193965068.000, 0004.000, &
		193962655.000, 0004.000, 193965330.000, 0013.000, &
		193965373.000, 0025.000, 194968120.000, 0540.000, &
		194965969.000, 0004.000, 194964766.000, 0004.000, &
		194965009.000, 0004.000, 194966640.000, 0050.000, &
		194969650.000, 0160.000, 195969610.000, 0040.000, &
		195968370.000, 0040.000, 195964926.000, 0004.000, &
		195966542.000, 0005.000, 195965806.000, 0005.000, &
		195980710.000, 0750.000, 196969628.000, 0022.000, &
		196967315.000, 0004.000, 196966543.000, 0004.000, &
		196967187.000, 0005.000, 196969510.000, 0050.000, &
		196978910.000, 0180.000, 197967867.000, 0005.000, &
		197968217.000, 0004.000, 197966743.000, 0004.000, &
		197970460.000, 0090.000, 197979020.000, 0170.000, &
		198970551.000, 0021.000, 198968740.000, 0004.000, &
		198968254.000, 0004.000, 198969790.000, 0110.000, &
		198972870.000, 0080.000, 198977540.000, 0110.000, &
		199971415.000, 0022.000, 199970710.000, 0060.000, &
		199968300.000, 0004.000, 199970936.000, 0007.000, &
		199978100.000, 0080.000, 199990400.000, 0750.000, &
		200974500.000, 0060.000, 200971645.000, 0017.000, &
		200970276.000, 0004.000, 200970794.000, 0017.000, &
		200972840.000, 0030.000, 200976950.000, 0050.000, &
		200988470.000, 0180.000, 201973780.000, 0180.000, &
		201970617.000, 0004.000, 201972081.000, 0017.000, &
		201972134.000, 0011.000, 201977670.000, 0060.000, &
		201988440.000, 0170.000, 202975145.000, 0017.000, &
		202972848.000, 0005.000, 202972320.000, 0004.000, &
		202973366.000, 0008.000, 202976830.000, 0040.000, &
		202981380.000, 0080.000, 202986810.000, 0110.000, &
		203973467.000, 0004.000, 203973839.000, 0004.000, &
		203973020.000, 0004.000, 203977740.000, 0040.000, &
		203987220.000, 0080.000, 204000700.000, 0740.000, &
		204976047.000, 0007.000, 204974401.000, 0004.000, &
		204974458.000, 0004.000, 204977365.000, 0009.000, &
		204981150.000, 0030.000, 204986010.000, 0050.000, &
		204998640.000, 0180.000, 205977489.000, 0022.000, &
		205976084.000, 0004.000, 205974440.000, 0004.000, &
		205978474.000, 0009.000, 205980456.000, 0011.000, &
		205986590.000, 0060.000, 205998480.000, 0170.000, &
		206982530.000, 0160.000, 206977403.000, 0006.000, &
		206975871.000, 0004.000, 206978445.000, 0005.000, &
		206981569.000, 0008.000, 206985740.000, 0040.000, &
		206990690.000, 0080.000, 206996820.000, 0110.000, &
		207981992.000, 0004.000, 207976627.000, 0004.000, &
		207979717.000, 0005.000, 207981222.000, 0005.000, &
		207986520.000, 0040.000, 207997090.000, 0070.000, &
		208985344.000, 0010.000, 208981065.000, 0004.000, &
		208980373.000, 0004.000, 208982405.000, 0005.000, &
		208986149.000, 0009.000, 208990370.000, 0030.000, &
		208995890.000, 0050.000, 209009550.000, 0190.000, &
		209990057.000, 0013.000, 209984163.000, 0004.000, &
		209984095.000, 0004.000, 209982848.000, 0004.000, &
		209987123.000, 0009.000, 209989669.000, 0011.000, &
		209996350.000, 0060.000, 210009250.000, 0170.000, &
		210988734.000, 0003.000, 210987254.000, 0006.000, &
		210986627.000, 0004.000, 210987468.000, 0005.000, &
		210990574.000, 0008.000, 210995490.000, 0040.000, &
		211000860.000, 0080.000, 211007610.000, 0120.000, &
		211991872.000, 0005.000, 211991259.000, 0004.000, &
		211988842.000, 0004.000, 211990725.000, 0005.000, &
		211990680.000, 0005.000, 211996130.000, 0040.000, &
		212007770.000, 0090.000, 212994370.000, 0008.000, &
		212992833.000, 0005.000, 212992911.000, 0014.000, &
		212993857.000, 0008.000, 212996166.000, 0009.000, &
		213000330.000, 0030.000, 213006550.000, 0080.000, &
		213999798.101, 0002.903, 213998692.000, 0012.000, &
		213995176.000, 0004.000, 213996346.000, 0006.000, &
		213995337.000, 0010.000, 213998944.000, 0010.000, &
		214000080.000, 0012.000, 214006850.000, 0080.000, &
		215001830.000, 0100.000, 214999417.000, 0003.000, &
		214998637.000, 0008.000, 214998719.000, 0009.000, &
		215000313.000, 0009.000, 215002693.000, 0009.000, &
		215006410.000, 0070.000, 215011690.000, 0080.000, &
		215018980.000, 0130.000, 216001889.000, 0005.000, &
		216002395.000, 0005.000, 216000248.000, 0009.000, &
		216003178.000, 0014.000, 216003509.000, 0010.000, &
		216008660.000, 0050.000, 216018980.000, 0110.000, &
		217004705.000, 0008.000, 217003901.000, 0005.000, &
		217004609.000, 0016.000, 217006295.000, 0011.000, &
		217009324.000, 0014.000, 217013050.000, 0030.000, &
		217018270.000, 0090.000, 218008965.797, 0002.901, &
		218008685.000, 0014.000, 218005581.000, 0005.000, &
		218007553.000, 0006.000, 218007115.000, 0012.000, &
		218011610.000, 0050.000, 218013256.000, 0015.000, &
		218019960.000, 0090.000, 219011300.000, 0090.000, &
		219009477.000, 0003.000, 219009242.000, 0009.000, &
		219010051.000, 0013.000, 219012390.000, 0050.000, &
		219015510.000, 0050.000, 220011368.000, 0005.000, &
		220012298.000, 0006.000, 220011004.000, 0012.000, &
		220014740.000, 0060.000, 220015724.000, 0024.000, &
		221014241.000, 0008.000, 221013889.000, 0008.000, &
		221015570.000, 0060.000, 221018161.000, 0012.000, &
		222017570.555, 0002.884, 222017590.000, 0050.000, &
		222015354.000, 0006.000, 222017824.000, 0007.000, &
		222018445.000, 0014.000, 222023550.000, 0080.000, &
		223019732.000, 0004.000, 223018500.000, 0003.000, &
		223019128.000, 0009.000, 223020781.000, 0030.000, &
		223023950.000, 0080.000, 224023220.000, 0050.000, &
		224020186.000, 0005.000, 224021690.000, 0006.000, &
		224021449.000, 0014.000, 224025530.000, 0080.000, &
		225025600.000, 0090.000, 225023605.000, 0004.000, &
		225023216.000, 0008.000, 225023922.000, 0009.000, &
		225026100.000, 0070.000, 226029210.000, 0150.000, &
		226025402.699, 0002.872, 226026090.000, 0004.000, &
		226024888.000, 0006.000, 226027928.000, 0013.000, &
		226029170.000, 0040.000, 227031770.000, 0100.000, &
		227029170.777, 0002.887, 227027750.000, 0003.000, &
		227027701.000, 0003.000, 227028797.000, 0010.000, &
		228031064.000, 0004.000, 228031015.000, 0004.000, &
		228028716.000, 0005.000, 228030978.000, 0007.000, &
		228031356.000, 0017.000, 229035060.000, 0120.000, &
		229033170.000, 0110.000, 229031756.000, 0003.000, &
		229032084.000, 0010.000, 229033474.000, 0010.000, &
		229036230.000, 0090.000, 230033127.907, 0002.418, &
		230034533.000, 0004.000, 230033924.000, 0006.000, &
		230037810.000, 0060.000, 231038550.000, 0110.000, &
		231036298.540, 0002.430, 231035880.092, 0002.938, &
		231036260.000, 0050.000, 231038240.000, 0050.000, &
		232038050.805, 0002.266, 232038566.000, 0009.000, &
		232037131.000, 0005.000, 232041170.000, 0021.000, &
		233041577.412, 0002.281, 233040242.317, 0002.504, &
		233039629.000, 0003.000, 233042970.000, 0050.000, &
		234043594.000, 0004.000, 234043300.000, 0006.000, &
		234040946.682, 0002.301, 234042890.000, 0009.000, &
		234043301.000, 0008.000, 235047510.000, 0050.000, &
		235045440.000, 0050.000, 235043924.195, 0002.293, &
		235044057.024, 0002.472, 235045260.000, 0060.000, &
		236048680.000, 0210.000, 236045562.685, 0002.246, &
		236046560.000, 0050.000, 236046033.000, 0005.000, &
		237051140.000, 0110.000, 237048724.930, 0002.288, &
		237048167.724, 0002.263, 237048405.000, 0006.000, &
		238054650.000, 0320.000, 238050784.540, 0002.250, &
		238050940.966, 0002.273, 238049554.504, 0002.308, &
		238051980.000, 0050.000, 238053010.000, 0040.000, &
		239054289.560, 0002.260, 239052932.390, 0002.450, &
		239052157.477, 0002.294, 239053017.000, 0003.000, &
		240056587.000, 0005.000, 240056168.000, 0015.000, &
		240053808.302, 0002.249, 240055285.000, 0014.000, &
		240055504.000, 0005.000, 241058250.000, 0080.000, &
		241056845.838, 0002.253, 241056823.468, 0002.262, &
		241057648.000, 0007.000, 242061640.000, 0210.000, &
		242058737.263, 0002.263, 242059541.928, 0002.323, &
		242058830.507, 0002.311, 242063690.000, 0040.000, &
		243064328.000, 0012.000, 243061998.000, 0004.000, &
		243061373.546, 0002.492, 243061381.746, 0002.533, &
		243062998.000, 0005.000, 244064199.000, 0005.000, &
		244064280.281, 0002.433, 244062747.253, 0002.253, &
		244065170.000, 0060.000, 244065980.000, 0005.000, &
		245067821.000, 0015.000, 245066443.000, 0003.000, &
		245065483.502, 0002.318, 245066354.769, 0002.504, &
		245068041.000, 0007.000, 246070200.000, 0016.000, &
		246069769.000, 0020.000, 246067218.000, 0003.000, &
		246068800.132, 0002.548, 246075280.000, 0040.000, &
		247070347.000, 0005.000, 247070299.000, 0006.000, &
		247070993.000, 0009.000, 247073590.000, 0040.000, &
		248072344.000, 0005.000, 248073115.000, 0022.000, &
		248072181.000, 0004.000, 248075460.000, 0060.000, &
		248077174.000, 0015.000, 249075948.000, 0005.000, &
		249074978.719, 0002.841, 249074844.647, 0002.437, &
		249076340.000, 0050.000, 250078352.000, 0012.000, &
		250078315.000, 0006.000, 250076401.000, 0003.000, &
		250079506.000, 0022.000, 251082278.000, 0025.000, &
		251080754.000, 0012.000, 251079580.000, 0005.000, &
		251079985.000, 0007.000, 251081566.000, 0009.000, &
		252081621.000, 0005.000, 252082970.000, 0050.000, &
		252082463.000, 0005.000, 252088950.000, 0019.000, &
		253085128.000, 0008.000, 253084816.836, 0002.842, &
		253085173.000, 0005.000, 254087319.000, 0013.000, &
		254088023.000, 0007.000, 254086849.000, 0004.000, &
		254090940.000, 0026.000, 255090266.000, 0012.000, &
		255089949.000, 0005.000, 255091073.000, 0008.000, &
		255093234.000, 0013.000, 256091768.000, 0008.000, &
		256093990.000, 0060.000, 256094249.000, 0019.000, &
		256101160.000, 0030.000, 257095099.000, 0008.000, &
		257096850.000, 0030.000, 259100932.000, 0012.000, &
		259102890.000, 0050.000, 259105500.000, 0040.000, &
		260105350.000, 0080.000, 260114420.000, 0040.000, &
		263118190.000, 0070.000 /
	DOUBLE PRECISION, DIMENSION(0:1, 0:1658) :: Nucleus_BindingEnergy
	DATA Nucleus_BindingEnergy / &
		0000000.000, 0000.000, 0000000.000, 0000.000, &
		0002224.585, 0000.002, 0008481.876, 0000.006, &
		0007718.125, 0000.005, 0005660.000, 0380.000, &
		0028295.906, 0000.014, 0004810.000, 0300.000, &
		0027410.000, 0050.000, 0026330.000, 0050.000, &
		0029271.000, 0000.900, 0031995.600, 0000.700, &
		0026925.000, 0005.000, 0028830.000, 0030.000, &
		0039245.600, 0000.800, 0037601.400, 0000.800, &
		0024720.000, 0070.000, 0031408.000, 0007.000, &
		0041278.400, 0000.800, 0056499.930, 0000.060, &
		0037738.900, 0001.200, 0024783.000, 0024.000, &
		0030270.000, 0120.000, 0045341.300, 0002.000, &
		0058165.300, 0000.400, 0056314.800, 0001.100, &
		0039034.400, 0002.300, 0044530.000, 0250.000, &
		0064977.300, 0000.400, 0064751.060, 0000.280, &
		0060320.600, 0000.300, 0045540.000, 0110.000, &
		0065481.000, 0006.000, 0076205.200, 0000.300, &
		0073440.700, 0000.900, 0058420.000, 0140.000, &
		0068650.000, 0015.000, 0079575.300, 0001.300, &
		0092162.460, 0000.080, 0074042.100, 0001.000, &
		0058530.000, 0040.000, 0066800.000, 0500.000, &
		0084453.700, 0001.100, 0097108.800, 0000.090, &
		0094105.970, 0000.280, 0075557.000, 0010.000, &
		0069770.000, 0130.000, 0085424.000, 0021.000, &
		0105285.310, 0000.090, 0104659.430, 0000.090, &
		0098733.970, 0000.120, 0088189.000, 0022.000, &
		0106503.400, 0000.800, 0115492.750, 0000.090, &
		0111956.500, 0000.500, 0097260.000, 0130.000, &
		0110754.000, 0004.000, 0117983.600, 0002.300, &
		0127620.310, 0000.090, 0111421.000, 0008.000, &
		0097330.000, 0020.000, 0111484.000, 0017.000, &
		0123866.000, 0015.000, 0131763.740, 0000.270, &
		0128220.520, 0000.260, 0112910.000, 0050.000, &
		0115670.000, 0030.000, 0126691.000, 0020.000, &
		0139808.200, 0000.800, 0137370.300, 0000.600, &
		0132142.000, 0005.000, 0132009.000, 0019.000, &
		0143765.300, 0002.900, 0147802.490, 0000.110, &
		0143781.700, 0000.600, 0131822.000, 0012.000, &
		0151371.900, 0001.200, 0154403.790, 0000.180, &
		0160651.900, 0001.800, 0145983.000, 0007.000, &
		0134469.000, 0027.000, 0155174.000, 0015.000, &
		0162505.400, 0001.800, 0167412.800, 0001.700, &
		0163083.000, 0002.000, 0149197.000, 0016.000, &
		0161870.000, 0090.000, 0167700.000, 0030.000, &
		0177774.000, 0001.500, 0174149.700, 0001.600, &
		0168579.100, 0001.500, 0149310.000, 0070.000, &
		0175250.000, 0170.000, 0182974.300, 0002.500, &
		0186568.200, 0000.800, 0181727.300, 0001.400, &
		0168704.000, 0025.000, 0191840.000, 0010.000, &
		0193527.700, 0000.800, 0198258.400, 0000.700, &
		0183598.000, 0004.000, 0172006.000, 0019.000, &
		0196020.000, 0040.000, 0202538.900, 0001.400, &
		0205589.100, 0000.700, 0200529.800, 0000.900, &
		0187004.000, 0010.000, 0201590.000, 0070.000, &
		0208154.000, 0016.000, 0216681.800, 0000.700, &
		0211895.700, 0000.700, 0206048.000, 0003.000, &
		0214920.000, 0040.000, 0223125.300, 0000.800, &
		0224953.900, 0000.600, 0219359.700, 0000.600, &
		0206950.000, 0040.000, 0218530.000, 0140.000, &
		0231629.600, 0002.100, 0232679.100, 0000.600, &
		0236538.600, 0000.600, 0221424.000, 0004.000, &
		0209350.000, 0160.000, 0222810.000, 0150.000, &
		0235343.000, 0029.000, 0242115.300, 0001.400, &
		0245012.500, 0000.600, 0239286.700, 0000.900, &
		0224710.000, 0050.000, 0225330.000, 0250.000, &
		0241850.000, 0210.000, 0247860.000, 0040.000, &
		0255622.100, 0000.600, 0250607.000, 0000.700, &
		0243687.000, 0003.000, 0229780.000, 0580.000, &
		0255100.000, 0070.000, 0262210.500, 0000.600, &
		0262918.700, 0000.500, 0256740.500, 0001.500, &
		0243980.000, 0050.000, 0233130.000, 0740.000, &
		0250650.000, 1580.000, 0271412.300, 0001.000, &
		0270854.400, 0000.500, 0271782.920, 0000.290, &
		0258314.000, 0008.000, 0246380.000, 0050.000, &
		0236280.000, 1140.000, 0275895.000, 0016.000, &
		0280958.400, 0001.100, 0280424.560, 0000.280, &
		0274059.400, 0000.600, 0261650.000, 0030.000, &
		0239170.000, 3570.000, 0283432.000, 0015.000, &
		0287249.400, 0001.200, 0291841.680, 0000.270, &
		0285567.000, 0000.300, 0278723.000, 0003.000, &
		0285860.000, 0050.000, 0295621.000, 0001.900, &
		0298827.600, 0000.270, 0298212.080, 0000.250, &
		0291464.900, 0001.300, 0278801.000, 0020.000, &
		0262400.000, 0060.000, 0299086.000, 0013.000, &
		0308716.300, 0000.300, 0306791.820, 0000.250, &
		0306718.100, 0000.400, 0293130.000, 0008.000, &
		0281360.000, 0040.000, 0313019.900, 0000.300, &
		0317102.880, 0000.220, 0315507.500, 0000.500, &
		0308575.100, 0001.400, 0296153.000, 0022.000, &
		0321056.000, 0007.000, 0323210.740, 0000.250, &
		0327345.200, 0000.800, 0320649.800, 0001.000, &
		0313124.000, 0005.000, 0331286.700, 0002.500, &
		0333943.000, 0005.000, 0333725.500, 0001.000, &
		0326412.400, 0002.000, 0312650.000, 0050.000, &
		0332850.000, 0040.000, 0337080.000, 0040.000, &
		0343812.000, 0001.100, 0341525.100, 0001.000, &
		0342054.200, 0001.000, 0326952.000, 0004.000, &
		0314707.000, 0011.000, 0345020.000, 0150.000, &
		0349910.800, 0001.200, 0351620.300, 0001.000, &
		0350417.000, 0001.000, 0343140.200, 0001.500, &
		0329405.000, 0013.000, 0359340.000, 0040.000, &
		0359154.200, 0001.000, 0361897.900, 0001.100, &
		0354690.500, 0001.300, 0346907.000, 0006.000, &
		0356900.000, 0060.000, 0364960.000, 0070.000, &
		0368798.000, 0009.000, 0369830.900, 0001.100, &
		0366827.700, 0002.200, 0359178.000, 0007.000, &
		0373319.000, 0020.000, 0376090.000, 0040.000, &
		0380962.900, 0001.200, 0376527.300, 0002.100, &
		0375477.200, 0001.300, 0349810.000, 0030.000, &
		0378850.000, 0060.000, 0384961.000, 0010.000, &
		0388377.800, 0001.300, 0387852.200, 0001.300, &
		0385006.800, 0001.400, 0377093.000, 0017.000, &
		0363850.000, 0100.000, 0386920.000, 0040.000, &
		0391837.000, 0016.000, 0398777.200, 0002.600, &
		0396612.900, 0001.300, 0398197.200, 0001.300, &
		0390364.400, 0001.400, 0381979.000, 0020.000, &
		0391180.000, 0100.000, 0400186.000, 0008.000, &
		0406053.300, 0002.500, 0407255.900, 0002.100, &
		0407074.900, 0001.100, 0403364.700, 0001.300, &
		0395132.000, 0014.000, 0404684.000, 0024.000, &
		0415993.000, 0004.000, 0415489.000, 0005.000, &
		0418701.600, 0001.100, 0413906.900, 0002.600, &
		0411468.000, 0007.000, 0397078.000, 0021.000, &
		0385210.000, 0110.000, 0411400.000, 0300.000, &
		0421140.000, 0004.000, 0425626.000, 0004.000, &
		0426844.000, 0001.100, 0425459.800, 0001.400, &
		0422049.500, 0002.700, 0413549.000, 0024.000, &
		0399740.000, 0160.000, 0427492.000, 0009.000, &
		0431676.000, 0016.000, 0437783.200, 0001.100, &
		0434793.900, 0001.500, 0435049.900, 0001.500, &
		0426635.600, 0001.600, 0417700.000, 0060.000, &
		0431010.000, 0080.000, 0438429.000, 0020.000, &
		0444155.600, 0001.400, 0445845.300, 0001.500, &
		0444311.700, 0001.500, 0440320.500, 0001.500, &
		0431517.000, 0015.000, 0451964.000, 0007.000, &
		0453156.500, 0001.600, 0456349.700, 0001.600, &
		0450855.900, 0002.400, 0447702.000, 0010.000, &
		0432875.000, 0022.000, 0420450.000, 0070.000, &
		0457400.000, 0100.000, 0461635.000, 0003.000, &
		0464289.200, 0001.600, 0462911.200, 0001.600, &
		0458385.100, 0002.200, 0449299.000, 0018.000, &
		0435260.000, 0160.000, 0467749.000, 0015.000, &
		0474008.200, 0001.600, 0471848.800, 0001.800, &
		0471763.700, 0001.400, 0462738.900, 0001.500, &
		0453160.000, 0050.000, 0475080.000, 0100.000, &
		0480254.500, 0001.600, 0482075.400, 0001.500, &
		0481061.700, 0001.400, 0476828.000, 0001.500, &
		0467350.000, 0011.000, 0488511.000, 0010.000, &
		0489346.000, 0001.500, 0492259.900, 0001.500, &
		0486911.500, 0002.500, 0483993.000, 0011.000, &
		0467894.000, 0017.000, 0454660.000, 0080.000, &
		0497997.000, 0003.000, 0499906.100, 0001.500, &
		0498287.800, 0001.500, 0494240.200, 0003.000, &
		0484730.000, 0050.000, 0469300.000, 0120.000, &
		0504410.000, 0030.000, 0509950.800, 0001.500, &
		0506860.700, 0001.800, 0506459.200, 0001.500, &
		0497114.200, 0002.500, 0486870.000, 0100.000, &
		0512129.000, 0029.000, 0516531.700, 0001.500, &
		0517314.200, 0001.500, 0515459.200, 0001.500, &
		0509876.700, 0001.800, 0500000.000, 0040.000, &
		0517620.000, 0100.000, 0525348.000, 0004.000, &
		0524806.100, 0001.500, 0526847.800, 0001.500, &
		0519938.600, 0002.600, 0514997.000, 0011.000, &
		0530932.000, 0020.000, 0534127.800, 0001.700, &
		0534668.000, 0001.500, 0531648.100, 0001.900, &
		0525227.000, 0016.000, 0538981.000, 0015.000, &
		0540726.000, 0019.000, 0545265.300, 0001.500, &
		0540535.000, 0004.000, 0538125.000, 0010.000, &
		0528172.000, 0028.000, 0543350.000, 0060.000, &
		0549212.000, 0020.000, 0552103.900, 0001.500, &
		0551387.600, 0001.500, 0547238.400, 0002.200, &
		0540940.000, 0100.000, 0555236.000, 0020.000, &
		0561760.500, 0001.600, 0559303.700, 0001.500, &
		0559100.000, 0001.700, 0551153.000, 0004.000, &
		0545960.000, 0250.000, 0562680.000, 0050.000, &
		0567858.700, 0001.600, 0569213.600, 0001.800, &
		0567079.600, 0001.800, 0563041.700, 0002.000, &
		0556020.000, 0100.000, 0576834.000, 0016.000, &
		0576279.600, 0001.800, 0578139.400, 0001.600, &
		0572182.000, 0003.000, 0569300.000, 0030.000, &
		0558970.000, 0060.000, 0582620.000, 0019.000, &
		0585397.000, 0008.000, 0585191.600, 0001.600, &
		0583408.200, 0001.700, 0578404.000, 0005.000, &
		0571610.000, 0100.000, 0590431.000, 0017.000, &
		0591710.000, 0050.000, 0595389.800, 0001.700, &
		0591686.400, 0002.100, 0590797.000, 0006.000, &
		0581910.000, 0100.000, 0595480.000, 0150.000, &
		0599978.000, 0008.000, 0601872.000, 0001.700, &
		0601995.000, 0002.900, 0598987.000, 0004.000, &
		0594190.000, 0030.000, 0586620.000, 0030.000, &
		0605700.000, 0110.000, 0611087.000, 0003.000, &
		0609649.600, 0003.000, 0610523.100, 0001.600, &
		0603520.000, 0050.000, 0616920.000, 0011.000, &
		0618954.600, 0001.900, 0617939.000, 0001.900, &
		0615144.000, 0004.000, 0625800.000, 0006.000, &
		0625475.800, 0002.100, 0628687.800, 0001.500, &
		0623549.000, 0004.000, 0622437.000, 0012.000, &
		0631150.000, 0040.000, 0634663.000, 0006.000, &
		0635470.700, 0001.500, 0634348.000, 0004.000, &
		0630826.000, 0011.000, 0625430.000, 0230.000, &
		0617940.000, 0140.000, 0639519.000, 0019.000, &
		0641080.000, 0070.000, 0645670.500, 0001.500, &
		0642326.000, 0002.200, 0642897.500, 0001.500, &
		0635201.000, 0015.000, 0631250.000, 0060.000, &
		0620000.000, 0460.000, 0644420.000, 0090.000, &
		0649567.000, 0007.000, 0652176.400, 0001.800, &
		0652571.400, 0001.700, 0650925.100, 0001.500, &
		0647113.000, 0014.000, 0641403.000, 0020.000, &
		0633620.000, 0100.000, 0652250.000, 0170.000, &
		0655620.000, 0150.000, 0661604.400, 0001.600, &
		0659897.800, 0001.900, 0662079.400, 0001.500, &
		0656334.000, 0009.000, 0654225.000, 0012.000, &
		0645010.000, 0060.000, 0667677.000, 0001.900, &
		0669597.400, 0002.200, 0669498.200, 0001.500, &
		0667351.000, 0003.000, 0663526.000, 0017.000, &
		0657467.000, 0030.000, 0649650.000, 0150.000, &
		0676395.000, 0004.000, 0676569.000, 0010.000, &
		0679996.100, 0001.500, 0675640.000, 0004.000, &
		0675550.000, 0008.000, 0667600.000, 0030.000, &
		0676110.000, 0120.000, 0682090.000, 0090.000, &
		0685460.000, 0006.000, 0686959.100, 0001.700, &
		0686327.400, 0002.400, 0683919.000, 0004.000, &
		0679531.000, 0023.000, 0674130.000, 0360.000, &
		0680830.000, 0300.000, 0690050.000, 0030.000, &
		0692058.000, 0024.000, 0696872.900, 0001.800, &
		0694219.700, 0002.400, 0695440.000, 0006.000, &
		0688940.000, 0018.000, 0686170.000, 0030.000, &
		0687510.000, 0190.000, 0695050.000, 0120.000, &
		0700500.000, 0006.000, 0703574.000, 0001.900, &
		0704377.000, 0005.000, 0703314.000, 0005.000, &
		0700294.000, 0021.000, 0695520.000, 0040.000, &
		0689220.000, 0070.000, 0681280.000, 0300.000, &
		0702200.000, 0140.000, 0706113.000, 0025.000, &
		0712849.700, 0002.100, 0711970.000, 0005.000, &
		0714280.000, 0005.000, 0709109.000, 0017.000, &
		0708122.000, 0009.000, 0699520.000, 0100.000, &
		0694740.000, 0510.000, 0713990.000, 0220.000, &
		0718668.000, 0004.000, 0721553.000, 0004.000, &
		0721742.000, 0003.000, 0720027.000, 0021.000, &
		0716976.000, 0021.000, 0711780.000, 0060.000, &
		0704980.000, 0100.000, 0727348.000, 0015.000, &
		0728390.000, 0025.000, 0732261.000, 0003.000, &
		0728797.000, 0003.000, 0728908.000, 0004.000, &
		0721720.000, 0170.000, 0731880.000, 0100.000, &
		0737292.000, 0019.000, 0739380.000, 0003.000, &
		0739284.700, 0002.800, 0737437.000, 0004.000, &
		0733400.000, 0025.000, 0727930.000, 0100.000, &
		0738080.000, 0130.000, 0742400.000, 0060.000, &
		0749236.000, 0005.000, 0747935.900, 0002.800, &
		0748928.100, 0002.500, 0742906.000, 0014.000, &
		0748683.000, 0025.000, 0754751.000, 0005.000, &
		0757856.200, 0002.900, 0757356.300, 0002.500, &
		0754712.500, 0002.900, 0750265.000, 0008.000, &
		0744310.000, 0060.000, 0736790.000, 0310.000, &
		0753620.000, 0130.000, 0761805.000, 0014.000, &
		0763935.000, 0004.000, 0768468.900, 0002.500, &
		0764064.000, 0003.000, 0762614.000, 0010.000, &
		0766910.000, 0050.000, 0771115.000, 0007.000, &
		0774834.000, 0004.000, 0775544.200, 0002.600, &
		0771929.000, 0004.000, 0766860.000, 0040.000, &
		0760499.000, 0016.000, 0763690.000, 0120.000, &
		0773207.000, 0027.000, 0776827.000, 0013.000, &
		0782637.600, 0002.900, 0782401.400, 0002.600, &
		0783900.700, 0002.400, 0777007.000, 0005.000, &
		0773736.000, 0006.000, 0777700.000, 0080.000, &
		0783335.000, 0010.000, 0788418.000, 0009.000, &
		0790333.000, 0003.000, 0791095.200, 0002.400, &
		0789059.000, 0003.000, 0783845.000, 0012.000, &
		0776840.000, 0200.000, 0783050.000, 0080.000, &
		0788431.000, 0012.000, 0795761.000, 0013.000, &
		0796888.000, 0010.000, 0799730.400, 0002.300, &
		0796942.100, 0002.800, 0796517.000, 0004.000, &
		0787865.000, 0026.000, 0786630.000, 0120.000, &
		0794379.000, 0015.000, 0801069.000, 0016.000, &
		0804372.000, 0011.000, 0806464.500, 0002.400, &
		0805772.700, 0002.500, 0804584.000, 0004.000, &
		0800604.000, 0004.000, 0793480.000, 0090.000, &
		0798280.000, 0019.000, 0807816.000, 0007.000, &
		0810546.000, 0006.000, 0814684.000, 0002.500, &
		0813001.800, 0002.500, 0814264.300, 0002.400, &
		0809226.000, 0005.000, 0806855.000, 0013.000, &
		0796440.000, 0450.000, 0803647.000, 0024.000, &
		0812100.000, 0050.000, 0817484.000, 0006.000, &
		0821146.600, 0002.500, 0821488.600, 0002.100, &
		0821631.900, 0002.100, 0819158.000, 0006.000, &
		0815808.000, 0012.000, 0809920.000, 0150.000, &
		0807050.000, 0030.000, 0818000.000, 0040.000, &
		0822640.000, 0040.000, 0829000.000, 0003.000, &
		0828382.000, 0004.000, 0830786.200, 0002.100, &
		0827031.000, 0006.000, 0826502.000, 0008.000, &
		0819273.000, 0013.000, 0815040.000, 0150.000, &
		0812270.000, 0040.000, 0822000.000, 0070.000, &
		0828680.000, 0060.000, 0834580.000, 0003.000, &
		0836455.700, 0002.800, 0837607.400, 0002.000, &
		0836505.000, 0005.000, 0834613.000, 0008.000, &
		0830310.000, 0040.000, 0824740.000, 0300.000, &
		0816140.000, 0060.000, 0827640.000, 0060.000, &
		0833000.000, 0160.000, 0840984.000, 0020.000, &
		0842446.000, 0006.000, 0846249.900, 0002.100, &
		0843783.000, 0004.000, 0844797.000, 0006.000, &
		0838957.000, 0012.000, 0836308.000, 0022.000, &
		0820980.000, 0110.000, 0831490.000, 0100.000, &
		0838720.000, 0080.000, 0845560.000, 0040.000, &
		0849318.000, 0013.000, 0852175.100, 0002.100, &
		0852749.800, 0002.100, 0852260.900, 0002.200, &
		0849380.000, 0010.000, 0845272.000, 0016.000, &
		0839060.000, 0150.000, 0837610.000, 0210.000, &
		0843920.000, 0140.000, 0852440.000, 0040.000, &
		0854990.000, 0028.000, 0860465.000, 0006.000, &
		0859514.200, 0002.400, 0861934.200, 0002.200, &
		0857522.000, 0020.000, 0856370.000, 0013.000, &
		0848540.000, 0090.000, 0857300.000, 0070.000, &
		0862090.000, 0040.000, 0865864.000, 0006.000, &
		0867906.000, 0024.000, 0868736.300, 0002.200, &
		0867414.000, 0017.000, 0864651.000, 0018.000, &
		0859630.000, 0120.000, 0853320.000, 0180.000, &
		0863760.000, 0060.000, 0867560.000, 0050.000, &
		0873981.000, 0021.000, 0874209.000, 0010.000, &
		0877956.700, 0002.300, 0874896.000, 0017.000, &
		0875210.000, 0008.000, 0868590.000, 0050.000, &
		0868350.000, 0130.000, 0874520.000, 0090.000, &
		0879250.000, 0080.000, 0882312.000, 0010.000, &
		0884189.100, 0002.300, 0884171.000, 0003.000, &
		0882835.000, 0008.000, 0879369.000, 0017.000, &
		0874449.000, 0016.000, 0867624.000, 0025.000, &
		0879610.000, 0120.000, 0886930.000, 0060.000, &
		0888270.000, 0050.000, 0893093.000, 0004.000, &
		0891170.000, 0003.000, 0892829.000, 0005.000, &
		0887767.000, 0006.000, 0885848.000, 0010.000, &
		0886360.000, 0120.000, 0892000.000, 0090.000, &
		0896200.000, 0060.000, 0899003.000, 0004.000, &
		0900138.000, 0005.000, 0899923.000, 0005.000, &
		0897802.000, 0009.000, 0894281.000, 0010.000, &
		0888653.000, 0016.000, 0881620.000, 0080.000, &
		0898970.000, 0090.000, 0901710.000, 0060.000, &
		0907469.000, 0008.000, 0906726.000, 0008.000, &
		0909485.000, 0005.000, 0905737.000, 0005.000, &
		0905148.000, 0006.000, 0897848.000, 0013.000, &
		0893900.000, 0060.000, 0912930.000, 0300.000, &
		0915294.000, 0018.000, 0916023.000, 0006.000, &
		0915274.000, 0005.000, 0913075.000, 0007.000, &
		0908871.000, 0013.000, 0921040.000, 0230.000, &
		0921580.000, 0200.000, 0925243.000, 0004.000, &
		0922544.000, 0005.000, 0923409.000, 0006.000, &
		0917486.000, 0029.000, 0914640.000, 0040.000, &
		0929596.000, 0020.000, 0931397.000, 0004.000, &
		0931731.000, 0003.000, 0930735.000, 0004.000, &
		0927933.000, 0006.000, 0923296.000, 0010.000, &
		0916133.000, 0019.000, 0906720.000, 0070.000, &
		0935590.000, 0220.000, 0940208.000, 0015.000, &
		0938540.000, 0003.000, 0940650.000, 0003.000, &
		0935930.000, 0200.000, 0934568.000, 0016.000, &
		0919470.000, 0060.000, 0945960.000, 0040.000, &
		0947370.000, 0004.000, 0947625.000, 0003.000, &
		0945979.000, 0006.000, 0942749.000, 0007.000, &
		0928720.000, 0070.000, 0954340.000, 0019.000, &
		0953848.000, 0017.000, 0957023.000, 0003.000, &
		0953654.000, 0005.000, 0953535.000, 0004.000, &
		0945698.000, 0023.000, 0940580.000, 0170.000, &
		0959760.000, 0150.000, 0962335.000, 0020.000, &
		0963563.000, 0003.000, 0963099.000, 0003.000, &
		0961278.000, 0004.000, 0956590.000, 0024.000, &
		0941720.000, 0050.000, 0931910.000, 0090.000, &
		0967609.000, 0029.000, 0968320.000, 0070.000, &
		0972606.000, 0003.000, 0970373.000, 0003.000, &
		0971580.000, 0003.000, 0964920.000, 0200.000, &
		0976390.000, 0070.000, 0978747.000, 0003.000, &
		0979413.000, 0005.000, 0979125.000, 0003.000, &
		0975313.000, 0020.000, 0969880.000, 0230.000, &
		0980440.000, 0150.000, 0982270.000, 0110.000, &
		0987447.000, 0003.000, 0986197.000, 0005.000, &
		0988689.000, 0003.000, 0983199.000, 0006.000, &
		0980890.000, 0100.000, 0972360.000, 0140.000, &
		0955540.000, 0290.000, 0989830.000, 0050.000, &
		0993214.000, 0013.000, 0994961.000, 0005.000, &
		0995633.200, 0003.000, 0993095.000, 0009.000, &
		0988780.000, 0019.000, 0967580.000, 0180.000, &
		0995230.000, 0100.000, 1001579.000, 0020.000, &
		1001320.000, 0009.000, 1004959.600, 0003.000, &
		1000521.000, 0004.000, 0999394.000, 0023.000, &
		0977660.000, 0130.000, 1002310.000, 0070.000, &
		1006880.000, 0060.000, 1009892.000, 0008.000, &
		1011444.800, 0002.900, 1010069.000, 0008.000, &
		1006994.000, 0008.000, 1002810.000, 0100.000, &
		0997000.000, 0140.000, 0989700.000, 0100.000, &
		1007570.000, 0100.000, 1014986.000, 0019.000, &
		1016030.000, 0170.000, 1020551.900, 0002.700, &
		1017089.000, 0008.000, 1017270.000, 0019.000, &
		1010872.000, 0024.000, 1008130.000, 0050.000, &
		0999350.000, 0080.000, 1014420.000, 0190.000, &
		1020040.000, 0150.000, 1024143.000, 0028.000, &
		1026723.300, 0002.600, 1026328.700, 0002.500, &
		1024505.000, 0026.000, 1021442.000, 0020.000, &
		1016900.000, 0060.000, 1010720.000, 0060.000, &
		1029950.000, 0050.000, 1035536.800, 0002.700, &
		1033135.400, 0002.500, 1034333.300, 0002.800, &
		1029317.000, 0006.000, 1027510.000, 0140.000, &
		1019820.000, 0060.000, 1037860.000, 0030.000, &
		1041482.700, 0002.700, 1042103.700, 0002.200, &
		1041268.800, 0002.000, 1039252.000, 0005.000, &
		1035791.000, 0016.000, 1030820.000, 0040.000, &
		1043570.000, 0050.000, 1049970.900, 0001.600, &
		1048571.100, 0002.200, 1050694.000, 0001.700, &
		1046755.000, 0004.000, 1046263.700, 0002.100, &
		1039560.000, 0040.000, 1051010.000, 0080.000, &
		1055703.400, 0002.100, 1057281.000, 0003.000, &
		1057265.100, 0002.400, 1056304.000, 0002.600, &
		1053867.000, 0002.200, 1050006.000, 0017.000, &
		1044660.000, 0250.000, 1056470.000, 0080.000, &
		1063897.000, 0011.000, 1063490.000, 0030.000, &
		1066378.800, 0002.400, 1063445.000, 0005.000, &
		1063921.000, 0007.000, 1058312.000, 0024.000, &
		1063740.000, 0070.000, 1069452.000, 0025.000, &
		1071870.000, 0006.000, 1072669.000, 0004.000, &
		1072583.000, 0004.000, 1071137.000, 0005.000, &
		1068279.000, 0012.000, 1064050.000, 0100.000, &
		1068820.000, 0170.000, 1077350.000, 0050.000, &
		1077850.000, 0040.000, 1081447.000, 0003.000, &
		1079408.000, 0004.000, 1080750.500, 0001.800, &
		1076036.000, 0006.000, 1074795.000, 0018.000, &
		1067360.000, 0400.000, 1075900.000, 0170.000, &
		1082710.000, 0120.000, 1085932.000, 0022.000, &
		1087532.000, 0004.000, 1088250.000, 0004.000, &
		1087659.100, 0002.000, 1085685.000, 0005.000, &
		1082476.000, 0011.000, 1077970.000, 0050.000, &
		1080960.000, 0200.000, 1090300.000, 0080.000, &
		1091710.000, 0070.000, 1095945.000, 0004.000, &
		1094712.000, 0010.000, 1096914.000, 0001.800, &
		1093103.000, 0008.000, 1092759.000, 0007.000, &
		1087500.000, 0140.000, 1095610.000, 0070.000, &
		1099470.000, 0070.000, 1101875.000, 0004.000, &
		1103343.000, 0004.000, 1103532.000, 0004.000, &
		1102398.000, 0006.000, 1100253.000, 0007.000, &
		1096510.000, 0100.000, 1091710.000, 0410.000, &
		1102920.000, 0080.000, 1105250.000, 0080.000, &
		1109962.000, 0012.000, 1109673.000, 0011.000, &
		1112468.000, 0004.000, 1109564.000, 0005.000, &
		1110058.000, 0008.000, 1104570.000, 0050.000, &
		1105570.000, 0220.000, 1112610.000, 0210.000, &
		1115780.000, 0080.000, 1117917.000, 0026.000, &
		1118906.000, 0005.000, 1118551.000, 0005.000, &
		1117252.000, 0005.000, 1115680.000, 0160.000, &
		1123320.000, 0110.000, 1124100.000, 0060.000, &
		1127443.000, 0008.000, 1125442.000, 0005.000, &
		1126718.000, 0005.000, 1122223.000, 0026.000, &
		1120940.000, 0200.000, 1126820.000, 0090.000, &
		1131992.000, 0023.000, 1133896.000, 0011.000, &
		1134269.000, 0007.000, 1133692.000, 0005.000, &
		1131709.000, 0011.000, 1128901.000, 0012.000, &
		1124400.000, 0150.000, 1131490.000, 0050.000, &
		1135790.000, 0040.000, 1141890.000, 0007.000, &
		1141032.000, 0005.000, 1142799.000, 0005.000, &
		1139150.000, 0070.000, 1138830.000, 0050.000, &
		1132920.000, 0050.000, 1129930.000, 0060.000, &
		1134570.000, 0300.000, 1140821.000, 0029.000, &
		1145915.000, 0007.000, 1149306.000, 0005.000, &
		1149699.000, 0005.000, 1148310.000, 0050.000, &
		1146310.000, 0050.000, 1142820.000, 0050.000, &
		1138540.000, 0070.000, 1132080.000, 0150.000, &
		1144680.000, 0080.000, 1151720.000, 0040.000, &
		1153717.000, 0022.000, 1158311.000, 0005.000, &
		1155787.000, 0005.000, 1156049.000, 0011.000, &
		1150829.000, 0015.000, 1149330.000, 0120.000, &
		1155360.000, 0060.000, 1159603.000, 0007.000, &
		1163034.000, 0005.000, 1164565.000, 0004.000, &
		1163518.000, 0013.000, 1160607.000, 0013.000, &
		1157040.000, 0040.000, 1151730.000, 0050.000, &
		1145490.000, 0120.000, 1160740.000, 0060.000, &
		1164017.000, 0016.000, 1169455.000, 0012.000, &
		1169726.000, 0004.000, 1172705.000, 0004.000, &
		1168535.000, 0007.000, 1167523.000, 0020.000, &
		1160650.000, 0040.000, 1164140.000, 0090.000, &
		1169507.000, 0016.000, 1173985.000, 0021.000, &
		1176454.000, 0025.000, 1178134.000, 0004.000, &
		1177932.000, 0004.000, 1175326.000, 0005.000, &
		1170814.000, 0029.000, 1165501.000, 0013.000, &
		1158760.000, 0040.000, 1169390.000, 0100.000, &
		1173645.000, 0020.000, 1180171.000, 0020.000, &
		1181568.000, 0007.000, 1185302.000, 0004.000, &
		1183775.000, 0004.000, 1185155.000, 0003.000, &
		1179500.000, 0040.000, 1176617.000, 0015.000, &
		1168430.000, 0100.000, 1178923.000, 0028.000, &
		1184375.000, 0028.000, 1187813.000, 0017.000, &
		1190447.000, 0004.000, 1191126.000, 0004.000, &
		1191278.000, 0003.000, 1189453.000, 0004.000, &
		1185228.000, 0005.000, 1179290.000, 0030.000, &
		1182620.000, 0040.000, 1190310.000, 0050.000, &
		1192620.000, 0060.000, 1197344.000, 0004.000, &
		1196880.000, 0004.000, 1199095.000, 0003.000, &
		1195980.000, 0004.000, 1195748.000, 0004.000, &
		1188636.000, 0022.000, 1187530.000, 0050.000, &
		1194660.000, 0070.000, 1198780.000, 0070.000, &
		1202080.000, 0040.000, 1203828.000, 0008.000, &
		1204851.000, 0003.000, 1203904.000, 0004.000, &
		1202505.000, 0004.000, 1199062.000, 0005.000, &
		1193230.000, 0040.000, 1191090.000, 0080.000, &
		1199670.000, 0080.000, 1203030.000, 0070.000, &
		1208770.000, 0070.000, 1209020.000, 0060.000, &
		1212416.000, 0003.000, 1210156.000, 0006.000, &
		1210915.000, 0005.000, 1206259.000, 0008.000, &
		1204450.000, 0012.000, 1195430.000, 0150.000, &
		1195760.000, 0110.000, 1204180.000, 0100.000, &
		1209150.000, 0080.000, 1213310.000, 0060.000, &
		1215810.000, 0040.000, 1217708.000, 0003.000, &
		1217822.000, 0003.000, 1217263.000, 0003.000, &
		1214759.000, 0004.000, 1211789.000, 0004.000, &
		1206520.000, 0060.000, 1199190.000, 0110.000, &
		1199120.000, 0360.000, 1213780.000, 0150.000, &
		1219610.000, 0120.000, 1220890.000, 0220.000, &
		1225041.000, 0004.000, 1223715.000, 0011.000, &
		1225405.000, 0003.000, 1221515.000, 0018.000, &
		1220772.000, 0004.000, 1214390.000, 0050.000, &
		1210930.000, 0060.000, 1224060.000, 0080.000, &
		1227465.000, 0011.000, 1230080.000, 0004.000, &
		1230986.000, 0005.000, 1231276.000, 0003.000, &
		1229803.000, 0006.000, 1227700.000, 0005.000, &
		1223282.000, 0005.000, 1204390.000, 0900.000, &
		1230320.000, 0120.000, 1232550.000, 0080.000, &
		1237459.000, 0004.000, 1236590.000, 0020.000, &
		1239262.000, 0003.000, 1236219.000, 0007.000, &
		1236407.000, 0007.000, 1230967.000, 0009.000, &
		1228396.000, 0012.000, 1220500.000, 0160.000, &
		1242794.000, 0004.000, 1244453.000, 0006.000, &
		1244860.000, 0003.000, 1244154.000, 0003.000, &
		1242907.000, 0004.000, 1239559.000, 0005.000, &
		1235907.000, 0005.000, 1230080.000, 0060.000, &
		1250070.000, 0030.000, 1250390.000, 0070.000, &
		1253117.000, 0003.000, 1250461.000, 0003.000, &
		1251497.000, 0003.000, 1246760.000, 0070.000, &
		1245341.000, 0006.000, 1238180.000, 0060.000, &
		1234290.000, 0060.000, 1257866.000, 0016.000, &
		1258984.000, 0003.000, 1259011.000, 0003.000, &
		1257744.000, 0003.000, 1255391.000, 0005.000, &
		1252438.000, 0005.000, 1247526.000, 0007.000, &
		1263680.000, 0110.000, 1266952.000, 0003.000, &
		1265453.000, 0003.000, 1266639.000, 0003.000, &
		1262290.000, 0050.000, 1261757.000, 0009.000, &
		1255222.000, 0009.000, 1252414.000, 0012.000, &
		1243710.000, 0160.000, 1272759.000, 0003.000, &
		1273605.000, 0003.000, 1273074.000, 0003.000, &
		1271472.000, 0012.000, 1268595.000, 0012.000, &
		1264711.000, 0023.000, 1260090.000, 0050.000, &
		1253810.000, 0060.000, 1280003.000, 0010.000, &
		1279943.000, 0007.000, 1281611.000, 0003.000, &
		1278384.000, 0005.000, 1278036.000, 0007.000, &
		1262130.000, 0070.000, 1257780.000, 0060.000, &
		1285570.000, 0200.000, 1287391.000, 0006.000, &
		1287971.000, 0003.000, 1287126.000, 0003.000, &
		1285006.000, 0007.000, 1281680.000, 0050.000, &
		1277430.000, 0090.000, 1293210.000, 0080.000, &
		1295908.000, 0003.000, 1293905.000, 0003.000, &
		1294061.000, 0004.000, 1289060.000, 0030.000, &
		1276535.000, 0016.000, 1267220.000, 0170.000, &
		1300119.000, 0009.000, 1301851.000, 0003.000, &
		1302039.000, 0003.000, 1300890.000, 0004.000, &
		1298270.000, 0004.000, 1294720.000, 0005.000, &
		1277570.000, 0080.000, 1309303.000, 0003.000, &
		1308414.000, 0003.000, 1309468.000, 0004.000, &
		1305394.000, 0011.000, 1304284.000, 0028.000, &
		1297900.000, 0300.000, 1281170.000, 0060.000, &
		1314938.000, 0004.000, 1316111.000, 0003.000, &
		1315921.000, 0003.000, 1314282.000, 0004.000, &
		1311496.000, 0010.000, 1307610.000, 0200.000, &
		1321730.000, 0110.000, 1322390.000, 0040.000, &
		1324118.000, 0003.000, 1321196.000, 0005.000, &
		1320709.000, 0004.000, 1315130.000, 0040.000, &
		1300413.000, 0017.000, 1290510.000, 0170.000, &
		1329480.000, 0040.000, 1330389.000, 0003.000, &
		1329604.000, 0003.000, 1327612.000, 0006.000, &
		1324390.000, 0006.000, 1320240.000, 0100.000, &
		1314860.000, 0220.000, 1301120.000, 0090.000, &
		1334940.000, 0100.000, 1338047.000, 0003.000, &
		1336279.000, 0004.000, 1336458.000, 0004.000, &
		1331714.000, 0020.000, 1304190.000, 0060.000, &
		1343763.000, 0003.000, 1344267.000, 0003.000, &
		1343108.000, 0004.000, 1340734.000, 0004.000, &
		1337189.000, 0020.000, 1332490.000, 0080.000, &
		1350807.000, 0003.000, 1350511.000, 0003.000, &
		1351582.000, 0003.000, 1347761.000, 0012.000, &
		1346674.000, 0008.000, 1340410.000, 0160.000, &
		1323853.000, 0018.000, 1313300.000, 0180.000, &
		1356230.000, 0060.000, 1357794.000, 0006.000, &
		1358019.000, 0003.000, 1356489.000, 0004.000, &
		1353752.000, 0005.000, 1349840.000, 0100.000, &
		1324160.000, 0100.000, 1363830.000, 0100.000, &
		1365790.000, 0003.000, 1363329.000, 0004.000, &
		1362803.000, 0005.000, 1357530.000, 0060.000, &
		1326670.000, 0060.000, 1370451.000, 0020.000, &
		1371793.000, 0003.000, 1371361.000, 0003.000, &
		1369670.000, 0005.000, 1366594.000, 0005.000, &
		1362540.000, 0080.000, 1375960.000, 0050.000, &
		1379051.000, 0004.000, 1377955.000, 0003.000, &
		1378140.000, 0003.000, 1373899.000, 0019.000, &
		1346609.000, 0018.000, 1335430.000, 0190.000, &
		1384733.000, 0004.000, 1385441.000, 0003.000, &
		1384755.000, 0003.000, 1382493.000, 0004.000, &
		1346380.000, 0110.000, 1391569.000, 0005.000, &
		1391677.000, 0006.000, 1392775.000, 0003.000, &
		1389472.000, 0004.000, 1388340.000, 0050.000, &
		1382640.000, 0190.000, 1348500.000, 0060.000, &
		1398632.000, 0006.000, 1399142.000, 0003.000, &
		1397688.000, 0004.000, 1404310.000, 0040.000, &
		1406607.000, 0003.000, 1404449.000, 0004.000, &
		1403941.000, 0004.000, 1368721.000, 0019.000, &
		1356940.000, 0190.000, 1410810.000, 0050.000, &
		1412429.000, 0003.000, 1412117.000, 0003.000, &
		1410650.000, 0004.000, 1367900.000, 0110.000, &
		1419299.000, 0003.000, 1418410.000, 0003.000, &
		1418816.000, 0003.000, 1414920.000, 0100.000, &
		1369870.000, 0060.000, 1424866.000, 0004.000, &
		1425482.000, 0003.000, 1425197.000, 0003.000, &
		1423249.000, 0004.000, 1431646.000, 0011.000, &
		1431497.000, 0024.000, 1432823.000, 0003.000, &
		1430130.000, 0100.000, 1429250.000, 0100.000, &
		1423810.000, 0210.000, 1390439.000, 0019.000, &
		1438350.000, 0040.000, 1438922.900, 0002.900, &
		1438031.000, 0006.000, 1436189.000, 0016.000, &
		1432720.000, 0050.000, 1443990.000, 0070.000, &
		1446311.100, 0003.000, 1444675.000, 0004.000, &
		1444601.000, 0005.000, 1440020.000, 0030.000, &
		1452007.000, 0003.000, 1452253.000, 0003.000, &
		1451282.000, 0006.000, 1458724.000, 0007.000, &
		1458315.000, 0003.000, 1459347.000, 0003.000, &
		1455760.000, 0100.000, 1454074.000, 0025.000, &
		1411712.000, 0028.000, 1464020.000, 0030.000, &
		1465250.000, 0003.000, 1465538.000, 0003.000, &
		1464199.000, 0009.000, 1470310.000, 0040.000, &
		1470866.000, 0026.000, 1472949.000, 0003.000, &
		1470678.000, 0006.000, 1469934.000, 0003.000, &
		1464430.000, 0250.000, 1477496.000, 0015.000, &
		1478704.000, 0003.000, 1478355.000, 0003.000, &
		1476559.000, 0003.000, 1482780.000, 0060.000, &
		1485898.000, 0003.000, 1484534.000, 0003.000, &
		1484821.000, 0003.000, 1480208.000, 0020.000, &
		1478050.000, 0030.000, 1491364.000, 0003.000, &
		1491894.000, 0003.000, 1491114.000, 0003.000, &
		1498198.000, 0005.000, 1497765.000, 0003.000, &
		1499103.000, 0003.000, 1495512.000, 0008.000, &
		1494223.000, 0006.000, 1503080.000, 0200.000, &
		1504799.000, 0010.000, 1505025.000, 0004.000, &
		1503711.000, 0013.000, 1500958.000, 0012.000, &
		1509980.000, 0160.000, 1510470.000, 0150.000, &
		1512818.000, 0004.000, 1510040.000, 0200.000, &
		1509870.000, 0006.000, 1504646.000, 0016.000, &
		1517317.000, 0011.000, 1518576.000, 0004.000, &
		1518108.000, 0004.000, 1516311.000, 0006.000, &
		1513700.000, 0050.000, 1509740.000, 0090.000, &
		1526138.000, 0004.000, 1524307.000, 0004.000, &
		1524985.000, 0004.000, 1520686.000, 0016.000, &
		1531723.000, 0004.000, 1532079.000, 0004.000, &
		1531240.000, 0004.000, 1521850.000, 0200.000, &
		1538831.000, 0005.000, 1538146.000, 0004.000, &
		1539612.000, 0004.000, 1536337.000, 0012.000, &
		1535515.000, 0023.000, 1544160.000, 0500.000, &
		1545378.000, 0004.000, 1545717.000, 0004.000, &
		1544708.000, 0004.000, 1542410.000, 0050.000, &
		1538820.000, 0140.000, 1550840.000, 0040.000, &
		1551210.000, 0040.000, 1553639.000, 0004.000, &
		1551351.000, 0005.000, 1551254.000, 0005.000, &
		1535020.000, 0700.000, 1558112.000, 0021.000, &
		1559485.000, 0004.000, 1559422.000, 0004.000, &
		1558040.000, 0005.000, 1555090.000, 0050.000, &
		1544770.000, 0170.000, 1567042.000, 0005.000, &
		1565934.000, 0004.000, 1566524.000, 0004.000, &
		1562280.000, 0080.000, 1552740.000, 0150.000, &
		1572613.000, 0019.000, 1573518.000, 0004.000, &
		1573188.000, 0004.000, 1570980.000, 0100.000, &
		1567320.000, 0070.000, 1562190.000, 0100.000, &
		1579879.000, 0021.000, 1579760.000, 0050.000, &
		1581217.000, 0004.000, 1577978.000, 0007.000, &
		1569740.000, 0080.000, 1556720.000, 0690.000, &
		1585080.000, 0050.000, 1586954.000, 0016.000, &
		1587447.000, 0004.000, 1586182.000, 0016.000, &
		1583500.000, 0030.000, 1578890.000, 0050.000, &
		1566590.000, 0170.000, 1593040.000, 0170.000, &
		1595201.000, 0004.000, 1593055.000, 0016.000, &
		1592223.000, 0010.000, 1586280.000, 0060.000, &
		1574690.000, 0150.000, 1599837.000, 0016.000, &
		1601194.000, 0004.000, 1600904.000, 0004.000, &
		1599147.000, 0008.000, 1595140.000, 0040.000, &
		1590120.000, 0070.000, 1584280.000, 0100.000, &
		1608689.000, 0004.000, 1607560.000, 0004.000, &
		1607541.000, 0004.000, 1602360.000, 0040.000, &
		1591960.000, 0070.000, 1577850.000, 0690.000, &
		1614357.000, 0007.000, 1615108.000, 0004.000, &
		1614273.000, 0004.000, 1610782.000, 0008.000, &
		1606470.000, 0030.000, 1601160.000, 0050.000, &
		1587830.000, 0170.000, 1621085.000, 0020.000, &
		1621612.000, 0004.000, 1622361.000, 0004.000, &
		1617821.000, 0009.000, 1615192.000, 0010.000, &
		1608700.000, 0060.000, 1596060.000, 0150.000, &
		1624460.000, 0150.000, 1628454.000, 0006.000, &
		1629099.000, 0004.000, 1625919.000, 0005.000, &
		1622227.000, 0008.000, 1617560.000, 0040.000, &
		1612160.000, 0070.000, 1605680.000, 0100.000, &
		1632251.000, 0004.000, 1636467.000, 0004.000, &
		1632806.000, 0005.000, 1630621.000, 0005.000, &
		1624900.000, 0040.000, 1613490.000, 0070.000, &
		1637200.000, 0010.000, 1640404.000, 0004.000, &
		1640266.000, 0004.000, 1637591.000, 0005.000, &
		1633320.000, 0008.000, 1628609.000, 0030.000, &
		1622680.000, 0050.000, 1608400.000, 0170.000, &
		1640881.000, 0012.000, 1645589.000, 0004.000, &
		1644870.000, 0004.000, 1645249.000, 0004.000, &
		1640485.000, 0009.000, 1637331.000, 0011.000, &
		1630320.000, 0050.000, 1616750.000, 0160.000, &
		1649403.000, 0003.000, 1649999.000, 0006.000, &
		1649801.000, 0004.000, 1648235.000, 0005.000, &
		1644559.000, 0008.000, 1639200.000, 0040.000, &
		1633410.000, 0070.000, 1626350.000, 0110.000, &
		1654551.000, 0005.000, 1654339.000, 0004.000, &
		1655809.000, 0004.000, 1653273.000, 0005.000, &
		1652532.000, 0005.000, 1646670.000, 0040.000, &
		1634260.000, 0080.000, 1659513.000, 0008.000, &
		1660162.000, 0005.000, 1659307.000, 0013.000, &
		1657644.000, 0008.000, 1654711.000, 0009.000, &
		1650046.000, 0030.000, 1643470.000, 0070.000, &
		1663311.000, 0003.000, 1663559.000, 0012.000, &
		1666051.000, 0004.000, 1664179.000, 0006.000, &
		1664337.000, 0010.000, 1660194.000, 0010.000, &
		1658354.000, 0011.000, 1651270.000, 0070.000, &
		1668700.000, 0090.000, 1670172.000, 0003.000, &
		1670116.000, 0007.000, 1669258.000, 0009.000, &
		1666990.000, 0008.000, 1663991.000, 0009.000, &
		1659740.000, 0060.000, 1654040.000, 0070.000, &
		1646480.000, 0120.000, 1675941.000, 0005.000, &
		1674688.000, 0005.000, 1675905.000, 0008.000, &
		1672393.000, 0013.000, 1671303.000, 0010.000, &
		1665720.000, 0040.000, 1654550.000, 0100.000, &
		1680607.000, 0008.000, 1680573.000, 0005.000, &
		1679132.000, 0015.000, 1676779.000, 0010.000, &
		1673175.000, 0013.000, 1668920.000, 0030.000, &
		1663280.000, 0090.000, 1685492.000, 0003.000, &
		1684971.000, 0013.000, 1687080.000, 0005.000, &
		1684460.000, 0006.000, 1684087.000, 0012.000, &
		1679110.000, 0050.000, 1676801.000, 0014.000, &
		1669770.000, 0090.000, 1690610.000, 0080.000, &
		1691522.000, 0003.000, 1690959.000, 0008.000, &
		1689423.000, 0012.000, 1686460.000, 0050.000, &
		1682770.000, 0050.000, 1697832.000, 0005.000, &
		1696183.000, 0006.000, 1696606.000, 0011.000, &
		1692340.000, 0050.000, 1690645.000, 0022.000, &
		1702445.000, 0008.000, 1701990.000, 0007.000, &
		1699640.000, 0050.000, 1696447.000, 0011.000, &
		1708197.000, 0003.000, 1707400.000, 0040.000, &
		1708697.000, 0006.000, 1705614.000, 0006.000, &
		1704253.000, 0013.000, 1698710.000, 0070.000, &
		1713472.000, 0004.000, 1713839.000, 0003.000, &
		1712471.000, 0008.000, 1710149.000, 0028.000, &
		1706410.000, 0070.000, 1718300.000, 0050.000, &
		1720339.000, 0005.000, 1718156.000, 0006.000, &
		1717598.000, 0013.000, 1713010.000, 0070.000, &
		1724150.000, 0090.000, 1725226.000, 0004.000, &
		1724805.000, 0008.000, 1723366.000, 0009.000, &
		1720560.000, 0060.000, 1728860.000, 0140.000, &
		1731622.000, 0003.000, 1730200.000, 0004.000, &
		1730538.000, 0006.000, 1726923.000, 0012.000, &
		1724980.000, 0030.000, 1734550.000, 0090.000, &
		1736184.000, 0003.000, 1736725.000, 0003.000, &
		1735988.000, 0003.000, 1734185.000, 0010.000, &
		1742492.000, 0004.000, 1741755.000, 0004.000, &
		1743114.000, 0005.000, 1740224.000, 0006.000, &
		1739090.000, 0016.000, 1746840.000, 0110.000, &
		1747820.000, 0110.000, 1748354.000, 0004.000, &
		1747265.000, 0009.000, 1745189.000, 0009.000, &
		1741840.000, 0080.000, 1755147.100, 0002.700, &
		1753056.000, 0004.000, 1752841.000, 0006.000, &
		1748440.000, 0050.000, 1758950.000, 0100.000, &
		1760265.100, 0002.700, 1759873.000, 0003.000, &
		1758730.000, 0050.000, 1756110.000, 0050.000, &
		1766704.200, 0002.600, 1765442.000, 0009.000, &
		1765997.000, 0005.000, 1760670.000, 0019.000, &
		1771490.600, 0002.600, 1771951.900, 0002.800, &
		1771740.000, 0003.000, 1767070.000, 0050.000, &
		1777684.000, 0004.000, 1777175.000, 0005.000, &
		1778584.800, 0002.600, 1775993.000, 0009.000, &
		1774827.000, 0008.000, 1782110.000, 0050.000, &
		1783250.000, 0050.000, 1783882.600, 0002.600, &
		1782976.500, 0002.800, 1781080.000, 0050.000, &
		1788310.000, 0200.000, 1790427.700, 0002.600, &
		1788720.000, 0050.000, 1788425.000, 0005.000, &
		1794090.000, 0100.000, 1795553.500, 0002.600, &
		1795290.100, 0002.600, 1794287.000, 0006.000, &
		1798890.000, 0300.000, 1801706.300, 0002.600, &
		1800778.200, 0002.600, 1801287.400, 0002.600, &
		1798250.000, 0050.000, 1796500.000, 0040.000, &
		1806512.800, 0002.600, 1806994.600, 0002.800, &
		1806934.100, 0002.600, 1805351.000, 0003.000, &
		1812444.000, 0005.000, 1812052.000, 0014.000, &
		1813467.700, 0002.600, 1811309.000, 0013.000, &
		1810324.000, 0005.000, 1818190.000, 0070.000, &
		1818709.600, 0002.600, 1817948.100, 0002.600, &
		1816397.000, 0006.000, 1823100.000, 0200.000, &
		1825019.100, 0002.600, 1823487.300, 0002.700, &
		1823367.600, 0002.700, 1817280.000, 0040.000, &
		1828665.000, 0011.000, 1830053.000, 0004.000, &
		1829852.500, 0002.800, 1829062.500, 0002.800, &
		1826775.000, 0005.000, 1836074.000, 0005.000, &
		1835216.200, 0002.700, 1835861.900, 0002.600, &
		1832830.000, 0050.000, 1831286.000, 0005.000, &
		1840772.000, 0014.000, 1841273.000, 0003.000, &
		1841384.500, 0002.700, 1839790.500, 0002.800, &
		1837438.000, 0007.000, 1846628.000, 0015.000, &
		1846246.000, 0018.000, 1847840.000, 0003.000, &
		1844801.700, 0002.900, 1837200.000, 0040.000, &
		1852997.000, 0005.000, 1852259.000, 0006.000, &
		1850831.000, 0008.000, 1847630.000, 0040.000, &
		1859208.000, 0005.000, 1857707.000, 0020.000, &
		1857795.000, 0004.000, 1853960.000, 0060.000, &
		1851580.000, 0014.000, 1863922.000, 0005.000, &
		1864043.000, 0003.000, 1863385.400, 0002.800, &
		1861210.000, 0050.000, 1869754.000, 0011.000, &
		1869006.000, 0006.000, 1870007.000, 0003.000, &
		1865550.000, 0021.000, 1874169.000, 0023.000, &
		1874806.000, 0011.000, 1875117.000, 0005.000, &
		1873957.000, 0006.000, 1871703.000, 0009.000, &
		1881287.000, 0005.000, 1879240.000, 0050.000, &
		1878938.000, 0005.000, 1871331.000, 0018.000, &
		1886092.000, 0007.000, 1885599.000, 0003.000, &
		1884485.000, 0005.000, 1892122.000, 0012.000, &
		1890684.000, 0006.000, 1890996.000, 0004.000, &
		1885620.000, 0025.000, 1896667.000, 0011.000, &
		1896179.000, 0005.000, 1894350.000, 0007.000, &
		1891554.000, 0013.000, 1902556.000, 0007.000, &
		1899710.000, 0050.000, 1898680.000, 0017.000, &
		1890675.000, 0029.000, 1907525.000, 0007.000, &
		1904330.000, 0030.000, 1916669.000, 0011.000, &
		1914060.000, 0050.000, 1910850.000, 0040.000, &
		1919850.000, 0070.000, 1909050.000, 0040.000, &
		1929750.000, 0060.000 /

	TYPE OneDimSolve
		TYPE (R1R1Function), POINTER :: func
		DOUBLE PRECISION AccX ! Accuracy in X direction
		DOUBLE PRECISION AccY ! Accuracy in Y direction
		INTEGER lim ! Maximum number of iterations
		DOUBLE PRECISION, DIMENSION(0:2) :: x, y ! Trial values of X and Y
		INTEGER L, C, U, Last ! Locations of trial values
		INTEGER vpol, hpol ! Polarities
		DOUBLE PRECISION YY ! Target value
		LOGICAL Finish ! .TRUE. if LookAt finds conv.
		LOGICAL Captured ! .TRUE. when target surrounded
		TYPE (DiagonalizationMethod), POINTER :: diagonal
	END TYPE

	SUBROUTINE OneDimSolve_new(solve, func, diagonal)
		TYPE (OneDimSolve), INTENT(INOUT) :: solve
		TYPE (R1R1Function), TARGET, INTENT(IN) :: func
		TYPE (DiagonalizationMethod), TARGET, INTENT(IN) :: diagonal

		solve%func => func
		solve%diagonal => diagonal
		solve%AccX = 0.0
		solve%AccY = 1.e-6
		RETURN
	END SUBROUTINE OneDimSolve_new

	FUNCTION OneDimSolve_solve(solve, Y, X, Dev_in)
		DOUBLE PRECISION OneDimSolve_solve
		TYPE (OneDimSolve), INTENT(INOUT) :: solve
		DOUBLE PRECISION, INTENT(IN) :: Y, X, Dev_in

		INTEGER, PARAMETER :: Lim = 100

		INTEGER State ! 0 = start, 1 = captured1, 2 = captured2, 3 = binary, 4 = finish
		INTEGER i
		DOUBLE PRECISION Dev

		Dev = Dev_in

		solve%lim = Lim
		solve%Captured = .FALSE.
		IF (Dev .EQ. 0.0) STOP "Dev es nulo"
		solve%L = 0
		solve%C = 1
		solve%U = 2
		solve%vpol = 1
		solve%hpol = 1
		solve%y(solve%C) = 0.0
		solve%y(solve%U) = 0.0

		IF (Dev < 0.0) THEN
			solve%hpol = - 1
			Dev = - Dev
		END IF

		solve%YY = Y ! Target value
		solve%x(solve%L) = X ! Initial trial value

		IF (.NOT. R1R1Function_isValid(solve%func, X)) STOP "Valor inicial no valido"

		State = 0
bucle:	DO
			SELECT CASE (State)
			CASE (0)
				CALL OneDimSolve_LookAt(Solve, solve%L)
				IF (solve%Finish) THEN
					State = 4
					CYCLE
				END IF

				IF (solve%y(solve%L) .GT. 0.0) THEN
					CALL OneDimSolve_VFlip(Solve) ! So Y(L) < 0
				END IF

				solve%x(solve%U) = X + (Dev * solve%hpol)
				IF (.NOT. solve%func%infinite_x_max .AND. (solve%x(solve%U) .GT. solve%func%x_max)) THEN
					solve%x(solve%U) = (solve%func%x_max + X) / 2.0
				END IF
				IF (.NOT. solve%func%infinite_x_min .AND. (solve%x(solve%U) .LT. solve%func%x_min)) THEN
					solve%x(solve%U) = (solve%func%x_min + X) / 2.0
				END IF

				CALL OneDimSolve_LookAt(Solve, solve%U)
				IF (solve%Finish) THEN
					State = 4
					CYCLE
				END IF

				IF (solve%y(solve%U) .GT. 0.0) THEN
					State = 1
					solve%Captured = .TRUE.
					CYCLE
				END IF

				IF (solve%y(solve%U) .EQ. solve%y(solve%L)) STOP "La funcion es plana"

				IF (solve%y(solve%U) .LT. solve%y(solve%L)) THEN
					CALL OneDimSolve_HFlip(Solve) ! Change direction
				END IF
				CALL OneDimSolve_State(Solve, solve%L, solve%U, solve%C)

				DO i = 0, 19
					! Have L C then crossing point, Y[L] < Y[C] <0
					solve%x(solve%U) = solve%x(solve%C) + DBLE(Dev * solve%hpol)
					IF (.NOT. solve%func%infinite_x_max .AND. (solve%x(solve%U) .GT. solve%func%x_max)) THEN
						solve%x(solve%U) = (solve%func%x_max + solve%x(solve%C)) / 2.0
					END IF
					IF (.NOT. solve%func%infinite_x_min .AND. (solve%x(solve%U) .LT. solve%func%x_min)) THEN
						solve%x(solve%U) = (solve%func%x_min + solve%x(solve%C)) / 2.0
					END IF

					CALL OneDimSolve_LookAt(Solve, solve%U)
					IF (solve%Finish) THEN
						State = 4
						CYCLE bucle
					END IF

					IF (solve%y(solve%U) .GT. 0) THEN
						State = 2
						solve%Captured = .TRUE.
						CYCLE bucle
					END IF
					Dev = Dev * 2.0
					CALL OneDimSolve_State(Solve, solve%C, solve%U, solve%L)
				END DO
				IF (State .NE. 0) EXIT bucle
				STOP "No se pudo localizar un punto de cruce"

			CASE (1)
				! We have 2 points L and U with crossing between them
				CALL OneDimSolve_Linear(Solve, solve%L, solve%C, solve%U) ! Linear interpolation
				! Result to C
				CALL OneDimSolve_LookAt(Solve, solve%C)
				IF (solve%Finish) THEN
					State = 4
					CYCLE
				END IF

				IF (solve%y(solve%C) .GT. 0.0) THEN
					CALL OneDimSolve_Flip(Solve) ! Want y[C] < 0
				END IF

				IF (solve%y(solve%C) .LT. (0.5 * solve%y(solve%L))) THEN
					CALL OneDimSolve_State(Solve, solve%C, solve%L, solve%U)
					State = 3 ! Binary
					CYCLE
				END IF

				State = 2
				CYCLE

			CASE (2)
				! We have L,C before crossing, U after crossing
				CALL OneDimSolve_Quadratic(Solve, solve%L, solve%C, solve%U) ! Quad interpolation
				! Result to L
				CALL OneDimSolve_State(Solve, solve%C, solve%L, solve%U)
				IF ((((solve%x(solve%C) - solve%x(solve%L)) * solve%hpol) .LE. 0.0) .OR. &
				    (((solve%x(solve%C) - solve%x(solve%U)) * solve%hpol) .GE. 0.0)) THEN
					State = 1
					CYCLE
				END IF

				CALL OneDimSolve_LookAt(Solve, solve%C)
				IF (solve%Finish) THEN
					State = 4
					CYCLE
				END IF

				IF (solve%y(solve%C) .GT. 0.0) THEN
					CALL OneDimSolve_Flip(Solve) ! Want y[C] < 0
				END IF

				IF (solve%y(solve%C) .GT. (0.5 * solve%y(solve%L))) THEN
					State = 2
					CYCLE
				ELSE
					CALL OneDimSolve_State(Solve, solve%C, solve%L, solve%U)
					State = 1
					CYCLE
				END IF

				State = 3
				CYCLE

			CASE (3)
				! We have L, U around crossing - do binary search
				DO i = 3, 1, -1
					solve%x(solve%C) = 0.5 * (solve%x(solve%L) + solve%x(solve%U))
					CALL OneDimSolve_LookAt(Solve, solve%C)
					IF (solve%Finish) THEN
						State = 4
						CYCLE bucle
					END IF

					IF (solve%y(solve%C) .GT. 0.0) THEN
						CALL OneDimSolve_State(Solve, solve%L, solve%U, solve%C)
					ELSE
						CALL OneDimSolve_State(Solve, solve%C, solve%L, solve%U)
					END IF
				END DO

				IF (State .NE. 3) CYCLE
				State = 1
				CYCLE

			CASE (4)
				OneDimSolve_solve = solve%x(solve%Last)
				RETURN
			END SELECT
		END DO bucle
		RETURN
	END FUNCTION OneDimSolve_solve

	SUBROUTINE OneDimSolve_LookAt(solve, V)
		TYPE (OneDimSolve), INTENT(INOUT) :: solve
		INTEGER, INTENT(IN) :: V

		DOUBLE PRECISION yy

		solve%lim = solve%lim - 1
		IF (solve%lim .EQ. 0) STOP "No converge"
		solve%Last = V

!TODO yy = function(solve%x(V)) - solve%YY
		CALL R1R1Function_set(solve%func, solve%x(V))
		yy = DiagonalizationMethod_operator(solve%diagonal) - solve%YY

		IF ((ABS(yy) .LE. solve%AccY) .OR. &
		    (solve%Captured .AND. (ABS(solve%x(solve%L) - solve%x(solve%U)) .LE. solve%AccX))) THEN
			solve%Finish = .TRUE.
		ELSE
			solve%Finish = .FALSE.
		END IF
		solve%y(V) = solve%vpol * yy
		RETURN
	END SUBROUTINE OneDimSolve_LookAt

	SUBROUTINE OneDimSolve_HFlip(solve)
		TYPE (OneDimSolve), INTENT(INOUT) :: solve

		solve%hpol = - solve%hpol
		CALL OneDimSolve_State(Solve, solve%U, solve%C, solve%L)
		RETURN
	END SUBROUTINE OneDimSolve_HFlip

	SUBROUTINE OneDimSolve_VFlip(solve)
		TYPE (OneDimSolve), INTENT(INOUT) :: solve

		solve%vpol = - solve%vpol
		solve%y(0) = - solve%y(0) !TODO solve%y = (-1) * solve%y
		solve%y(1) = - solve%y(1)
		solve%y(2) = - solve%y(2)
		RETURN
	END SUBROUTINE OneDimSolve_VFlip

	SUBROUTINE OneDimSolve_Flip(solve)
		TYPE (OneDimSolve), INTENT(INOUT) :: solve

		solve%hpol = - solve%hpol
		solve%vpol = - solve%vpol
		CALL OneDimSolve_State(Solve, solve%U, solve%C, solve%L)
		solve%y(0) = - solve%y(0) !TODO solve%y = (-1) * solve%y
		solve%y(1) = - solve%y(1)
		solve%y(2) = - solve%y(2)
		RETURN
	END SUBROUTINE OneDimSolve_Flip

	SUBROUTINE OneDimSolve_State(solve, L, C, U)
		TYPE (OneDimSolve), INTENT(INOUT) :: solve
		INTEGER, INTENT(IN) :: L, C, U

		! ATENCIN: Hacemos una doble asignacin, por ejemplo: L => I => solve%L
		! debido a que a pesar de que los parmetros de entrada no son
		! "modificables", la llamada a esta funcin se suele realizar de la
		! forma: OneDimSolve_State(solve, solve%L, solve%C, solve%U)
		! que puede producir una incosistencia por la secuenciacin de las
		! operaciones. Por ejemplo:
		! # OneDimSolve_State(solve, solve%C, solve%L, solve%U)
		! # solve%L = solve%C
		! # solve%C = solve%L ERROR!
		INTEGER I, J, K

		I = L
		J = C
		K = U
		solve%L = I
		solve%C = J
		solve%U = K
		RETURN
	END SUBROUTINE OneDimSolve_State

	SUBROUTINE OneDimSolve_Linear(solve, L, C, U)
		TYPE (OneDimSolve), INTENT(INOUT) :: solve
		INTEGER, INTENT(IN) :: L, C, U

		INTEGER I, J, K

		I = L
		J = C
		K = U
		solve%x(J) = ((solve%x(I) * solve%y(K)) - (solve%x(K) * solve%y(I))) / (solve%y(K) - solve%y(I))
		RETURN
	END SUBROUTINE OneDimSolve_Linear

	SUBROUTINE OneDimSolve_Quadratic(solve, L, C, U)
		TYPE (OneDimSolve), INTENT(INOUT) :: solve
		INTEGER, INTENT(IN) :: L, C, U
		! Result to overwrite I
		DOUBLE PRECISION YJK, YIK, YIJ, XKI, XKJ

		INTEGER I, J, K

		I = L
		J = C
		K = U
		YJK = solve%y(J) - solve%y(K)
		YIK = solve%y(I) - solve%y(K)
		YIJ = solve%y(I) - solve%y(J)
		XKI = solve%x(K) - solve%x(I)
		XKJ = ((solve%x(K) * solve%y(J)) - (solve%x(J) * solve%y(K))) / YJK
		IF ((((YJK / YIK) ** 2) .GT. ((solve%x(K) - solve%x(J)) / XKI)) .OR. &
		    (((YIJ / YIK) ** 2) .GT. ((solve%x(J) - solve%x(I)) / XKI))) THEN
			solve%x(I) = XKJ
		ELSE
			XKI = (solve%x(K) * solve%y(I) - solve%x(I) * solve%y(K)) / YIK
			solve%x(I) = (XKJ * solve%y(I) - XKI * solve%y(J)) / YIJ
		END IF
		RETURN
	END SUBROUTINE OneDimSolve_Quadratic
 MODULE diagmeth

	USE input
	USE symd3t
	USE r1r1
	USE nucleus
	USE symden
	USE symgden
	USE symgdhf
	USE symke2b
	USE symvbb
	USE symvc
	USE symvls
	USE symgdd
	USE selfc
	USE wave
	USE eigenval
	USE jacobi
	USE indexx

	IMPLICIT NONE

	INCLUDE "brent_d1.f90"

	INTEGER, PARAMETER :: MAX_ITER = 4

	TYPE MatrixType
		DOUBLE PRECISION, POINTER, DIMENSION(:, :) :: value
	END TYPE

	TYPE DiagonalMatrix
		DOUBLE PRECISION, POINTER, DIMENSION(:) :: value
	END TYPE

	TYPE DiagonalizationMethod
		TYPE (SelfConsistencyMethod) consistency
		TYPE (R1R1Function) func
		TYPE (MatrixType), POINTER, DIMENSION(:, :) :: UV
		TYPE (DiagonalMatrix), POINTER, DIMENSION(:, :) :: QuasiParticleEnergies
		TYPE (SymGenDensity) S ! Superhamiltoniano sin el multiplicador del radio
		TYPE (SymGenDensity) iterated ! Densidad
		INTEGER ta
	END TYPE

 CONTAINS

	INCLUDE "brent_d2.f90"

	SUBROUTINE DiagonalizationMethod_new(diagonal, density)
		TYPE (DiagonalizationMethod), INTENT(INOUT) :: diagonal
		TYPE (SymDensity), INTENT(INOUT) :: density

		INTEGER ta, a, max_a, d, dd

		! Inicializamos las variables y subtipos
		CALL SelfConsistencyMethod_new(diagonal%consistency, density)
		CALL R1R1Function_new(diagonal%func)
		CALL SymGenDensity_new_Nucleus(diagonal%S, &
			Nucleus_get_N(density%nucleus), &
			Nucleus_get_Z(density%nucleus))
		CALL SymGenDensity_new_SymDensity(diagonal%iterated, density)

		max_a = 2 * N_0
		
		! Reservamos memoria para las matrices del tipo
		ALLOCATE(diagonal%QuasiParticleEnergies(0:1, 0:max_a))
		IF (.NOT. ASSOCIATED(diagonal%QuasiParticleEnergies)) STOP "Unable to allocate memory"
		
		ALLOCATE(diagonal%UV(0:1, 0:max_a))
		IF (.NOT. ASSOCIATED(diagonal%UV)) STOP "Unable to allocate memory"
		
		DO ta = 0, 1
			DO a = 0, max_a
				d = DIM(a)
				dd = d + d
				ALLOCATE(diagonal%QuasiParticleEnergies(ta, a)%value(dd))
				IF (.NOT. ASSOCIATED(diagonal%QuasiParticleEnergies(ta, a)%value)) STOP "Unable to allocate memory"
				
				ALLOCATE(diagonal%UV(ta, a)%value(dd, dd))
				IF (.NOT. ASSOCIATED(diagonal%UV(ta, a)%value)) STOP "Unable to allocate memory"
			END DO
		END DO
		RETURN
	END SUBROUTINE DiagonalizationMethod_new

	SUBROUTINE DiagonalizationMethod_get_SymDensity(diagonal, density)
		TYPE (DiagonalizationMethod), INTENT(INOUT) :: diagonal
		TYPE (SymDensity), INTENT(INOUT) :: density

		CALL SymDensity_new_GenDensity(density, diagonal%iterated)
		RETURN
	END SUBROUTINE DiagonalizationMethod_get_SymDensity

	SUBROUTINE DiagonalizationMethod_goto_SelfConsistency(diagonal, tolerance)
		TYPE (DiagonalizationMethod), INTENT(INOUT) :: diagonal
		DOUBLE PRECISION, INTENT(IN) :: tolerance

		DOUBLE PRECISION b, diff, factor, anneal, R2
		INTEGER A, niter, N, Z, ta
		TYPE (OneDimSolve) neutron_constrainer, proton_constrainer
		TYPE (SymDensity) new_density
		DOUBLE PRECISION accuracy
		INTEGER cycles_in, cycles_out, cycles_rate

		TYPE (SymHartreeFockField) field1, field2

		PRINT "(/A)", "Iniciando calculo autoconsistente"
		PRINT "(A,I2)", "Numero de capas: ", N_0
		PRINT "(A,ES8.2)", "Tolerancia: ", tolerance
		! Leemos el reloj actual del sistema
		CALL SYSTEM_CLOCK(cycles_in)

		diff = 0.0
		b = Nucleus_get_b(diagonal%consistency%density%nucleus)
		PRINT "(A,F8.5/)", "Longitud del oscilador (b) = ", b
		A = Nucleus_get_A(diagonal%consistency%density%nucleus)
		
		IF ((A .LE. 1) .OR. (A .GE. 300)) THEN
			PRINT *, "Unexpected A value = ", A
			STOP "DiagonalizationMethod_goto_SelfConsistency"
		END IF
		
		factor = 1.0 - (1.0 / A)

		CALL SymVBBph_calculate(diagonal%consistency%vBBph)
		CALL SymVBBpp_calculate(diagonal%consistency%vBBpp)
		CALL SymVCph_calculate(diagonal%consistency%vCph)
		CALL SymVCpp_calculate(diagonal%consistency%vCpp)
		CALL SymVLSph_calculate(diagonal%consistency%vLSph)
		CALL SymVLSpp_calculate(diagonal%consistency%vLSpp)

		CALL SymHartreeFockField_new(field1)
		CALL SymHartreeFockField_new(field2)

		anneal = 0.2
		niter = 0
gsc:		DO
  			N = Nucleus_get_N(diagonal%consistency%density%nucleus)
 			Z = Nucleus_get_Z(diagonal%consistency%density%nucleus)
			A = N + Z
			IF (A .LE. 1) THEN
				PRINT *, "Unexpected A value = ", A
				STOP "DiagonalizationMethod_goto_SelfConsistency"
			END IF

			CALL DiagonalizationMethod_get_MeanField(diagonal, diagonal%S)

			CALL DiagonalizationMethod_set_ISOSpin(diagonal, 1)

			CALL OneDimSolve_new(neutron_constrainer, diagonal%func, diagonal)
			diagonal%consistency%density%nucleus%lambda_np(1) = OneDimSolve_Solve(neutron_constrainer, &
				DBLE(N), diagonal%consistency%density%nucleus%lambda_np(1), &
				0.5 * (diagonal%consistency%density%nucleus%np(1) - diagonal%consistency%density%nucleus%actual_np(1)) + 0.1)

			CALL DiagonalizationMethod_set_ISOSpin(diagonal, 0)

			CALL OneDimSolve_new(proton_constrainer, diagonal%func, diagonal)
			diagonal%consistency%density%nucleus%lambda_np(0) = OneDimSolve_Solve(proton_constrainer, &
				DBLE(Z), diagonal%consistency%density%nucleus%lambda_np(0), &
				0.5 * (diagonal%consistency%density%nucleus%np(0) - diagonal%consistency%density%nucleus%actual_np(0)) + 0.1)

			CALL SymDensity_new_GenDensity(new_density, diagonal%iterated)

			IF (MOD(niter, MAX_ITER) .EQ. 0) THEN
				diff = SymHartreeFockField_distance(diagonal%consistency%density%field%rho, new_density%field%rho)
				PRINT "(A12,I4,A14,ES15.5)", "Iteraciones:", niter, "Diferencia:", diff
			END IF
			niter = niter + 1

			IF (MOD(niter, 50) .EQ. 0) THEN
				anneal = anneal + 0.1
				PRINT "(A,F8.5)", "El annealing se aumento a ", anneal
			END IF

			factor = 1.0 / (1.0 + anneal)
			CALL SymHartreeFockField_product(field1, anneal, diagonal%consistency%density%field%rho)
			CALL SymHartreeFockField_add(field2, new_density%field%rho, field1)
			CALL SymHartreeFockField_product(diagonal%consistency%density%field%rho, factor, field2)

			CALL SymHartreeFockField_product(field1, anneal, diagonal%consistency%density%field%kap)
			CALL SymHartreeFockField_add(field2, new_density%field%kap, field1)
			CALL SymHartreeFockField_product(diagonal%consistency%density%field%kap, factor, field2)

			DO ta = 0, 1
				diagonal%consistency%density%nucleus%actual_np(ta) = factor	* ((new_density%nucleus%actual_np(ta)) &
					+ (anneal * diagonal%consistency%density%nucleus%actual_np(ta)))
			END DO

			IF (MOD(niter, (10 * MAX_ITER)) .EQ. 0) THEN
				CALL SymDensity_save(diagonal%consistency%density)
			END IF

			accuracy = SelfConsistencyMethod_accuracy(diagonal%consistency)
			PRINT "(A,I5,A,EN15.5)", "Iteration N = ",niter, " Energy:", diagonal%consistency%density%nucleus%eHFB
			IF ((diff .LE. tolerance) .AND. (MOD(niter, MAX_ITER) .EQ. 0)) THEN
				accuracy = SelfConsistencyMethod_accuracy(diagonal%consistency)
				PRINT "(A30,EN15.5,A12,ES12.5)", "Energia:", diagonal%consistency%density%nucleus%eHFB, "Precision:", accuracy
				IF (accuracy .LE. tolerance) THEN
					EXIT gsc
				END IF
			END IF
		END DO gsc

		CALL SymHartreeFockField_del(field1)
		CALL SymHartreeFockField_del(field2)

		CALL SYSTEM_CLOCK(cycles_out, cycles_rate)
		PRINT "(/A,EN10.2)", "Tiempo empleado (segundos): ", (DBLE(cycles_out - cycles_in) / cycles_rate)

		CALL SymDensity_store_actual_R2(diagonal%consistency%density)

		CALL SelfConsistencyMethod_store_eHFB(diagonal%consistency)
		CALL SelfConsistencyMethod_show_Status(diagonal%consistency)
		RETURN
	END SUBROUTINE DiagonalizationMethod_goto_SelfConsistency

	SUBROUTINE DiagonalizationMethod_get_MeanField(diagonal, S)
		TYPE (DiagonalizationMethod), INTENT(INOUT) :: diagonal
		TYPE (SymGenDensity), INTENT(INOUT) :: S

		DOUBLE PRECISION b, factor
		INTEGER A

		TYPE (SymHartreeFockField) HF_Gamma, HF_Delta
		TYPE (SymD3Tensor) ek_tensor
		TYPE (SymHartreeFockField) ekcm_field, vbb_field, vc_field, vls_field, gdd_field, field1, field2
		TYPE (SymGenDensityHF) gendenhf_gamma, gendenhf_delta

!	integer la,u1,u2

		b = Nucleus_get_b(diagonal%consistency%density%nucleus)
		A = Nucleus_get_A(diagonal%consistency%density%nucleus)
		IF ((A .LE. 1) .OR. (A .GE. 300)) THEN
			PRINT *, "Unexpected A value = ", A
			STOP "DiagonalizationMethod::get_MeanField"
		END IF

		CALL SymHartreeFockField_new(HF_Gamma)
		CALL SymHartreeFockField_new(HF_Delta)
		CALL SymD3Tensor_new(ek_tensor)
		CALL SymHartreeFockField_new(ekcm_field)
		CALL SymHartreeFockField_new(vbb_field)
		CALL SymHartreeFockField_new(vc_field)
		CALL SymHartreeFockField_new(vls_field)
		CALL SymHartreeFockField_new(gdd_field)
		CALL SymHartreeFockField_new(field1)
		CALL SymHartreeFockField_new(field2)

		factor = 1.0 - (1.0 / A)

		CALL SymD3Tensor_product(ek_tensor, DBLE(factor / (b * b)), EkField)
!	print *,"Ek:"
!	do la=0,N_0
!		print *,"la=",la
!		do u1=1,((N_0-la)/2)+1
!			print "(5F10.5)",(ek_tensor%d3tensor(la)%d2(u1,u2),u2=1,((N_0-la)/2)+1)
!		end do
!	end do

		CALL SymKineticEnergy2Body_product(field1, diagonal%consistency%vEkCMph, diagonal%consistency%density%field%rho)
		CALL SymHartreeFockField_product(ekcm_field, DBLE(1.0 / (A * (b * b))), field1)
!	print *,"EkCM:", DBLE(1.0 / (A * (b * b)))
!	do la=0,N_0
!		print *,"la=",la
!		do u1=1,((N_0-la)/2)+1
!			print "(5F10.5)",(ekcm_field%p(0)%d3tensor(la)%d2(u1,u2),u2=1,((N_0-la)/2)+1)
!		end do
!	end do

		CALL SymVBBph_product(vbb_field, diagonal%consistency%vBBph, diagonal%consistency%density%field%rho)
!	print *,"BB:"
!	do la=0,N_0
!		print *,"la=",la
!		do u1=1,((N_0-la)/2)+1
!			print "(5F10.5)",(vbb_field%p(0)%d3tensor(la)%d2(u1,u2),u2=1,((N_0-la)/2)+1)
!		end do
!	end do

		CALL SymVCph_product(field1, diagonal%consistency%vCph, diagonal%consistency%density%field%rho)
		CALL SymHartreeFockField_product(vc_field, DBLE(1.0 / b), field1)
!	print *,"C:"
!	do la=0,N_0
!		print *,"la=",la
!		do u1=1,((N_0-la)/2)+1
!			print "(5F10.5)",(vc_field%p(0)%d3tensor(la)%d2(u1,u2),u2=1,((N_0-la)/2)+1)
!		end do
!	end do

		CALL SymVLSph_product(field1, diagonal%consistency%vLSph, diagonal%consistency%density%field%rho)
		CALL SymHartreeFockField_product(vls_field, DBLE(1.0 / (b ** 5.0)), field1)
!	print *,"LS:"
!	do la=0,N_0
!		print *,"la=",la
!		do u1=1,((N_0-la)/2)+1
!			print "(5F10.5)",(vls_field%p(0)%d3tensor(la)%d2(u1,u2),u2=1,((N_0-la)/2)+1)
!		end do
!	end do

		CALL SymGDDph_update(field1, diagonal%consistency%gDDph, diagonal%consistency%density%field%rho)
		CALL SymHartreeFockField_product(gdd_field, DBLE(1.0 / (b ** 4.0)), field1)
!	print *,"DD:"
!	do la=0,N_0
!		print *,"la=",la
!		do u1=1,((N_0-la)/2)+1
!			print "(5F10.5)",(gdd_field%p(0)%d3tensor(la)%d2(u1,u2),u2=1,((N_0-la)/2)+1)
!		end do
!	end do

		CALL SymHartreeFockField_add(field1, vls_field, gdd_field)
		CALL SymHartreeFockField_add(field2, vc_field, field1)
		CALL SymHartreeFockField_add(field1, vbb_field, field2)
		CALL SymHartreeFockField_add(field2, ekcm_field, field1)
		CALL SymHartreeFockField_add_SymD3Tensor(HF_Gamma, ek_tensor, field2)

!	print *,"Gamma:"
!	do la=0,N_0
!		print *,"la=",la
!		do u1=1,((N_0-la)/2)+1
!			print "(5F10.5)",(HF_Gamma%p(0)%d3tensor(la)%d2(u1,u2),u2=1,((N_0-la)/2)+1)
!		end do
!	end do
!		HF_Gamma = (factor / (b * b)) * EkField + &
!			(1.0 / (A * (b * b))) * (diagonal%consistency%vEkCMph * diagonal%consistency%density%field%rho) + &
!			(diagonal%consistency%vBBph * diagonal%consistency%density%field%rho) + &
!			(1.0 / b) * (diagonal%consistency%vCph * diagonal%consistency%density%field%rho) + &
!			(1.0 / (b ** 5.0)) * (diagonal%consistency%vLSph * diagonal%consistency%density%field%rho) + &
!			(1.0 / (b ** 4.0)) * SymGDDph_update(diagonal%consistency%gDDph, diagonal%consistency%density%field%rho)

		CALL SymVBBpp_product(vbb_field, diagonal%consistency%vBBpp, diagonal%consistency%density%field%kap)

		CALL SymVCpp_product(field1, diagonal%consistency%vCpp, diagonal%consistency%density%field%kap)
		CALL SymHartreeFockField_product(vc_field, DBLE(1.0 / b), field1)

		CALL SymVLSpp_product(field1, diagonal%consistency%vLSpp, diagonal%consistency%density%field%kap)
		CALL SymHartreeFockField_product(vls_field, DBLE(1.0 / (b ** 5.0)), field1)

		CALL SymHartreeFockField_add(field1, vc_field, vls_field)
		CALL SymHartreeFockField_add(HF_Delta, vbb_field, field1)

!		HF_Delta = (diagonal%consistency%vBBpp * diagonal%consistency%density%field%kap) + &
!			(1.0 / b) * (diagonal%consistency%vCpp * diagonal%consistency%density%field%kap) + &
!			(1.0 / (b ** 5.0)) * (diagonal%consistency%vLSpp * diagonal%consistency%density%field%kap)

		CALL SymGenDensityHF_new(gendenhf_gamma)
		CALL SymGenDensityHF_new(gendenhf_delta)
		CALL SymGenDensityHF_copy(gendenhf_gamma, HF_Gamma)
		CALL SymGenDensityHF_copy(gendenhf_delta, HF_Delta)

		CALL SymGenDensity_new_GammaDelta(S, gendenhf_gamma, gendenhf_delta, b)

		CALL SymGenDensityHF_del(gendenhf_gamma)
		CALL SymGenDensityHF_del(gendenhf_delta)

		CALL SymHartreeFockField_del(HF_Gamma)
		CALL SymHartreeFockField_del(HF_Delta)
		CALL SymD3Tensor_del(ek_tensor)
		CALL SymHartreeFockField_del(ekcm_field)
		CALL SymHartreeFockField_del(vbb_field)
		CALL SymHartreeFockField_del(vc_field)
		CALL SymHartreeFockField_del(vls_field)
		CALL SymHartreeFockField_del(gdd_field)
		CALL SymHartreeFockField_del(field1)
		CALL SymHartreeFockField_del(field2)
		RETURN
	END SUBROUTINE DiagonalizationMethod_get_MeanField

	SUBROUTINE DiagonalizationMethod_set_ISOSpin(diagonal, ta)
		TYPE (DiagonalizationMethod), INTENT(INOUT) :: diagonal
		INTEGER, INTENT(IN) :: ta

		diagonal%ta = ta
		RETURN
	END SUBROUTINE DiagonalizationMethod_set_ISOSpin

	FUNCTION DiagonalizationMethod_get_WaveFunction(diagonal)
		TYPE (WaveFunction) DiagonalizationMethod_get_WaveFunction
		TYPE (DiagonalizationMethod), INTENT(INOUT) :: diagonal

		INTEGER N, Z, A
		DOUBLE PRECISION factor, b
		DOUBLE PRECISION, DIMENSION(0:1) :: np, R2
		DATA np /0.0, 0.0/
		DATA R2 /0.0, 0.0/
		TYPE (SymGenDensity) SuperHamiltonian
		INTEGER ta, a2, d, dd, la, ja

		DOUBLE PRECISION, DIMENSION(:, :), ALLOCATABLE :: I, h, Delta, SH, UV, U, V, tmp
		DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE :: Diag2
		INTEGER u1, u2
		DOUBLE PRECISION trace

		TYPE (SymHartreeFockField) HF_Gamma, HF_Delta
		TYPE (SymD3Tensor) ek_tensor
		TYPE (SymHartreeFockField) ekcm_field, vbb_field, vc_field, vls_field, gdd_field, field1, field2
		TYPE (SymGenDensityHF) gendenhf_gamma, gendenhf_delta

		N = Nucleus_get_N(diagonal%consistency%density%nucleus)
		Z = Nucleus_get_Z(diagonal%consistency%density%nucleus)
		A = N + Z
		factor = 1.0 - (1.0 / A)
		b = Nucleus_get_b(diagonal%consistency%density%nucleus)

		! ATENCIN: El siguiente procedimiento crea un ncleo a partir
		! del nmero de neutrones y protones (N y Z). Ncleo que es sobreescrito
		! a continuacin... Esto ha sido mantenido por "similitud" con el
		! programa original, pero debera ser corregido en una versin posterior
		CALL WaveFunction_new(DiagonalizationMethod_get_WaveFunction, N, Z)
		CALL Nucleus_copy(DiagonalizationMethod_get_WaveFunction%nucleus, diagonal%consistency%density%nucleus)

		CALL SymHartreeFockField_new(HF_Gamma)
		CALL SymHartreeFockField_new(HF_Delta)
		CALL SymD3Tensor_new(ek_tensor)
		CALL SymHartreeFockField_new(ekcm_field)
		CALL SymHartreeFockField_new(vbb_field)
		CALL SymHartreeFockField_new(vc_field)
		CALL SymHartreeFockField_new(vls_field)
		CALL SymHartreeFockField_new(gdd_field)
		CALL SymHartreeFockField_new(field1)
		CALL SymHartreeFockField_new(field2)

		CALL SymD3Tensor_product(ek_tensor, DBLE(factor / (b * b)), EkField)

		CALL SymKineticEnergy2Body_product(field1, diagonal%consistency%vEkCMph, diagonal%consistency%density%field%rho)
		CALL SymHartreeFockField_product(ekcm_field, DBLE(1.0 / (A * (b * b))), field1)

		CALL SymVBBph_product(vbb_field, diagonal%consistency%vBBph, diagonal%consistency%density%field%rho)

		CALL SymVCph_product(field1, diagonal%consistency%vCph, diagonal%consistency%density%field%rho)
		CALL SymHartreeFockField_product(vc_field, DBLE(1.0 / b), field1)

		CALL SymVLSph_product(field1, diagonal%consistency%vLSph, diagonal%consistency%density%field%rho)
		CALL SymHartreeFockField_product(vls_field, DBLE(1.0 / (b ** 5.0)), field1)

		CALL SymGDDph_update(field1, diagonal%consistency%gDDph, diagonal%consistency%density%field%rho)
		CALL SymHartreeFockField_product(gdd_field, DBLE(1.0 / (b ** 4.0)), field1)

		CALL SymHartreeFockField_add(field1, vls_field, gdd_field)
		CALL SymHartreeFockField_add(field2, vc_field, field1)
		CALL SymHartreeFockField_add(field1, vbb_field, field2)
		CALL SymHartreeFockField_add(field2, ekcm_field, field1)
		CALL SymHartreeFockField_add_SymD3Tensor(HF_Gamma, ek_tensor, field2)

		CALL SymVBBpp_product(vbb_field, diagonal%consistency%vBBpp, diagonal%consistency%density%field%kap)

		CALL SymVCpp_product(field1, diagonal%consistency%vCpp, diagonal%consistency%density%field%kap)
		CALL SymHartreeFockField_product(vc_field, DBLE(1.0 / b), field1)

		CALL SymVLSpp_product(field1, diagonal%consistency%vLSpp, diagonal%consistency%density%field%kap)
		CALL SymHartreeFockField_product(vls_field, DBLE(1.0 / (b ** 5.0)), field1)

		CALL SymHartreeFockField_add(field1, vc_field, vls_field)
		CALL SymHartreeFockField_add(HF_Delta, vbb_field, field1)

!		CALL SymGenDensity_new_GammaDelta(SuperHamiltonian, &
!			(factor / (b * b)) * EkField &
!			+ (1.0 / (A * (b * b))) * (diagonal%consistency%vEkCMph * diagonal%consistency%density%field%rho)  &
!			+ (diagonal%consistency%vBBph * diagonal%consistency%density%field%rho)  &
!			+ (1.0 / b) * (diagonal%consistency%vCph * diagonal%consistency%density%field%rho)  &
!			+ (1.0 / (b ** 5.0)) * (diagonal%consistency%vLSph * diagonal%consistency%density%field%rho)  &
!			+ (1.0 / (b ** 4.0)) * SymGDDph_update(diagonal%consistency%gDDph, diagonal%consistency%density%field%rho), & ! pairing field
!			  (diagonal%consistency%vBBpp * diagonal%consistency%density%field%kap)  &
!			+ (1.0 / b) * (diagonal%consistency%vCpp * diagonal%consistency%density%field%kap)  &
!			+ (1.0 / (b ** 5.0)) * (diagonal%consistency%vLSpp * diagonal%consistency%density%field%kap), &
!			b)

		CALL SymGenDensityHF_new(gendenhf_gamma)
		CALL SymGenDensityHF_new(gendenhf_delta)
		CALL SymGenDensityHF_copy(gendenhf_gamma, HF_Gamma)
		CALL SymGenDensityHF_copy(gendenhf_delta, HF_Delta)

		CALL SymGenDensity_new_GammaDelta(SuperHamiltonian, gendenhf_gamma, gendenhf_delta, b)

		CALL SymGenDensityHF_del(gendenhf_gamma)
		CALL SymGenDensityHF_del(gendenhf_delta)

		CALL SymHartreeFockField_del(HF_Gamma)
		CALL SymHartreeFockField_del(HF_Delta)
		CALL SymD3Tensor_del(ek_tensor)
		CALL SymHartreeFockField_del(ekcm_field)
		CALL SymHartreeFockField_del(vbb_field)
		CALL SymHartreeFockField_del(vc_field)
		CALL SymHartreeFockField_del(vls_field)
		CALL SymHartreeFockField_del(gdd_field)
		CALL SymHartreeFockField_del(field1)
		CALL SymHartreeFockField_del(field2)

		DO ta = 0, 1
			DO a2 = 0, 2 * N_0
				d = DIM(a2)
				dd = d + d
				la = L(a2)
				ja = J(a2)

				ALLOCATE(I(d, d))
				ALLOCATE(h(d, d))
				ALLOCATE(Delta(d, d))
				ALLOCATE(SH(dd, dd))
				ALLOCATE(Diag2(dd))
				ALLOCATE(UV(dd, dd))
				ALLOCATE(U(d, d))
				ALLOCATE(V(d, d))
				ALLOCATE(tmp(d, d))

				I = 0.0
				DO u1 = 1, d
					I(u1, u1) = 1.0
				END DO

				h = SuperHamiltonian%rho%rho(ta, a2)%store &
					- (diagonal%consistency%density%nucleus%lambda_np(ta) * I) &
					- (diagonal%consistency%density%nucleus%lambda_R2(ta) * (b ** 2) &
					* SymD3Tensor_matrix(R2Field, la))

				Delta = SuperHamiltonian%kap%rho(ta, a2)%store

				! Componemos la matriz SH de la siguiente forma:
				!    h     -Delta
				!   -Delta -h
				DO u1 = 1, d
					DO u2 = 1, d
						SH(u1    , u2    ) =   h(u1, u2)
						SH(u1    , u2 + d) = - Delta(u1, u2)
						SH(u1 + d, u2    ) = - Delta(u1, u2)
						SH(u1 + d, u2 + d) = - h(u1, u2)
					END DO
				END DO

				CALL EigenValues(dd, dd, SH, Diag2, UV)

				! Extraemos las matrices U y V
				! A partir de la matriz UV, la posicin de las matrices U y V
				! es la siguiente:
				!   X X
				!   U V
				DO u1 = 1, d
					DO u2 = 1, d
						U(u1, u2) = UV(u1    , u2 + d)
						V(u1, u2) = UV(u1 + d, u2 + d)
					END DO
				END DO

				DiagonalizationMethod_get_WaveFunction%genden%rho%rho(ta, a2)%value = U
				DiagonalizationMethod_get_WaveFunction%genden%kap%rho(ta, a2)%value = V

				tmp = MATMUL(V, TRANSPOSE(V))
				! Calculamos la traza de la matriz "tmp"
				trace = 0.0
				DO u1 = 1, d
					trace = trace + tmp(u1, u1)
				END DO
				np(ta) = np(ta) + (DBLE(ja + 1.0) * trace)

				tmp = MATMUL(SymD3Tensor_matrix(R2Field, la), MATMUL(V, TRANSPOSE(V)))
				! Calculamos la traza de la matriz "tmp"
				trace = 0.0
				DO u1 = 1, d
					trace = trace + tmp(u1, u1)
				END DO
				R2(ta) = R2(ta) + (DBLE(ja + 1.0) * trace)

				DEALLOCATE(I)
				DEALLOCATE(h)
				DEALLOCATE(Delta)
				DEALLOCATE(SH)
				DEALLOCATE(Diag2)
				DEALLOCATE(UV)
				DEALLOCATE(U)
				DEALLOCATE(V)
				DEALLOCATE(tmp)
			END DO
		END DO
		RETURN
	END FUNCTION DiagonalizationMethod_get_WaveFunction

	FUNCTION DiagonalizationMethod_operator(diagonal)
		DOUBLE PRECISION DiagonalizationMethod_operator
		TYPE (DiagonalizationMethod), INTENT(INOUT) :: diagonal

		DOUBLE PRECISION np, R2, b2
		INTEGER a, d, dd, la, ja

		DOUBLE PRECISION, DIMENSION(:, :), ALLOCATABLE :: xI, h, Delta, SH, U, V, tmp
		INTEGER u1, u2
		DOUBLE PRECISION trace

		np = 0.0
		R2 = 0.0
		b2 = Nucleus_get_b(diagonal%iterated%nucleus) ** 2

		DO a = 0, 2 * N_0
			d = DIM(a)
			dd = d + d
			la = L(a)
			ja = J(a)

			ALLOCATE(xI(d, d))
			ALLOCATE(h(d, d))
			ALLOCATE(Delta(d, d))
			ALLOCATE(SH(dd, dd))
			ALLOCATE(U(d, d))
			ALLOCATE(V(d, d))
			ALLOCATE(tmp(d, d))

			xI = 0.0
			DO u1 = 1, d
				xI(u1, u1) = diagonal%func%x
			END DO
			h = diagonal%S%rho%rho(diagonal%ta, a)%store - xI

			Delta = 1.0 * diagonal%S%kap%rho(diagonal%ta, a)%store

			! Componemos la matriz SH de la siguiente forma:
			!    h     -Delta
			!   -Delta -h
			DO u1 = 1, d
				DO u2 = 1, d
					SH(u1    , u2    ) =   h(u1, u2)
					SH(u1    , u2 + d) = - Delta(u1, u2)
					SH(u1 + d, u2    ) = - Delta(u1, u2)
					SH(u1 + d, u2 + d) = - h(u1, u2)
				END DO
			END DO

			! ATENCION: Este procedimiento no ha sido traducido, sino
			! extrado a traves de Google.
			! Confiamos en su correcta implementacion

			! Da las enegias ordenadas de menor (negativas) a mayor (positivas)
			CALL EigenValues(dd, dd, SH, &
				diagonal%QuasiParticleEnergies(diagonal%ta, a)%value, &
				diagonal%UV(diagonal%ta, a)%value)

			! Extraemos las matrices U y V
			DO u1 = 1, d
				DO u2 = 1, d
					U(u1, u2) = diagonal%UV(diagonal%ta, a)%value(u1    , u2 + d)
					V(u1, u2) = diagonal%UV(diagonal%ta, a)%value(u1 + d, u2 + d)
				END DO
			END DO

			CALL SymGenDensity_make_Block(diagonal%iterated, diagonal%ta, a, U, V)

			trace = 0.0
			DO u1 = 1, d
				trace = trace + diagonal%iterated%rho%rho(diagonal%ta, a)%store(u1, u1)
			END DO
			np = np + DBLE(ja + 1.0) * trace

			tmp = MATMUL(SymD3Tensor_matrix(R2Field, la), diagonal%iterated%rho%rho(diagonal%ta, a)%store)
			trace = 0.0
			DO u1 = 1, d
				trace = trace + tmp(u1, u1)
			END DO
			R2 = R2 + DBLE(ja + 1.0) * trace

			! Liberamos la memoria de las matrices utilizadas
			DEALLOCATE(xI)
			DEALLOCATE(h)
			DEALLOCATE(Delta)
			DEALLOCATE(SH)
			DEALLOCATE(U)
			DEALLOCATE(V)
			DEALLOCATE(tmp)
		END DO
		diagonal%iterated%nucleus%actual_np(diagonal%ta) = np
		diagonal%iterated%nucleus%actual_R2(diagonal%ta) = (b2 * R2) / np
		! Resultado final
		DiagonalizationMethod_operator = np
		RETURN
	END FUNCTION DiagonalizationMethod_operator

	! Encontrar la base de particulas
	SUBROUTINE DiagonalizationMethod_show_ParticleEnergies(diagonal)
		TYPE (DiagonalizationMethod), INTENT(INOUT) :: diagonal

		DOUBLE PRECISION b
		TYPE (SymGenDensity) G, SuperHamiltonian
		INTEGER ndim, a, num, i, dim_cur, dim_acc, la, ja, ta
		INTEGER, DIMENSION(:), ALLOCATABLE :: an, ap
		TYPE (DiagonalMatrix), DIMENSION(0:1) :: D
		TYPE (MatrixType), DIMENSION(0:1) :: P, E, R2
		DOUBLE PRECISION, DIMENSION(:, :), ALLOCATABLE :: S, V
		TYPE (DiagonalMatrix), DIMENSION(0:1) :: Occup, SingleParticleE, SingleParticleP, SingleParticleR2
		INTEGER, DIMENSION(:), ALLOCATABLE :: in, ip
		DOUBLE PRECISION spn, spp
		CHARACTER, DIMENSION(0:19) :: spectr
		DATA spectr / "s", "p", "d", "f", "g", "h", "i", "j", "k", "l", &
			"m", "n", "o", "p", "q", "r", "s", "t", "u", "v" /
		INTEGER nrot

		b = Nucleus_get_b(diagonal%consistency%density%nucleus)

		CALL SymGenDensity_new_SymDensity(G, diagonal%consistency%density)
!A	GenDenHF PB = G.rho.get_particle_basis();

		dim_cur = 0
		DO a = 0, 2 * N_0
			dim_cur = dim_cur + DIM(a)
		END DO
		ALLOCATE(Occup(0)%value(dim_cur))
		ALLOCATE(Occup(1)%value(dim_cur))
		ALLOCATE(SingleParticleE(0)%value(dim_cur))
		ALLOCATE(SingleParticleE(1)%value(dim_cur))
		ALLOCATE(SingleParticleP(0)%value(dim_cur))
		ALLOCATE(SingleParticleP(1)%value(dim_cur))
		ALLOCATE(SingleParticleR2(0)%value(dim_cur))
		ALLOCATE(SingleParticleR2(1)%value(dim_cur))

		CALL DiagonalizationMethod_get_MeanField(diagonal, SuperHamiltonian)
!A	SuperHamiltonian.rho.show_particle_energies(PB);

		ndim = (N_0 + 1) * (N_0 + 2) / 2
		ALLOCATE(an(ndim + 1))
		ALLOCATE(ap(ndim + 1))

		dim_acc = 0
		num = 1
		DO a = 0, 2 * N_0
			dim_cur = DIM(a)
			la = L(a)
			ja = J(a)
			DO i = 1, dim_cur
				an(num) = a
				ap(num) = a
				num = num + 1
			END DO

			ALLOCATE(S(dim_cur, dim_cur))
			ALLOCATE(V(dim_cur, dim_cur))

			DO ta = 0, 1
				ALLOCATE(D(ta)%value(dim_cur))
				ALLOCATE(E(ta)%value(dim_cur, dim_cur))
				ALLOCATE(P(ta)%value(dim_cur, dim_cur))
				ALLOCATE(R2(ta)%value(dim_cur, dim_cur))

				S = G%rho%rho(ta, a)%store
				CALL Jacobi_real8(S, dim_cur, D(ta)%value, V, nrot)

				E(ta)%value = MATMUL(TRANSPOSE(V), MATMUL(SuperHamiltonian%rho%rho(ta, a)%store, V))
				P(ta)%value = MATMUL(TRANSPOSE(V), MATMUL(SuperHamiltonian%kap%rho(ta, a)%store, V))
				R2(ta)%value = MATMUL(TRANSPOSE(V), (b * b) * MATMUL(SymD3Tensor_matrix(R2Field, L(a)), V))

				DO i = 1, dim_cur
					Occup(ta)%value(dim_acc + i) = D(ta)%value(i)
					SingleParticleE(ta)%value(dim_acc + i) = E(ta)%value(i, i)
					SingleParticleP(ta)%value(dim_acc + i) = P(ta)%value(i, i)
					SingleParticleR2(ta)%value(dim_acc + i) = R2(ta)%value(i, i)
				END DO

				DEALLOCATE(D(ta)%value)
				DEALLOCATE(E(ta)%value)
				DEALLOCATE(P(ta)%value)
				DEALLOCATE(R2(ta)%value)
			END DO

			DEALLOCATE(S)
			DEALLOCATE(V)

			dim_acc = dim_acc + dim_cur
		END DO

		ALLOCATE(in(ndim))
		ALLOCATE(ip(ndim))
		CALL indexx_real8(ndim, SingleParticleE(1)%value, in)
		CALL indexx_real8(ndim, SingleParticleE(0)%value, ip)
		PRINT *
		PRINT "(A32,A36)", "neu", "pro"
spe:		DO i = 1, ndim
			spn = SingleParticleE(1)%value(in(i))
			spp = SingleParticleE(0)%value(ip(i))
			IF ((spn .LT. -20.0) .AND. (spp .LT. -20.0)) CYCLE
			IF ((spn .GT.  10.0) .AND. (spp .GT.  10.0)) EXIT spe

			PRINT "(A2,I2,F6.2,F10.3,F8.3,F8.3,A8,I2,F6.2,F10.3,F10.3,F8.3)", &
				spectr(L(an(in(i)))), J(an(in(i))), Occup(1)%value(in(i)), spn, SingleParticleP(1)%value(in(i)), SingleParticleR2(1)%value(in(i)), &
				spectr(L(ap(ip(i)))), J(ap(ip(i))), Occup(0)%value(ip(i)), spp, SingleParticleP(0)%value(ip(i)), SingleParticleR2(0)%value(ip(i))
		END DO spe

		DEALLOCATE(in)
		DEALLOCATE(ip)

		DEALLOCATE(Occup(0)%value)
		DEALLOCATE(Occup(1)%value)
		DEALLOCATE(SingleParticleE(0)%value)
		DEALLOCATE(SingleParticleE(1)%value)
		DEALLOCATE(SingleParticleP(0)%value)
		DEALLOCATE(SingleParticleP(1)%value)
		DEALLOCATE(SingleParticleR2(0)%value)
		DEALLOCATE(SingleParticleR2(1)%value)

		DEALLOCATE(an)
		DEALLOCATE(ap)
		RETURN
	END SUBROUTINE DiagonalizationMethod_show_ParticleEnergies

	SUBROUTINE DiagonalizationMethod_show_QuasiParticleEnergies(diagonal)
		TYPE (DiagonalizationMethod), INTENT(INOUT) :: diagonal

		INTEGER NN, NumberOfStates, a, na, top
		INTEGER, DIMENSION(:), ALLOCATABLE :: nIndx, pIndx
		CHARACTER, DIMENSION(0:19) :: spectr
		DATA spectr / "s", "p", "d", "f", "g", "h", "i", "j", "k", "l", &
			"m", "n", "o", "p", "q", "r", "s", "t", "u", "v" /
		DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE :: nQPE, pQPE, nVV, pVV
		INTEGER, DIMENSION(:), ALLOCATABLE :: nMomentum, pMomentum
		INTEGER num, la, ja, d, s1, sa
		DOUBLE PRECISION sumvvn, sumvvp
		INTEGER an, ap, jn, jp
		CHARACTER cn, cp

		NN = N_0 * 2
		NumberOfStates = 0;
		DO a = 0, NN
			NumberOfStates = NumberOfStates + DIM(a)
		END DO

		! Imprimir las energias de cuasiparticulas
		! y las ocupaciones para neutrones y protones
		top = MIN(100, NumberOfStates)

		ALLOCATE(nIndx(top))
		ALLOCATE(pIndx(top))

		! Asignar memoria a la tabla de energias de cuasiparticulas,
		! sus momentos angulares y sus ocupaciones
		ALLOCATE(nQPE(top))
		ALLOCATE(pQPE(top))
		ALLOCATE(nVV(top))
		ALLOCATE(pVV(top))
		ALLOCATE(nMomentum(top))
		ALLOCATE(pMomentum(top))

		! Alamcenar las energias de cuasiparticulas y sus ocupaciones
		num = 1
		DO a = 0, NN
			la = L(a)
			ja = J(a)
			d = ((N_0 - la) / 2) + 1
			DO s1 = d + 1, d + d
				num = num + 1
				sumvvn = 0.0
				sumvvp = 0.0
				IF (num > top) GOTO 1 ! Fin 
				nQPE(num) = diagonal%QuasiParticleEnergies(NEUTRON, a)%value(s1)
				pQPE(num) = diagonal%QuasiParticleEnergies(PROTON, a)%value(s1)
				nMomentum(num) = a
				pMomentum(num) = a
				nIndx(num) = num
				pIndx(num) = num
				DO sa = 1, d
					sumvvn = sumvvn + (diagonal%UV(NEUTRON, a)%value(sa + d, s1) ** 2)
					sumvvp = sumvvp + (diagonal%UV(PROTON, a)%value(sa + d, s1) ** 2)
				END DO

				IF ((diagonal%consistency%density%nucleus%is_blocking(0)) .AND. &
					(a .EQ. diagonal%consistency%density%nucleus%ia(0)) .AND. &
					(s1 .EQ. (d + diagonal%consistency%density%nucleus%mu0(0)))) THEN
					PRINT *, "Se pone la correccin de bloqueo de protones"
					DO sa = 1, d
						sumvvp = sumvvp + ((diagonal%UV(PROTON, a)%value(sa, s1) ** 2) &
							- (diagonal%UV(PROTON, a)%value(sa + d, s1) ** 2)) / (ja + 1.0)
					END DO
				END IF
!A				IF ( Nbl && a == ibln && s1 == mu0n ) 
!A					DO sa = 1, d
!A						sumvvn = sumvvn + ((diagonal%UV(NEUTRON, a)%value(sa, s1) ** 2) - (diagonal%UV(NEUTRON, a)%value(sa + d, s1) ** 2)) / (ja + 1.0)
				nVV(num) = sumvvn
				pVV(num) = sumvvp
			END DO
		END DO

		! Ordenarlas en orden creciente reordenando
		! los indices de momento angular
1		CALL indexx_real8(top, nVV, nIndx)
		CALL indexx_real8(top, pVV, pIndx)
		PRINT "(A14,A10,A12,A5,A10)", "EQP NEUT", "V2", "", "V2", "EQP PROT"
		DO num = top, 1, -1
			an = nMomentum(nIndx(num))
			ap = pMomentum(pIndx(num))
			cn = spectr((an + 1) / 2)                       
			cp = spectr((ap + 1) / 2)
			jn = J(an)
			jp = J(ap)
			PRINT "(F14.4,F10.4,A1,I2,A5,I2,F6.4,F10.4)", &
				nQPE(nIndx(num)), nVV(nIndx(num)), cn, jn, cp, jp, pVV(pIndx(num)), pQPE(pIndx(num))
		END DO
		PRINT *, "Lineas = ", top

		DEALLOCATE(nIndx)
		DEALLOCATE(pIndx)
		DEALLOCATE(nQPE)
		DEALLOCATE(pQPE)
		DEALLOCATE(nVV)
		DEALLOCATE(pVV)
		DEALLOCATE(nMomentum)
		DEALLOCATE(pMomentum)
		RETURN
	END SUBROUTINE DiagonalizationMethod_show_QuasiParticleEnergies

	SUBROUTINE DiagonalizationMethod_del(diagonal)
		TYPE (DiagonalizationMethod), INTENT(INOUT) :: diagonal

		INTEGER ta, a, max_a

		max_a = 2 * N_0
		DO ta = 0, 1
			DO a = 0, max_a
				DEALLOCATE(diagonal%QuasiParticleEnergies(ta, a)%value)
				DEALLOCATE(diagonal%UV(ta, a)%value)
			END DO
		END DO
		DEALLOCATE(diagonal%QuasiParticleEnergies)
		DEALLOCATE(diagonal%UV)

		CALL SelfConsistencyMethod_del(diagonal%consistency)
		CALL R1R1Function_del(diagonal%func)
		CALL SymGenDensity_del(diagonal%S)
		CALL SymGenDensity_del(diagonal%iterated)
		RETURN
	END SUBROUTINE DiagonalizationMethod_del

	SUBROUTINE WaveFunction_new_SymDensity(wave_func, density, tolerance)
		TYPE (WaveFunction), INTENT(INOUT) :: wave_func
		TYPE (SymDensity), INTENT(INOUT) :: density
		DOUBLE PRECISION, INTENT(IN) :: tolerance

		TYPE (DiagonalizationMethod) evolv

		CALL Nucleus_new_Nucleus(wave_func%nucleus, density%nucleus)
		CALL DiagonalizationMethod_new(evolv, density)
		CALL DiagonalizationMethod_goto_SelfConsistency(evolv, tolerance)
		wave_func = DiagonalizationMethod_get_WaveFunction(evolv)
		RETURN
	END SUBROUTINE WaveFunction_new_SymDensity

END MODULE diagmeth
MODULE eigenval

CONTAINS

	! A = Matriz simtrica
	! D = Matriz diagonal
	! Z = Matriz
	SUBROUTINE EigenValues(NM, N, A, D, Z)
		INTEGER, INTENT(IN) :: NM, N
		DOUBLE PRECISION, DIMENSION(:, :), INTENT(IN) :: A
		DOUBLE PRECISION, DIMENSION(:), INTENT(INOUT) :: D
		DOUBLE PRECISION, DIMENSION(:, :), INTENT(INOUT) :: Z

		! E = Matriz diagonal
		DOUBLE PRECISION, DIMENSION(NM, N) :: E
		INTEGER IERR

		CALL TRED2(NM, N, A, D, E, Z)
		CALL TQL2(NM, N, D, E, Z, IERR)
		IF (IERR .NE. 0) STOP "ERROR: EigenValues"
		RETURN
	END SUBROUTINE EigenValues

      SUBROUTINE TQL2(NM,N,D,E,Z,IER)
!-------------------------------------------------------------------------
!     QL METHOD TO DETERMINE THE EIGENVALUES AND EIGENVECTORS OF:
!
!       1)  A SYMMETRIC TRIDIAGONAL MATRIX.
!       2)  A FULL SYMMETRIC MATRIX AFTER A PREVIOUS CALL TO TRED2.
!
!     CALLING MODE:
!               CALL TQL2(NM,N,D,E,Z,IER)
!     INPUTSS:
!     NM  (I4)  1ST DIMENSION OF MATRICES A AND Z IN CALLING PROGRAM
!     N   (I4)  SIZE OF Z
!     D  (R*8)  MAIN DIAGONAL (N) OF THE TRIDIAGONAL MATRIX
!     E  (R*8)  SUB-DIAGONAL (N) OF THE TRIDIAGONAL MATRIX
!     Z  (R*8)  TABLE (NM,N) STORING THE UNITY MATRIX IF THE TRIDIAGONAL
!               MATRIX IS DEFINED BY D AND E, CASE #1.
!               FOR CASE #2, IT CONTAINS THE ELEMENTS OF THE TRANSFORMATION
!               MATRIX AFTER A CALL TO TRED2.
!     OUTPUTS:
!     D  (R*8)  EIGENVALUES
!     Z  (R*8)  EIGENVECTORS
!     IER (I4)  ERROR CODE = 0,  CONVERGENCE OK.
!                          = L,  NO CONVERGENCE FOR THE Lth EIGENVALUE
!
!     REFERENCE:
!     J.H.WILKINSON,-C.REINSCH,R.S.MARTIN
!     HANDBOOK FOR AUTOMATIC COMPUTATION, VOL.2, LINEAR ALGEBRA
!     SPRINGER-VERLAG 1971.
!-------------------------------------------------------------------------
      INTEGER I,J,K,L,M,N,NM,JM,IER
      REAL *8 D(N),E(N),Z(NM,N),B,C,F,G,H,P,R,S,EPS,EPS1
      DATA EPS /0.D0/,JM /30/
      IER = 0
      IF (N.EQ.1) GO TO 38
!
!     MACHINE EPSILON
!
      IF (EPS.NE.0.D0) GO TO 12
      EPS = 1.D0
   10 EPS = EPS/2.D0
      EPS1 = 1.D0+EPS
      IF (EPS1.GT.1.D0) GO TO 10
!
   12 DO 14 I = 2,N
   14 E(I-1) = E(I)
      E(N) = 0.D0
      F = 0.D0
      B = 0.D0
!
      DO 28 L = 1,N
      J = 0
      H = EPS*(ABS(D(L))+ABS(E(L)))
      IF (B.LT.H) B = H
!
!     SEEK SMALLEST ELEMENT OF SUBDIAGONAL
!
      DO 16 M = L,N
      IF (ABS(E(M)).LE.B) GO TO 18
   16 CONTINUE
   18 IF (M.EQ.L) GO TO 26

!     START ITERATION

   20 IF (J.EQ.JM) GO TO 36
      J = J+1

!     SHIFT

      G = D(L)
      P = (D(L+1)-G)/(2.D0*E(L))
      R = SQRT(P*P+1.D0)
      D(L) = E(L)/(P+SIGN(R,P))
      H = G-D(L)
      DO 22 I = L+1,N
   22 D(I) = D(I)-H
      F = F+H

!     QL TRANSFORMATION

      P = D(M)
      C = 1.D0
      S = 0.D0
      DO 24 I = M-1,L,-1
      G = C*E(I)
      H = C*P
      IF (ABS(P).GE.ABS(E(I))) THEN
      C = E(I)/P
      R = SQRT(C*C+1.D0)
      E(I+1) = S*P*R
      S = C/R
      C = 1.D0/R
      ELSE
      C = P/E(I)
      R = SQRT(C*C+1.D0)
      E(I+1) = S*E(I)*R
      S = 1.D0/R
      C = C*S
      ENDIF
      P = C*D(I)-S*G
      D(I+1) = H+S*(C*G+S*D(I))

!     ELEMENTS OF EIGENVECTORS

      DO 24 K = 1,N
      H = Z(K,I+1)
      Z(K,I+1) = S*Z(K,I)+C*H
      Z(K,I) = Z(K,I)*C-S*H
   24 CONTINUE
      E(L) = S*P
      D(L) = C*P
      IF (ABS(E(L)).GT.B) GO TO 20

!     CONVERGENCE

   26 D(L) = D(L)+F
   28 CONTINUE

!     SORT EIGENVALUES AND EIGENVECTORS
!     IN ASVENDING ORDER

      DO 34 L = 2,N
      I = L-1
      K = I
      P = D(I)
      DO 30 J = L,N
      IF (D(J).GE.P) GO TO 30
      K = J
      P = D(J)
   30 CONTINUE
      IF (K.EQ.I) GO TO 34
      D(K) = D(I)
      D(I) = P
      DO 32 J = 1,N
      P = Z(J,I)
      Z(J,I) = Z(J,K)
   32 Z(J,K) = P
   34 CONTINUE
      GO TO 38

!     NO CONVERGENCE

   36 IER = L
   38 RETURN
      END SUBROUTINE TQL2

      SUBROUTINE TRED2(NM,N,A,D,E,Z)
!---------------------------------------------------------------------------
!     TRIDIAGONALIZATION OF A SYMMETRIC MATRIX BY ORTHOGONAL TRANSFORMATIONS
!     (ALGORITHM OF HOUSEHOLDER)
!     CALLING MODE:
!               CALL TRED2(NM,N,A,D,E,Z)
!     INPUTS:
!     NM  (I4)  1ST DIMENSION OF MATRICES A AND Z IN CALLING PROGRAM
!     N   (I4)  SIZE OF A
!     A  (R*8)  TABLE(NM,N) STORING THE COEFFICIENTS OF SYMMETRIC A MATRIX
!               (LOWER HALF), A IS NOT DESTROYED DURING THE PROCESS
!               IF Z MATRIX HAS NOT THE SAME ADDRESS.
!     OUTPUTS:
!     D  (R*8)  MAIN DIAGONAL (N) OF REDUCED TRIDIAGONAL MATRIX
!     E  (R*8)  SUB-DIAGONAL (N) OF REDUCED TRIDIAGONAL MATRIX
!     Z  (R*8)  TABLE (NM,N) STORING THE ELEMENTS OF THE ORTHOGONAL 
!               TRANSFORMATION MATRIX.
!     REFERENCE:
!     J.H.WILKINSON,-C.REINSCH,R.S.MARTIN
!     HANDBOOK FOR AUTOMATIC COMPUTATION, VOL.2, LINEAR ALGEBRA
!     SPRINGER-VERLAG 1971.
!-----------------------------------------------------------------------
      INTEGER I,J,K,L,N,NM
      REAL *8 A(NM,N),D(N),E(N),Z(NM,N),F,G,H,HH,SCALE

!     LOWER HALF OF A PUT INTO Z

      DO 10 I = 1,N
      DO 10 J = 1,I
   10 Z(I,J) = A(I,J)
      IF (N.EQ.1) GO TO 32

!     N-2 STAGE OF TRANSFORMATION

      DO 30 I = N,2,-1
      L = I-1
      H = 0.

!     CONDITIONNING BY NORM OF A

      SCALE = 0.
      IF (L.LT.2) GO TO 14
      DO 12 K = 1,L
   12 SCALE = SCALE+ABS(Z(I,K))
      IF (SCALE.NE.0.) GO TO 16

   14 E(I) = Z(I,L)
      GO TO 28

   16 DO 18 K = 1,L
      Z(I,K) = Z(I,K)/SCALE
      H = H+Z(I,K)*Z(I,K)
   18 CONTINUE

      F = Z(I,L)
      G = -SIGN(SQRT(H),F)
      E(I) = SCALE*G
      H = H-F*G
      Z(I,L) = F-G
      F = 0.
      DO 24 J = 1,L
      Z(J,I) = Z(I,J)/H
      G = 0.

!     ELEMENT OF A*U
      DO 20 K = 1,J
   20 G = G+Z(J,K)*Z(I,K)
      IF (L.GE.J+1) THEN
      DO 22 K = J+1,L
   22 G = G+Z(K,J)*Z(I,K)

!     ELEMENT OF P = A*U/H

      END IF
      E(J) = G/H
      F = F+E(J)*Z(I,J)
   24 CONTINUE

!     ELEMENT OF K

      HH = F/(H+H)

!     REDUCED FORM OF A

      DO 26 J = 1,L
      F = Z(I,J)
      G = E(J)-HH*F
      E(J) = G
      DO 26 K = 1,J
      Z(J,K) = Z(J,K)-F*E(K)-G*Z(I,K)
   26 CONTINUE
!
   28 D(I) = H
   30 CONTINUE

!     END OF TRANSFORMATION

   32 D(1) = 0.
      E(1) = 0.

!     ACCUMULATE TRANSFORMATION MATRICES IN Z

      DO 40 I = 1,N
      L = I-1
      IF (D(I).NE.0.) THEN
      DO 36 J = 1,L
      G = 0.
      DO 34 K = 1,L
   34 G = G+Z(I,K)*Z(K,J)
      DO 36 K = 1,L
      Z(K,J) = Z(K,J)-G*Z(K,I)
   36 CONTINUE
      END IF
      D(I) = Z(I,I)
      Z(I,I) = 1.
      IF (L.LT.1) GO TO 40
      DO 38 J = 1,L
      Z(I,J) = 0.
      Z(J,I) = 0.
   38 CONTINUE
   40 CONTINUE

      RETURN
      END SUBROUTINE TRED2

END MODULE eigenval
 MODULE gauss

	USE math

	IMPLICIT NONE

	TYPE GaussQuadrature
		DOUBLE PRECISION, DIMENSION(:), POINTER :: x, w
		INTEGER n
	END TYPE

	TYPE GaussLaguerreQuadrature
		TYPE (GaussQuadrature) gauss
		DOUBLE PRECISION alf
	END TYPE

 CONTAINS

	SUBROUTINE GaussQuadrature_new(gauss, n)
		TYPE (GaussQuadrature), INTENT(INOUT) :: gauss
		INTEGER, INTENT(IN) :: n

		gauss%n = n
		
		ALLOCATE(gauss%x(0:n))
		IF (.NOT. ASSOCIATED(gauss%x)) STOP "Unable to allocate memory"
		
		ALLOCATE(gauss%w(0:n)) !TODO El tamao mximo es n?
		IF (.NOT. ASSOCIATED(gauss%w)) STOP "Unable to allocate memory"
		
		RETURN
	END SUBROUTINE GaussQuadrature_new

	SUBROUTINE GaussLaguerreQuadrature_new(laguerre, n, alf)
		TYPE (GaussLaguerreQuadrature), INTENT(INOUT) :: laguerre
		INTEGER, INTENT(IN) :: n
		DOUBLE PRECISION, INTENT(IN) :: alf

		CALL GaussQuadrature_new(laguerre%gauss, n)
		
		laguerre%alf = alf
		
		CALL gaulag2(laguerre%gauss%x, laguerre%gauss%w, n, alf)
		
		RETURN
	END SUBROUTINE GaussLaguerreQuadrature_new

	! Given alf, the parameter alf of the Laguerre polynomials,
	! this routine returns arrays x(1..n)  and w(1..n)
	! containing the abscissas and weights
	! of the n-point Gauss-Laguerre quadrature formula.
	! The smallest abscissa is returned in x(1), the largest in x(n).
	SUBROUTINE gaulag2(x, w, n, alf)
		DOUBLE PRECISION, DIMENSION(0:), INTENT(INOUT) :: x, w
		INTEGER, INTENT(IN) :: n
		DOUBLE PRECISION, INTENT(IN) :: alf

		INTEGER kind2, kpts
		DOUBLE PRECISION bet
		DOUBLE PRECISION, DIMENSION(1:2) :: endpts
		DATA endpts /0.0, 0.0/
		DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE :: wksp

		ALLOCATE(wksp(1:n))
		kind2 = 6
		bet  = 0.0
		kpts = 0
		CALL gaussq(kind2, n, alf, bet, kpts, endpts, wksp, x, w)
		RETURN
	END SUBROUTINE

	SUBROUTINE gaussq(kind2, n, alf, bet, kpts, endpts, b, t, w)
		INTEGER, INTENT(IN) :: kind2, n, kpts
		DOUBLE PRECISION, INTENT(IN) :: alf, bet
		DOUBLE PRECISION, DIMENSION(1:2), INTENT(IN) :: endpts
		DOUBLE PRECISION, DIMENSION(:), INTENT(INOUT) :: b
		DOUBLE PRECISION, DIMENSION(0:), INTENT(INOUT) :: t, w

		INTEGER ierr, i
		DOUBLE PRECISION muzero, gam, t1

		CALL clase(kind2, n, alf, bet, b, t, muzero)
		
		IF (kpts .NE. 0) THEN
			IF (kpts .EQ. 2) THEN
				gam = gbslve(endpts(1), n, t, b)
				t1 = DBLE(endpts(1) - endpts(2)) / (gbslve(endpts(2), n, t, b) - gam)
				b(n - 1) = SQRT(t1)
				t(n) = DBLE(endpts(1)) + gam * t1
			ELSE ! Computing 2nd power
				t(n) = gbslve(endpts(1), n, t, b) * (b(n - 1) ** 2.0) + DBLE(endpts(1))
			END IF
		END IF

		w(1) = 1.0
		DO i = 2, n
			w(i) = 0.0
		END DO

		CALL gbtql2(n, t, b, w, ierr)
		
		DO i = 1, n
			w(i) = muzero * w(i) * w(i)
		END DO
		
		RETURN
	END SUBROUTINE gaussq

	SUBROUTINE clase(kind2, n, alf, bet, b, a, muzero)
		INTEGER, INTENT(IN) :: kind2, n
		DOUBLE PRECISION, INTENT(IN) :: alf, bet
		DOUBLE PRECISION, DIMENSION(:), INTENT(INOUT) :: b
		DOUBLE PRECISION, DIMENSION(0:), INTENT(INOUT) :: a
		DOUBLE PRECISION, INTENT(INOUT) :: muzero

		INTEGER i
		DOUBLE PRECISION ab, a2b2, abi

		SELECT CASE (kind2)
		CASE (1)
			muzero = 2.0
			DO i = 1, n - 1
				a(i) = 0.0
				b(i) = i / SQRT(i * 4.0 * i - 1.0)
			END DO
			a(n) = 0.0
		CASE (2)
			muzero = PI
			DO i = 1, n - 1
				a(i) = 0.0
				b(i) = 0.5
			END DO
			b(1) = SQRT(0.5)
			a(n) = 0.0
		CASE (3)
			muzero = PI / 2.0
			DO i = 1, n - 1
				a(i) = 0.0
				b(i) = 0.5
			END DO
			a(n) = 0.0
		CASE (4)
			muzero = SQRT(PI)
			DO i = 1, n - 1
				a(i) = 0.0
				b(i) = SQRT(0.5 * i)
			END DO
			a(n) = 0.0
		CASE (5)
			ab = alf + bet
			abi = ab + 2.0
			muzero = (2.0 ** (ab + 1.0)) * dgamma(alf + 1.0) * dgamma(bet + 1.0) / dgamma(ab + 2.0)
			a(1) = (bet - alf) / abi
			b(1) = SQRT((alf + 1.0) * 4.0 * (bet + 1.0) / ((abi + 1.0) * abi * abi))

			a2b2 = bet * bet - alf * alf
			DO i = 2, n - 1
				abi = i * 2.0 + ab
				a(i) = a2b2 / ((abi - 2.) * abi)
				b(i) = SQRT(i * 4.0 * (i + alf) * (i + bet) * (i + ab) / ((abi * abi - 1.0) * abi * abi))
			END DO
			abi = n * 2.0 + ab
			a(n) = a2b2 / ((abi - 2.0) * abi)
		CASE (6)
			muzero = dgamma(alf + 1.0)
			DO i = 1, n - 1
				a(i) = 2.0 * i - 1.0 + alf
				b(i) = SQRT((alf + i) * i)
			END DO
			a(n) = n * 2.0 - 1.0 + alf
		END SELECT
		RETURN
	END SUBROUTINE clase

	FUNCTION gbslve(shift, n, a, b)
		DOUBLE PRECISION gbslve
		DOUBLE PRECISION, INTENT(IN) :: shift
		INTEGER, INTENT(IN) :: n
		DOUBLE PRECISION, DIMENSION(0:), INTENT(IN) :: a
		DOUBLE PRECISION, DIMENSION(:), INTENT(IN) :: b

		INTEGER i
		DOUBLE PRECISION alpha

		alpha = a(1) - shift
		DO i = 2, n - 1 ! Computing 2nd power
			alpha = a(i) - shift - (b(i - 1) ** 2.0) / alpha
		END DO
		gbslve = 1.0 / alpha
		RETURN
	END FUNCTION gbslve

	SUBROUTINE gbtql2(n, d, e, z, ierr)
		INTEGER, INTENT(IN) :: n
		DOUBLE PRECISION, DIMENSION(:), INTENT(INOUT) :: e
		DOUBLE PRECISION, DIMENSION(0:), INTENT(INOUT) :: d, z
		INTEGER, INTENT(INOUT) :: ierr

		DOUBLE PRECISION b, c, f, g, p, r, s
		INTEGER i, ii, j, k, l, m, m2

		ierr = 0
		IF (n .EQ. 1) RETURN
		
		e(n) = 0.0
		
		DO l = 1, n
		
		   j = 0
		   
!bucle:		   DO 

		   DO m2 = l, n
		   
		      IF (m2 .EQ. n) THEN
			  m = m2
			  EXIT
		      END IF
		      
		      IF ((m2 .LT. n) .AND. (ABS(e(m2)) .LE. (EPS * (ABS(d(m2)) + ABS(d(m2 + 1)))))) THEN
			   m = m2
			   EXIT
		      END IF
		      
		   END DO
		      
		   DO WHILE (m .lt. l)
		      p = d(l)
				
		     !IF (m .EQ. l) EXIT bucle

		     IF (j .EQ. 30) THEN
			 ierr = 1
			 RETURN
		     END IF
				
		     j = j + 1
		     g = (d(l + 1) - p) / (e(l) * 2.0)
		     r = SQRT(g * g + 1.0)
		     g = d(m) - p + e(l) / (g + SIGN(r, g))
		     s = 1.0
		     c = 1.0
		     p = 0.0
			 
		     DO ii = 1, m - l
			 
			i = m - ii
			f = s * e(i)
			b = c * e(i)
			    
			IF (ABS(f) .LT. ABS(g)) THEN
			    s = f / g
			    r = SQRT(s * s + 1.0)
			    e(i + 1) = g * r
			    c = 1.0 / r
			    s = s * c
			ELSE
		            c = g / f
			    r = SQRT(c * c + 1.0)
			    e(i + 1) = f * r
			    s = 1.0 / r
			    c = c * s
			END IF
					
			g = d(i + 1) - p
					
			r = (d(i) - g) * s + c * 2.0 * b
			p = s * r
			d(i + 1) = g + p
			g = c * r - b
			f = z(i + 1)
			z(i + 1) = s * z(i) + c * f
			z(i    ) = c * z(i) - s * f
			    
	 	     END DO
		     
		     d(l) = d(l) - p
		     e(l) = g
		     e(m) = 0.0
		     
!		   END DO bucle
		   END DO
		   
		END DO

		DO ii = 2, n
		
		   i = ii - 1
		   k = i
		   p = d(i)
			
	  	   DO j = ii, n
		   
		      IF (d(j) .GE. p) CYCLE
		      
		      k = j
		      p = d(j)
		      
		   END DO
			
		   IF (k .EQ. i) CYCLE
			  
		   d(k) = d(i)
		   d(i) = p
		   p = z(i)
		   z(i) = z(k)
		   z(k) = p
		   
		 END DO
		 
		RETURN
	END SUBROUTINE gbtql2

	FUNCTION dgamma(z)
		DOUBLE PRECISION dgamma
		DOUBLE PRECISION, INTENT(IN) :: z

		DOUBLE PRECISION, DIMENSION(0:17) :: a
		DATA a /1.0, &
			 0.4227843350984678, &
			 0.4118403304263672, &
			 0.0815769192502609, &
			 0.0742490106800904, &
			-2.669810333484e-4, &
			 0.0111540360240344, &
			-0.0028525821446197, &
			 0.0021036287024598, &
			-9.184843690991e-4, &
 			 4.874227944768e-4, &
			-2.347204018919e-4, &
			 1.115339519666e-4, &
 			-4.78747983834e-5, &
			 1.75102727179e-5, &
			-4.9203750904e-6, &
			 9.199156407e-7, &
			-8.39940496e-8/

		INTEGER k
		DOUBLE PRECISION p, t

		IF (z .LE. 1.0) THEN
			t = z
		ELSE IF (z .LE. 2.0) THEN
			t = z - 1.0
		ELSE
			t = z - 2.0
		END IF

		p = a(17)
		DO k = 1, 17
			p = t * p + a(17 - k)
		END DO

		IF (z .GT. 2.0) THEN
			dgamma = p
		ELSE IF (z .GT. 1.0) THEN
			dgamma = p / z
		ELSE
			dgamma = p / (z * (z + 1.0))
		END IF
		RETURN
	END FUNCTION dgamma

END MODULE gauss
 MODULE genden

	USE input
	USE math
!	USE matrix

	IMPLICIT NONE

	TYPE Matrix2D
		DOUBLE PRECISION, DIMENSION(:, :), POINTER :: value
	END TYPE

	TYPE GenDensityHF
		TYPE (Matrix2D), DIMENSION(:, :), POINTER :: rho
	END TYPE

	TYPE GenDensity
		TYPE (GenDensityHF) rho, kap
	END TYPE

 CONTAINS

	SUBROUTINE GenDensity_new(density)
		TYPE (GenDensity), INTENT(INOUT) :: density

		CALL GenDensityHF_new(density%rho)
		CALL GenDensityHF_new(density%kap)
		RETURN
	END SUBROUTINE GenDensity_new

	SUBROUTINE GenDensityHF_new(hf)
		TYPE (GenDensityHF), INTENT(INOUT) :: hf

		INTEGER ta, a, d

		ALLOCATE(hf%rho(0:1, 0:(2 * N_0)))
		DO ta = 0, 1
			DO a = 0, 2 * N_0
				d = DIM(a)
				ALLOCATE(hf%rho(ta, a)%value(d, d))
				! Comprobamos que se ha reservado correctamente la memoria
				IF (.NOT. ASSOCIATED(hf%rho(ta, a)%value)) STOP "Unable to allocate memory"
			END DO
		END DO
		RETURN
	END SUBROUTINE GenDensityHF_new

	SUBROUTINE GenDensityHF_del(hf)
		TYPE (GenDensityHF), INTENT(INOUT) :: hf

		INTEGER ta, a

		DO ta = 0, 1
			DO a = 0, 2 * N_0
				DEALLOCATE(hf%rho(ta, a)%value)
			END DO
		END DO
		DEALLOCATE(hf%rho)
		RETURN
	END SUBROUTINE GenDensityHF_del

END MODULE genden
 MODULE global

	USE input
	USE lgfactor
	USE symd3t
	USE symtalm
	USE gauss
	USE angmom

	IMPLICIT NONE

	! We define the flags that will identify each isospin throughout the program
	
	INTEGER, PARAMETER :: PROTON  = 0
	INTEGER, PARAMETER :: NEUTRON = 1
        INTEGER, PARAMETER :: Isospin = 1

	INTEGER A
	INTEGER NLag

	! The list of spherical magic numbers
	
	INTEGER, DIMENSION(8) :: MagicNumber
	DATA MagicNumber/2, 20, 28, 50, 82, 126, 184, 256/

	! m is equal to mc/(hbar*c)
	
	DOUBLE PRECISION, DIMENSION(0:1), PARAMETER :: m = (0.024111868, 0.024111868)

	DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE :: sq, sq2

	DOUBLE PRECISION, PARAMETER :: x0 = 1.0

	! Parameters of the Gogny force
	DOUBLE PRECISION, DIMENSION(0:1, 3) :: Gogny_W
	DOUBLE PRECISION, DIMENSION(0:1, 3) :: Gogny_B
	DOUBLE PRECISION, DIMENSION(0:1, 3) :: Gogny_H
	DOUBLE PRECISION, DIMENSION(0:1, 3) :: Gogny_M

	! GOGNYF = DSA1
	DATA Gogny_W / -1720.30,  103.639, -402.40, -21.30, -402.40, -21.30 /
	DATA Gogny_B /  1300.00, -163.483, -100.00, -11.77, -100.00, -11.77 /
	DATA Gogny_H / -1813.53,  162.812, -496.20,  37.27, -496.20,  37.27 /
	DATA Gogny_M /  1397.60, -223.934,  -23.56, -68.81,  -23.56, -68.81 /

	DOUBLE PRECISION, DIMENSION(3) :: Gogny_W0
	DATA Gogny_W0 / 130.0, 115.0, 130.0 / ! DSA1, D1, D1_PRIMA

	DOUBLE PRECISION, DIMENSION(3) :: Gogny_t0
	DATA Gogny_t0 / 1390.6, 1350.0, 1350.0 / ! DSA1, D1, D1_PRIMA

	TYPE (SymD3Tensor) EkField, R2Field
	TYPE (GaussLaguerreQuadrature) GaussLQ

 CONTAINS

	SUBROUTINE Global_new

		INTEGER max_1, max_2

		! Reading the input parameters
		CALL Input_read
		
		! Printing the parameters of the force
		PRINT "(/A)", "Parameters of the Gogny force:"
		PRINT "(A,F8.2)", "W(0) = ", Gogny_W(0, Gogny)
		PRINT "(A,F8.2)", "W(1) = ", Gogny_W(1, Gogny)
		PRINT "(A,F8.2)", "B(0) = ", Gogny_B(0, Gogny)
		PRINT "(A,F8.2)", "B(1) = ", Gogny_B(1, Gogny)
		PRINT "(A,F8.2)", "H(0) = ", Gogny_H(0, Gogny)
		PRINT "(A,F8.2)", "H(1) = ", Gogny_H(1, Gogny)
		PRINT "(A,F8.2)", "M(0) = ", Gogny_M(0, Gogny)
		PRINT "(A,F8.2)", "M(1) = ", Gogny_M(1, Gogny)
		PRINT "(A,F8.2)", "W0 = ", Gogny_W0(Gogny)
		PRINT "(A,F8.2)", "t0 = ", Gogny_t0(Gogny)
		
		NLag = MIN(N_0 * 32, 156) ! NLag = UMIN(N_0 << 5, 156)

		!max_1 = 4 * N_0
		!max_2 = max_1 + 1
		
		max_1 = 100
		max_2 = 2000

!TODO El autor lo implementa, pero no se utiliza en ninguna parte del cdigo
!		CALL LogFactorials_new(max_2)
!		CALL LogSemiFactorials_new(max_2)

                ! Defined in module "lgfactor.f90"
		CALL DDLogFactorials_new(max_2)
		CALL DDLogSemiFactorials_new(max_2)

                ! Defined here...
		CALL SquareRoot_new(max_1)
		CALL SemiSquareRoot_new(max_1)
		
		CALL Global_start
		
                ! Defined in module "symtalm.f90"
		CALL SymCoefficientB_new
		CALL SymKumar_new
		
		CALL GaussLaguerreQuadrature_new(GaussLQ, NLag, DBLE(0.5))
		
                ! Defined in module "angmom.f90"
		CALL ThreeJSymbols_new
		
		RETURN

	CONTAINS

                ! Subroutine storing in a vector of size imax the square root of 
		! all integers from 1 to imax: sqrt(i)

		SUBROUTINE SquareRoot_new(imax)
			INTEGER, INTENT(IN) :: imax

			INTEGER i

			ALLOCATE(sq(0:imax))
			sq(0) = 0.0
			DO i = 1, imax
				sq(i) = SQRT(i + 0.0)
			END DO
			RETURN
		END SUBROUTINE SquareRoot_new

                ! Subroutine storing in a vector of size imax the square root of 
		! all integers from 1 to imax, plus one half: sqrt(i+0.5)

		SUBROUTINE SemiSquareRoot_new(imax)
			INTEGER, INTENT(IN) :: imax

			INTEGER i

			ALLOCATE(sq2(0:imax))
			sq2(0) = 1.0/SQRT(2.0)
			DO i = 1, imax
				sq2(i) = SQRT(i + 0.5)
			END DO
			RETURN
		END SUBROUTINE SemiSquareRoot_new

	END SUBROUTINE Global_new

         !
	 !  
	 !

	SUBROUTINE Global_start

		INTEGER ta, la, na, nc
		DOUBLE PRECISION factor
		INTEGER d

		CHARACTER(64) filename
		INTEGER, PARAMETER :: file_desc = 6
		INTEGER file_error

	        !  Creating two new pointers to the 3D tensors EkField and R2Field and allocating 
		!  memory for them
		
		CALL SymD3Tensor_new(EkField)
		CALL SymD3Tensor_new(R2Field)
		
	        !  Filling in these two pointers with the ONE-BODY kinetic energy and square radius
		!  matrix elements. We don't calculate <na nb | T | nc nd> here, but only things like 
		!  <n'|T|n>. Same with the radius
		
		DO ta = 0, 1  ! Loop over isospin
		
			factor = 1.0 / (2.0 * m(ta))
			
			DO la = 0, N_0  ! Loop over "bra" orbital angular momentum
			
				d = ((N_0 - la) / 2) + 1
				
				DO na = 1, d  ! Sum over "bra" main quantum number
					EkField%d3tensor(la)%d2(na, na) = factor * nabla2(na - 1, na - 1, la)
					R2Field%d3tensor(la)%d2(na, na) = r2_cuton(na - 1, na - 1, la)
				END DO
				
				DO na = 1, d - 1
				
					EkField%d3tensor(la)%d2(na + 1, na) = factor * nabla2(na - 1, na, la)
					R2Field%d3tensor(la)%d2(na + 1, na) = r2_cuton(na - 1, na, la)
					
					DO nc = na + 2, d ! Loop over "ket" main quantum number
						EkField%d3tensor(la)%d2(nc, na) = 0.0
						R2Field%d3tensor(la)%d2(nc, na) = 0.0
					END DO
					
				END DO
				
			END DO
		END DO

                 ! Writing output: the one-body kinetic energy

		IF (N_0 < 10) THEN
			WRITE(filename, "(A,I1,A)") "data/Ek", N_0, ".txt"
		ELSE
			WRITE(filename, "(A,I2,A)") "data/Ek", N_0, ".txt"
		END IF

		OPEN(file_desc, FILE=filename, ACTION="WRITE", IOSTAT=file_error)
		IF (file_error .NE. 0) THEN
			PRINT *, "*** Attention: Impossible to write the results in file ", filename
		ELSE
			DO la = 0, N_0
				d = ((N_0 - la) / 2) + 1
				DO na = 1, d
					DO nc = 1, na
						WRITE (file_desc, "(I3,I3,I3,E)", IOSTAT=file_error) &
							la, na, nc, EkField%d3tensor(la)%d2(na, nc)
					END DO
				END DO
			END DO
			CLOSE(file_desc)
		END IF

                 ! Writing output: the one-body root mean square radius

		IF (N_0 < 10) THEN
			WRITE(filename, "(A,I1,A)") "data/R2", N_0, ".txt"
		ELSE
			WRITE(filename, "(A,I2,A)") "data/R2", N_0, ".txt"
		END IF

		OPEN(file_desc, FILE=filename, ACTION="WRITE", IOSTAT=file_error)
		IF (file_error .NE. 0) THEN
			PRINT *, "*** Attention:  Impossible to write the results in file ", filename
		ELSE
			DO la = 0, N_0
				d = ((N_0 - la) / 2) + 1
				DO na = 1, d
					DO nc = 1, na
						WRITE (file_desc, "(I3,I3,I3,E)", IOSTAT=file_error) &
							la, na, nc, R2Field%d3tensor(la)%d2(na, nc)
					END DO
				END DO
			END DO
			CLOSE(file_desc)
		END IF
		RETURN

	CONTAINS

                !
		!  Function calculating the matrix elements of the form 
		!           < n'l' | nabla^2 | nl >
		!
		!  Refs: Sec. 5.1.1., Page 45, 
		!        Appendix C, Page 115
		!

		FUNCTION nabla2(na, nc, la)
			DOUBLE PRECISION nabla2
			INTEGER, INTENT(IN) :: na, nc, la

			IF ((na + 1) .EQ. nc) THEN
				nabla2 = sq(nc) * sq2(nc + la)
			ELSE IF (na .EQ. (nc + 1)) THEN
				nabla2 = sq(na) * sq2(na + la)
			ELSE IF (na .eq. nc) THEN
				nabla2 = (na * 2.0) + la + 1.5
			ELSE
				nabla2 = 0.0
			END IF
			
			RETURN
		END FUNCTION nabla2

                !
		!  Function calculating the matrix elements of the squared radius 
		!           < n'l' | nabla^2 | nl >
		!
		!  Refs: Sec. 5.1.1., Page 45
		!

		FUNCTION r2_cuton(na, nc, la)
			DOUBLE PRECISION r2_cuton
			INTEGER, INTENT(IN) :: na, nc, la

			IF ((na + 1) .eq. nc) THEN
				r2_cuton = - sq(nc) * sq2(nc + la)
			ELSE IF (na .eq. (nc + 1)) THEN
				r2_cuton = - sq(na) * sq2(na + la)
			ELSE IF (na .eq. nc) THEN
				r2_cuton = (na * 2.0) + la + 1.5
			ELSE
				r2_cuton = 0.0
			END IF
			
			RETURN
		END FUNCTION r2_cuton

	END SUBROUTINE Global_start

	SUBROUTINE Global_del
		!TODO
	END SUBROUTINE Global_del

END MODULE global
!---------------------------------------------------------------------!
!                                                                     !
!     RADIAL INTEGRALS: BRINK-BOKER FORCE                             !
!                                                                     !
!---------------------------------------------------------------------!

 MODULE ibb

	USE global
	USE lgfactor
	USE symtalm

	IMPLICIT NONE

	! PI_BrinkBooker = 2.0 * (PI ** 3.0)
	REAL(KIND = 16), PARAMETER :: PI_BB = 62.01255336059964035

 CONTAINS

        !---------------------------------------------------------------------------------!
	! Function giving the radial integral IBB for the Brink-Boeker term in the case   !
	! of the spherical harmonic oscillator basis	  			          !
	! Ref.:
        !---------------------------------------------------------------------------------!

	FUNCTION IBrinkBookerHO(na, la, nb, lb, nc, lc, nd, ld, k, x)
		DOUBLE PRECISION IBrinkBookerHO
		INTEGER, INTENT(IN) :: na, la, nb, lb, nc, lc, nd, ld, k
		DOUBLE PRECISION, INTENT(IN) :: x ! x = mi(i) / b
		INTEGER N1max, N2max, N1min, N2min
		DOUBLE PRECISION d1, d2
		REAL(KIND = 16) sumN1
		INTEGER N1

		N1max = na + nc + ((la + lc - k) / 2)
		N2max = nb + nd + ((lb + ld - k) / 2)
		N1min = MIN_5N(na, la, nc, lc, k)
		N2min = MIN_5N(nb, lb, nd, ld, k)

		! El sumatorio se deberia realizar en el sentido opuesto
		! para ir de menor a mayor en el orden de magnitud de los numeros
		
		d1 = x * x
		d2 = d1 + 2.0
		
		sumN1 = SymKumar_get(na, la, nc, lc, N1max, k) * SumBB(nb, lb, nd, ld, k, N1max, d2)
		
		DO N1 = N1max - 1, N1min, -1
			sumN1 = (SymKumar_get(na, la, nc, lc, N1, k) * SumBB(nb, lb, nd, ld, k, N1, d2)) &
				- (sumN1 * (N1 + N2min + k + 1.5) / (N1 + 1.0) / (N1 + k + 1.5) / d2)
		END DO

		IBrinkBookerHO = PI_BB * PAR(N1min + N2min) &
			* EXP(DDLogSemiFactorials(N1min + N2min + k) &
		            - DDLogFactorials(N1min) &
			    - DDLogSemiFactorials(N1min+ k) &
			    - DDLogFactorials(N2min) &
			    - DDLogSemiFactorials(N2min + k)) &
			* (x ** 3.0) * sumN1 / (d2 ** (N1min + N2min + k + 1.5))
		RETURN

	CONTAINS

       		!-----------------------------------------------------------------------!
		!  Sum over N2 of the c(N2,k) T(nb,lb,nd,ld,N2,k)*Integral(k,N1,)	1
       		!-----------------------------------------------------------------------!

		FUNCTION SumBB(n1, l1, n2, l2, k, M1, y) ! M1 <- N1
			REAL(KIND = 16) SumBB
			INTEGER, INTENT(IN) :: n1, l1, n2, l2, k, M1
			DOUBLE PRECISION, INTENT(IN) :: y

			INTEGER N, Nmin, Nmax

			Nmax = n1 + n2 + ((l1 + l2 - k) / 2)
			Nmin = MIN_5N(n1, l1, n2, l2, k)

			SumBB = SymKumar_get(n1, l1, n2, l2, Nmax, k)
			
			DO N = Nmax - 1, Nmin, -1
				SumBB = - (SumBB * (N + M1 + k + 1.5) / (N + 1.0) / (N + k + 1.5) / y) &
					+ SymKumar_get(n1, l1, n2, l2, N, k)
			END DO
			
			RETURN
		END FUNCTION SumBB

	END FUNCTION IBrinkBookerHO

        !---------------------------------------------------------------------------------!
	! Function giving the radial integral IBB for the Brink-Boeker term in the case   !
	! of a general spherical basis			  			          !
	! Ref.:
        !---------------------------------------------------------------------------------!

	FUNCTION IBrinkBooker(na, la, nb, lb, nc, lc, nd, ld, k, x)
		DOUBLE PRECISION IBrinkBooker
		
		INTEGER, INTENT(IN) :: na, la, nb, lb, nc, lc, nd, ld, k
		DOUBLE PRECISION, INTENT(IN) :: x ! x = mu(i) / b
		
		INTEGER :: s, n
		DOUBLE PRECISION :: epsilo, Pi
		REAL(KIND = 16) SumNew, SumTot
		REAL(KIND = 16) Term1,Term2,Term3
		
		Pi = 4.0*ATAN(1.0)
		
		SumNew = 1000.0
		epsilo = 1.e-15
		Sumtot = 0.0
		
		s = 0
		
                DO WHILE (ABS(SumNew) .GT. epsilo) 
		
		   n = k + 2*s
		
		   Term1 = OneBodyInt(na, la, nc, lc, n, x, s, 1) 
		   Term2 = OneBodyInt(nb, lb, nd, ld, n, x, k+s, 2)
		   Term3 = EXP( -2.0*n*LOG(x))
		   
		   SumNew = Term1 * Term2 * Term3
		   
		   SumTot = SumTot + SumNew
		   
		   s = s + 1
		
		END DO

		IBrinkBooker = 2.0*Pi*SQRT(Pi) * SumTot

		RETURN

	CONTAINS

		FUNCTION OneBodyInt(n1, l1, n2, l2, k, x, N, flag)
			DOUBLE PRECISION OneBodyInt
			
			INTEGER, INTENT(IN) :: n1, l1, n2, l2, k, N, flag
			
			DOUBLE PRECISION, INTENT(IN) :: x
			DOUBLE PRECISION, ALLOCATABLE :: Integrand(:)
			DOUBLE PRECISION :: Result, Radius
			
			REAL(KIND = 16) :: Factor
			
			INTEGER :: Ipoint, IndexBra, IndexKet
	
		        IndexBra = IndexVecNL(n1, l1)
		        IndexKet = IndexVecNL(n2, l2)
			
			IF (IndexBra .EQ. 0 .OR. IndexKet .EQ. 0) THEN
			    OneBodyInt = 0.0
			    RETURN
			END IF
			
			IF (flag .EQ. 1) Factor = EXP( -DDLogFactorials(N))
			IF (flag .EQ. 2) Factor = EXP( -DDLogSemiFactorials(N))
			
	       	 	ALLOCATE(Integrand(0:Npoint))
		
			Integrand(0) = 0.0
					
			DO Ipoint = 1, Npoint
			   Radius = RadMesh(Ipoint)
		  	   Integrand(Ipoint) = WaveFun(Ipoint,IndexBra,Isospin)*WaveFun(Ipoint,IndexKet,Isospin) * &
			                       Radius**k * EXP(-(Radius/x)**2) * Factor
		            
			END DO
		
			CALL simps(Integrand,Npoint+1,MeshStep,Result)
		
			DEALLOCATE(Integrand)
		
			IF (ABS(Result) .LT. 1.e-25) Result=0.0
			
			OneBodyInt = Result
		
			RETURN
		END FUNCTION OneBodyInt
		
	END FUNCTION IBrinkBooker

END MODULE ibb
!---------------------------------------------------------------------!
!                                                                     !
!     RADIAL INTEGRALS: COULOMB FORCE                                 !                
!                                                                     !
!---------------------------------------------------------------------!

 MODULE ic

	USE global
	USE lgfactor
	USE symtalm

	IMPLICIT NONE

		DOUBLE PRECISION, PARAMETER :: VC = 1.44197028
		! PI_COU = SQRT(2.0) * (PI ** (5.0 / 2.0))
		REAL(KIND = 16), PARAMETER :: PI_COU = 24.73942945119314805

 CONTAINS

	FUNCTION ICoulomb(na, la, nb, lb, nc, lc, nd, ld, k)
		DOUBLE PRECISION ICoulomb
		INTEGER, INTENT(IN) :: na, la, nb, lb, nc, lc, nd, ld, k

		INTEGER N1, N1min, N1max, N2min, N2max
		REAL(KIND = 16) sumN1

		N1max = na + nc + ((la + lc - k) / 2)
		N2max = nb + nd + ((lb + ld - k) / 2)
		N1min = MIN_5N(na, la, nc, lc, k)
		N2min = MIN_5N(nb, lb, nd, ld, k)

		sumN1 = SymKumar_get(na, la, nc, lc, N1max, k) * SumC(nb, lb, nd, ld, k, N1max, DBLE(2.0))
		DO N1 = N1max - 1, N1min, -1
			sumN1 = (-sumN1 * (N1 + N2min + k + 0.5) / (N1 + 1.0) / (N1 + k + 1.5) / 2.0) &
				+ SymKumar_get(na, la, nc, lc, N1, k) * SumC(nb, lb, nd, ld, k, N1, DBLE(2.0))
		END DO

		ICoulomb = PI_COU * PAR(N1min + N2min) &
			* EXP(DDLogSemiFactorials(N1min + N2min + k - 1) &
			    - DDLogFactorials(N1min) &
			    - DDLogSemiFactorials(N1min + k) &
			    - DDLogFactorials(N2min) &
			    - DDLogSemiFactorials(N2min + k)) &
			* (sumN1 * (2.0 ** DBLE(-N1min - N2min - k)))
		RETURN

	CONTAINS

		FUNCTION SumC(n1, l1, n2, l2, k, M1, y)
			REAL(KIND = 16) SumC
			INTEGER, INTENT(IN) :: n1, l1, n2, l2, k, M1
			DOUBLE PRECISION, INTENT(IN) :: y

			INTEGER N, Nmin, Nmax

			Nmax = n1 + n2 + ((l1 + l2 - k) / 2)
	 		Nmin = MIN_5N(n1, l1, n2, l2, k)

			SumC = SymKumar_get(n1, l1, n2, l2, Nmax, k)
			DO N = Nmax - 1, Nmin, -1
				SumC = - (SumC * (N + M1 + k + 0.5) / (N + 1.0) / (N + k + 1.5) / y) &
					+ SymKumar_get(n1, l1, n2, l2, N, k)
			END DO
			RETURN
		END FUNCTION SumC

	END FUNCTION ICoulomb

END MODULE ic
!---------------------------------------------------------------------!
!                                                                     !
!     RADIAL INTEGRALS: SPIN-ORBIT FORCE                              !                
!                                                                     !
!---------------------------------------------------------------------!

 MODULE ils

	USE global
	USE symtalm

	IMPLICIT NONE

	REAL(KIND = 16), PARAMETER :: Log2 = 0.6931471805599453094172321214581765680755
	DOUBLE PRECISION, PARAMETER :: SQRT_2 = 1.414213562373095

 CONTAINS

	!---------------------------------------------------------------------!
	! Radial Integral IPLS in the case of the harmonic oscillator basis   ! 
	! Refs.: PhD, Page 137, E18                                           !              
	!---------------------------------------------------------------------!

	FUNCTION IPLSHO(na, nc, la, nb, nd, lb)
		DOUBLE PRECISION IPLSHO
		INTEGER, INTENT(IN) :: na, nc, la, nb, nd, lb

		INTEGER p, pmax
		DOUBLE PRECISION x
		REAL(KIND = 16) s

		! OJO: vale para b1==b2

		pmax = na + nb
		x = la + lb - 0.5

		s = SymCoefficientB_get(na, la, nb, lb, pmax) * Sum1(nc, la, nd, lb, pmax + x)
		DO p = pmax - 1, 0, -1
			s = SymCoefficientB_get(na, la, nb, lb, p) * Sum1(nc, la, nd, lb, p + x) &
				+ 0.5 * (p + x + 1.0) * s
		END DO
		IPLSHO = s * EXP(DDLogSemiFactorials(la + lb - 1) - ((la + lb + 1.0) * Log2)) / SQRT_2 ! /b_0**5
		RETURN

	CONTAINS

		FUNCTION Sum1(n1, l1, n2, l2, x)
			REAL(KIND = 16) Sum1
			INTEGER, INTENT(IN) :: n1, l1, n2, l2
			DOUBLE PRECISION, INTENT(IN) :: x

			INTEGER p, pmax

			pmax = n1 + n2
			Sum1 = SymCoefficientB_get(n1, l1, n2, l2, pmax)
			DO p = pmax - 1, 0, -1
				Sum1 = 0.5 * (p + x + 1.0) * Sum1 + SymCoefficientB_get(n1, l1, n2, l2, p)
			END DO
			RETURN
		END FUNCTION Sum1

	END FUNCTION IPLSHO

	!---------------------------------------------------------------------!
	! Radial Integral IPLS in the general case of a spherical basis       ! 
	!---------------------------------------------------------------------!

	FUNCTION IPLS(na, nc, la, nb, nd, lb)
		DOUBLE PRECISION IPLS
		INTEGER, INTENT(IN) :: na, nc, la, nb, nd, lb
		
		DOUBLE PRECISION, ALLOCATABLE :: Integrand(:)

		INTEGER IndexBraOne, IndexKetOne, IndexBraTwo, IndexKetTwo, Ipoint
		
		DOUBLE PRECISION RFourth,Result

		IndexBraOne = IndexVecNL(na,la)
		IndexBraTwo = IndexVecNL(nb,lb)
							
		IndexKetOne = IndexVecNL(nc,la)
		IndexKetTwo = IndexVecNL(nd,lb)
			
		IF (IndexBraOne .EQ. 0 .OR. IndexKetOne .EQ. 0 .OR. IndexBraTwo .EQ. 0 .OR. IndexKetTwo .EQ. 0) THEN
		    IPLS = 0.0
		    RETURN
		END IF
		
	        ALLOCATE(Integrand(0:Npoint))
		
		Integrand(0) = 0.0
		
		DO Ipoint = 1, Npoint
		   RFourth = RadMesh(Ipoint)**4
		   Integrand(Ipoint) = WaveFun(Ipoint,IndexBraOne,Isospin)*WaveFun(Ipoint,IndexBraTwo,Isospin)* &
		                       WaveFun(Ipoint,IndexKetOne,Isospin)*WaveFun(Ipoint,IndexKetTwo,Isospin)/RFourth
		END DO
		
		CALL simps(Integrand,Npoint+1,MeshStep,Result)
		
		DEALLOCATE(Integrand)
		
		IPLS = Result
		
		RETURN

	END FUNCTION IPLS
	
	!---------------------------------------------------------------------!
	! Radial Integral IHFLS in the case of the harmonic oscillator basis  ! 
	! Refs.: PhD, Page 137, Sec. E3.3                                     !               
	!---------------------------------------------------------------------!

	FUNCTION IHFLSHO(na, nc, la, nb, nd, lb)
		DOUBLE PRECISION IHFLSHO
		INTEGER, INTENT(IN) :: na, nc, la, nb, nd, lb

                ! OJO: solo vale cuando b1==b2

		INTEGER p, pmax
		DOUBLE PRECISION x, y
		REAL(KIND = 16) s

		pmax = na + nc
		x = la + lb - 0.5
		y = lb - la - 0.5

		s = SymCoefficientB_get(na, la, nc, la, pmax) * Sum2(nb, lb, nd, lb, pmax + x, y - pmax)
		
		DO p = pmax - 1, 0, -1
			s = (SymCoefficientB_get(na, la, nc, la, p) * Sum2(nb, lb, nd, lb, p + x, y - p)) &
				+ 0.5 * (p + x + 1.0) * s
		END DO
		IHFLSHO = s * EXP(DDLogSemiFactorials(la + lb - 1) - ((la + lb + 1.0) * Log2)) / SQRT_2 ! /b_0**5
		RETURN

	CONTAINS

		FUNCTION Sum2(n1, l1, n2, l2, x, y)
			REAL(KIND = 16) Sum2
			INTEGER, INTENT(IN) :: n1, l1, n2, l2
			DOUBLE PRECISION, INTENT(IN) :: x, y

			INTEGER p, pmax

			pmax = n1 + n2
			Sum2 = SymCoefficientB_get(n1, l1, n2, l2, pmax) * (pmax + y)
			DO p = pmax - 1, 0, -1
				Sum2 = 0.5 * (p + x + 1.0) * Sum2 + (SymCoefficientB_get(n1, l1, n2, l2, p) * (p + y))
			END DO
			RETURN
		END FUNCTION Sum2

	END FUNCTION IHFLSHO
	
	!---------------------------------------------------------------------!
	! Radial Integral IHFLS in the general case of a spherical basis      ! 
	!---------------------------------------------------------------------!

	FUNCTION IHFLS(na, nc, la, nb, nd, lb)
		DOUBLE PRECISION IHFLS
		INTEGER, INTENT(IN) :: na, nc, la, nb, nd, lb
		
		DOUBLE PRECISION, ALLOCATABLE :: Integrand(:)

		INTEGER IndexBraOne, IndexKetOne, IndexBraTwo, IndexKetTwo, Ipoint
		
		DOUBLE PRECISION Result

		IndexBraOne = IndexVecNL(na,la)
		IndexBraTwo = IndexVecNL(nc,la)
							
		IndexKetOne = IndexVecNL(nb,lb)
		IndexKetTwo = IndexVecNL(nd,lb)
						
		IF (IndexBraOne .EQ. 0 .OR. IndexKetOne .EQ. 0 .OR. IndexBraTwo .EQ. 0 .OR. IndexKetTwo .EQ. 0) THEN
		    IHFLS = 0.0
		    RETURN
		END IF
		
	        ALLOCATE(Integrand(0:Npoint))
		
		Integrand(0) = 0.0
		
		DO Ipoint = 1, Npoint
		   Integrand(Ipoint) = WaveFun(Ipoint,IndexBraOne,Isospin)*WaveFun(Ipoint,IndexBraTwo,Isospin)* &
		                     ( WaveFun(Ipoint,IndexKetOne,Isospin)*WaveDeri(Ipoint,IndexKetTwo,Isospin) + &
		                       WaveDeri(Ipoint,IndexKetOne,Isospin)*WaveFun(Ipoint,IndexKetTwo,Isospin) - &
		                   2.0*WaveFun(Ipoint,IndexKetOne,Isospin)*WaveFun(Ipoint,IndexKetTwo,Isospin)/RadMesh(Ipoint) ) &
		   		      /RadMesh(Ipoint)**3
		END DO
		
		CALL simps(Integrand,Npoint+1,MeshStep,Result)
		
		DEALLOCATE(Integrand)
		
		IHFLS = Result
		
		RETURN

	END FUNCTION IHFLS

END MODULE ils
MODULE indexx

CONTAINS

	SUBROUTINE indexx_real8(n, arrin, indx)
		INTEGER, INTENT(IN) :: n
		DOUBLE PRECISION, DIMENSION(*), INTENT(IN) :: arrin
		INTEGER, DIMENSION(*), INTENT(INOUT) :: indx

		INTEGER l, j, ir, indxt, i
		DOUBLE PRECISION q

		DO j = 1, n
			indx(j) = j
		END DO

		IF (n .EQ. 1) RETURN

		l = (n / 2) + 1
		ir = n
		DO
			IF (l .GT. 1) THEN
				l = l - 1
				indxt = indx(l)
				q = arrin(indxt)
			ELSE
				indxt = indx(ir)
				q = arrin(indxt)
				indx(ir) = indx(1)
				ir = ir - 1
				IF (ir .EQ. 1) THEN
					indx(1) = indxt
					RETURN
				END IF
			END IF
			i = l
			j = l * 2
			DO WHILE (j .LE. ir)
				IF ((j .LT. ir) .AND. (arrin(indx(j)) .LT. arrin(indx(j + 1)))) THEN
					j = j + 1
				END IF
				IF (q .LT. arrin(indx(j))) THEN
					indx(i) = indx(j)
					i = j
					j = j + i
				ELSE
					j = ir + 1
				END IF
			END DO
			indx(i) = indxt
		END DO
	END SUBROUTINE indexx_real8

END MODULE indexx
! Input parameters module
 MODULE input

	USE io

	IMPLICIT NONE

	! Input parameters
	DOUBLE PRECISION :: b_0 = 1.66       	   ! Oscillator length ("b")
	INTEGER :: N_0 = 8                   	   ! Number of shells
	INTEGER :: protons = 8, neutrons = 8       ! Number of protons and neutrons
	INTEGER :: Gogny = 1        		   ! 1 = DSA1, 2 = D1, 3 = D1_PRIMA
	INTEGER :: Basis = 1
	
	INTEGER, ALLOCATABLE :: IndexVecNL(:,:)

 CONTAINS

	SUBROUTINE Input_read

		INTEGER, PARAMETER :: file_desc = 6
		INTEGER file_error, N, L, i
		CHARACTER(LEN = 256) :: param
		INTEGER param_len

		OPEN(file_desc, FILE="data/input.txt", ACTION="READ", IOSTAT=file_error)
		IF (file_error .NE. 0) STOP "Impossible to read: ./data/input.txt"

		PRINT "(/A)", "Reading the input parameters..."
		
		param_len = IO_get_Param(file_desc, param)
		
		DO WHILE (param_len .GT. 0)
			IF (param .EQ. "b_0") THEN
				b_0 = IO_get_RealValue(file_desc)
				PRINT "(A,F8.5)", "Oscillator Length (b_0)       : ", b_0
			ELSE IF (param .EQ. "N_0") THEN
				N_0 = IO_get_IntegerValue(file_desc)
				PRINT "(A,I3)",   "Number of shells (N_0)        : ", N_0
			ELSE IF (param .EQ. "N") THEN
				neutrons = IO_get_IntegerValue(file_desc)
				PRINT "(A,I3)",   "Number of neutrons (N)        : ", neutrons
			ELSE IF (param .EQ. "Z") THEN
				protons = IO_get_IntegerValue(file_desc)
				PRINT "(A,I3)",   "Number of protons  (Z)        : ", protons
			ELSE IF (param .EQ. "GOGNY") THEN
				Gogny = IO_get_IntegerValue(file_desc)
				SELECT CASE (Gogny)
					CASE (1)
						PRINT "(A)", "Parameters of the Gogny force : DSA1"
					CASE (2)
						PRINT "(A)", "Parameters of the Gogny force : D1"
					CASE (3)
						PRINT "(A)", "Parameters of the Gogny force : D1_PRIMA"
					CASE DEFAULT
						STOP "Invalid parameters of the Gogny force"
				END SELECT
			ELSE IF (param .EQ. "Basis") THEN
				Basis = IO_get_IntegerValue(file_desc)
				!Basis = IO_get_String(file_desc)
				PRINT "(A,I3)",   "Type of Basis                 : ", Basis
				!PRINT "(A,A)",   "Type of Basis                 :", Basis
			ELSE
				PRINT "(A,A)", "Attention! Unknown parameter: ", param(1:param_len)
				! We ignore the remaining lines
				READ (file_desc, "(A)") param
			END IF
			param_len = IO_get_Param(file_desc, param)
		END DO

		CLOSE(file_desc)
		
		! IndexVecNL gives the correspondence N, L -> index i of the basis
                ALLOCATE(IndexVecNL(0:N_0,0:N_0))
			      
		DO N = 0,N_0
			DO L = 0,N_0
				IndexVecNL(N,L) = 0
			END DO
		END DO
			      
		DO i=1,Nlevel(1)
			N = Nmain(i,1)
			L = Lmain(i,1)
			IF (N .LE. N_0 .AND. L .LE. N_0) IndexVecNL(N,L) = i
		END DO			      
		
		RETURN
		
	END SUBROUTINE Input_read

END MODULE input
!---------------------------------------------------------------------!
!                                                                     !
!              MODULE CONTAINING INPUT/OUTPUT FUNCTIONS               !                
!                                                                     !
!---------------------------------------------------------------------!

 MODULE io

	IMPLICIT NONE

	INTEGER :: Nsize, Npoint
	
	INTEGER :: Nlevel(1:2)
	
	INTEGER, ALLOCATABLE :: LmaxiIso(:)
	INTEGER, ALLOCATABLE :: Nmain(:,:), Lmain(:,:), Jmain(:,:)
	
	DOUBLE PRECISION :: MeshStep
	DOUBLE PRECISION, ALLOCATABLE    :: RadMesh(:)
	DOUBLE PRECISION, ALLOCATABLE    :: Energy(:,:), WaveFun(:,:,:), WaveDeri(:,:,:), Overlap(:,:,:)
		
 CONTAINS

        !------------------------------------------------------------------------!
        ! Subroutine that reads the spherical basis. It provides the number      !
	! of levels, their single-particle energies, and their quantum numbers   !
	! (n,l,j) stored in arrays     						 !
        !------------------------------------------------------------------------!

        SUBROUTINE ReadBasis()
	
		INTEGER, PARAMETER :: file_unit = 12
		
	        INTEGER, ALLOCATABLE :: Ndummy(:)
		
		INTEGER file_error
		INTEGER param_len, stat
		INTEGER i, j, L, N, nb1, nb2, jtemp, kappa, Nmaxi, Lmax, Nmax
		
		CHARACTER(LEN = 6)   :: keyword

                ! Opening the file to read
		
		OPEN(file_unit, FILE="basis.txt", ACTION="READ", IOSTAT=file_error)
		
		IF (file_error .NE. 0) STOP "Impossible to open: basis.txt"

		PRINT "(/A)", "Reading the Basis parameters..."
		
		READ(file_unit, FMT="(A)", ADVANCE="NO", IOSTAT=stat) keyword
		
                ! We read the input file by using keywords
		
		DO WHILE (keyword .NE. "FINISH")
		
			  SELECT CASE (keyword)
			  
			  CASE ("boxpar") 
			  
			      READ(file_unit, *, IOSTAT=stat) Npoint,MeshStep
			      
			      ALLOCATE(RadMesh(0:Npoint))
			      
			      DO i = 0, Npoint
			         RadMesh(i) = i*MeshStep
			      END DO
			      
			  CASE ("noflev") 
			  
			      READ(file_unit, *, IOSTAT=stat) nb1,nb2,Nlevel(1),Nlevel(2)
			      
			      Nsize = max(Nlevel(1),Nlevel(2))			      
			    
			  !    
                          ! NEUTRONS - NEUTRONS - NEUTRONS - NEUTRONS - NEUTRONS - NEUTRONS
			  !
			  
			  ! Neutron single-particle energies
			  CASE ("esingn") 
			  
			      IF (Nlevel(1) .EQ. 0) STOP "Nlevel = 0 in ReadBasis !"
			  
                              ALLOCATE(Energy(Nsize,2))
			      
			      READ(file_unit, *, IOSTAT=stat) (Energy(i,1),i=1,Nlevel(1))
			      
			  ! Neutron angular momentum j (in Jmain)
			  CASE( "spin_n")
			  
			      IF (Nlevel(1) .EQ. 0) STOP "Nlevel = 0 in ReadBasis !"
			  
                              ALLOCATE(Jmain(Nsize,2))
			      ALLOCATE(Ndummy(Nlevel(1)))
			      
			      READ(file_unit, *, IOSTAT=stat) (Ndummy(i),i=1,Nlevel(1))
			      
			      DO i=1,Nlevel(1)
			         Jmain(i,1) = 2*Ndummy(i) - 1
			      END DO
			      
			      DEALLOCATE(Ndummy)
			      			      
			  ! Neutron orbital angular momentum l (in Lmain)
			  CASE ("kappan")
			  
			      IF (Nlevel(1) .EQ. 0) STOP "Nlevel = 0 in ReadBasis !"
			  
                              ALLOCATE(Lmain(Nsize,2))
			      ALLOCATE(Ndummy(Nlevel(1)))
			      
			      READ(file_unit, *, IOSTAT=stat) (Ndummy(i),i=1,Nlevel(1))
			      
			      ! Lmax is the maximum orbital angular momentum (used to define 
			      ! a fake number of shells N0)
			      Lmax = 0
			      
			      DO i=1,Nlevel(1)
			         kappa = Ndummy(i)
				 jtemp = iabs(kappa)
				 Lmain(i,1) = jtemp - (1 - kappa/jtemp)/2
				 IF (Lmain(i,1) .GT. Lmax) Lmax = Lmain(i,1)
			      END DO
			      
			      DEALLOCATE(Ndummy)
			      
			      ALLOCATE(LmaxiIso(2))
			      LmaxiIso(1) = Lmax
			      			      
			  CASE ("numbrn")
			  
			      IF (Nlevel(1) .EQ. 0) STOP "Nlevel = 0 in ReadBasis !"
			  
                              ALLOCATE(Nmain(Nsize,2))
			      
			      READ(file_unit, *, IOSTAT=stat) (Nmain(i,1),i=1,Nlevel(1))
			      
			      Nmax = 0
			      
			      DO i=1,Nlevel(1)
				 IF (Nmain(i,1) .GT. Nmax) Nmax = Nmain(i,1)
			      END DO
			      
			  CASE ("wave_n")
			  
			      IF (Nlevel(1) .EQ. 0) STOP "Nlevel = 0 in ReadBasis !"
			  
                              ALLOCATE(WaveFun(0:Npoint,Nsize,2))
			      
			      DO j=1,Nlevel(1)
			         READ(file_unit, *, IOSTAT=stat) (WaveFun(i,j,1),i=0,Npoint)
			      END DO
			      
			  CASE ("derivn")
			  
			      IF (Nlevel(1) .EQ. 0) STOP "Nlevel = 0 in ReadBasis !"
			  
                              ALLOCATE(WaveDeri(0:Npoint,Nsize,2))
			      
			      DO j=1,Nlevel(1)
			         READ(file_unit, *, IOSTAT=stat) (WaveDeri(i,j,1),i=0,Npoint)
			      END DO
			    
			  !    
                          ! PROTONS - PROTONS - PROTONS - PROTONS - PROTONS - PROTONS
			  !
			  
			  CASE ("esingp") 
			  
			      READ(file_unit, *, IOSTAT=stat) (Energy(i,2),i=1,Nlevel(2))
			      
			  CASE( "spin_p")
			  
			      ALLOCATE(Ndummy(Nlevel(1)))
			      
			      READ(file_unit, *, IOSTAT=stat) (Ndummy(i),i=1,Nlevel(2))
			      
			      DO i=1,Nlevel(2)
			         Jmain(i,2) = 2*Ndummy(i) - 1
			      END DO
			      
			      DEALLOCATE(Ndummy)
			      
			  CASE ("kappap")
			  
			      ALLOCATE(Ndummy(Nlevel(1)))
			      
			      READ(file_unit, *, IOSTAT=stat) (Ndummy(i),i=1,Nlevel(2))
			      
			      Lmax = 0
			      
			      DO i=1,Nlevel(2)
			         kappa = Ndummy(i)
				 jtemp = iabs(kappa)
				 Lmain(i,2) = jtemp - (1 - kappa/jtemp)/2
				 IF (Lmax .GT. Lmain(i,2)) Lmax = Lmain(i,2)
			      END DO
			      
			      DEALLOCATE(Ndummy)
			      
			      LmaxiIso(2) = Lmax
			      
			  CASE ("numbrp")
			  
			      READ(file_unit, *, IOSTAT=stat) (Nmain(i,2),i=1,Nlevel(2))
			      
			  CASE ("wave_p")
			  
			      DO j=1,Nlevel(2)
			         READ(file_unit, *, IOSTAT=stat) (WaveFun(i,j,2),i=0,Npoint)
			      END DO
			      
			  CASE ("derivp")
			  
			      DO j=1,Nlevel(2)
			         READ(file_unit, *, IOSTAT=stat) (WaveDeri(i,j,2),i=0,Npoint)
			      END DO
			    
			  END SELECT
			  
                          ! Until we get to the end of the file, we read the next keyword

		          READ(file_unit, FMT="(A)", IOSTAT=stat) keyword

                          ! At the end of the file, we exit

		          IF (stat .NE. 0) THEN
		
		              CLOSE(file_unit)
		              RETURN
		   
		          END IF
		
		END DO
	
		RETURN
	END SUBROUTINE ReadBasis
	

	FUNCTION IO_get_Param(fd, param)
		INTEGER IO_get_Param
		INTEGER, INTENT(IN) :: fd ! Descriptor de fichero
		CHARACTER(*), INTENT(INOUT) :: param

		CHARACTER c
		INTEGER num, stat

		READ (fd, FMT="(A1)", ADVANCE="NO", IOSTAT=stat) c
		IF (stat .NE. 0) THEN
			IO_get_Param = 0
			RETURN
		END IF
		! Ignoramos los espacios en blanco iniciales
		DO WHILE (c == " ")
			READ (fd, FMT="(A1)", ADVANCE="NO", IOSTAT=stat) c
			IF (stat .NE. 0) THEN
				IO_get_Param = 0
				RETURN
			END IF
		END DO
		num = 0
		DO WHILE ((c .NE. " ") .AND. (c .NE. "="))
			IF (num .EQ. 0) THEN
				param = c
			ELSE
				param = param(1:num) // c
			END IF
			num = num + 1
			READ (fd, FMT="(A1)", ADVANCE="NO", IOSTAT=stat) c
			IF (stat .NE. 0) THEN
				IO_get_Param = 0
				RETURN
			END IF
		END DO
		! Si no se encontra ningun nombre de parametro, salimos con error
		IF (num .EQ. 0) THEN
			IO_get_Param = 0
			RETURN
		END IF

		DO WHILE (c .EQ. " ")
			READ (fd, FMT="(A1)", ADVANCE="NO", IOSTAT=stat) c
			IF (stat .NE. 0) THEN
				IO_get_Param = 0
				RETURN
			END IF
		END DO

		IF (c .EQ. "=") THEN
			IO_get_Param = num
		ELSE
			IO_get_Param = 0
		END IF
		RETURN
	END FUNCTION IO_get_Param

	FUNCTION IO_get_IntegerValue(fd)
		INTEGER IO_get_IntegerValue
		INTEGER, INTENT(IN) :: fd ! Descriptor de fichero

		INTEGER stat

		READ (fd, FMT="(I)", IOSTAT=stat) IO_get_IntegerValue
		IF (stat .NE. 0) STOP "Imposible leer parametro de entrada"
		RETURN
	END FUNCTION IO_get_IntegerValue

	FUNCTION IO_get_RealValue(fd)
		DOUBLE PRECISION IO_get_RealValue
		INTEGER, INTENT(IN) :: fd ! Descriptor de fichero

		INTEGER stat

		READ (fd, FMT="(E)", IOSTAT=stat) IO_get_RealValue
		IF (stat .NE. 0) STOP "Imposible leer parametro de entrada"
		RETURN
	END FUNCTION IO_get_RealValue

	FUNCTION IO_get_String(fd)
		CHARACTER(LEN=30) IO_get_String
		INTEGER, INTENT(IN) :: fd ! Descriptor de fichero

		INTEGER stat

		READ (fd, FMT="(A)", IOSTAT=stat) IO_get_String
		IF (stat .NE. 0) STOP "Imposible leer parametro de entrada"
		RETURN
	END FUNCTION IO_get_String

END MODULE io
MODULE jacobi

CONTAINS

	!*************************************************************
	!* This subroutine computes all eigenvalues and eigenvectors *
	!* of a real symmetric square matrix A(N,N). On output, ele- *
	!* ments of A above the diagonal are destroyed. D(N) returns *
	!* the eigenvalues of matrix A. V(N,N) contains, on output,  *
	!* the eigenvectors of A by columns. THe normalization to    *
	!* unity is made by main program before printing results.    *
	!* NROT returns the number of Jacobi matrix rotations which  *
	!* were required.                                            *
	!* --------------------------------------------------------- *
	!* Ref.:"NUMERICAL RECIPES, Cambridge University Press,1986, *
	!*       chap. 11, pages 346-348".                           *
	!*************************************************************
	SUBROUTINE Jacobi_real8(A, N, D, V, NROT)
		INTEGER, INTENT(IN) :: N
		DOUBLE PRECISION, DIMENSION(N,  N), INTENT(INOUT) :: A, V
		DOUBLE PRECISION, DIMENSION(N), INTENT(INOUT) :: D
		INTEGER, INTENT(INOUT) :: NROT
		DOUBLE PRECISION, POINTER :: B(:), Z(:)
		DOUBLE PRECISION c, g, h, s, sm, t, tau, theta, tresh

		INTEGER ialloc, ip, iq, i, j

		ALLOCATE(B(100), stat = ialloc)
		ALLOCATE(Z(100), stat = ialloc)

		DO ip = 1,  N    !initialize V to identity matrix
			DO iq = 1,  N
				V(ip, iq) = 0.d0
			END DO
			V(ip, ip) = 1.d0
		END DO
	  DO ip = 1,  N
	    B(ip) = A(ip, ip)
	    D(ip) = B(ip)
	    Z(ip) = 0.d0    
	  END DO
	  NROT = 0
	  DO i = 1,  50
	    sm = 0.d0
	    DO ip = 1,  N-1     !sum off-diagonal elements
	      DO iq = ip + 1,  N
	        sm = sm + DABS(A(ip, iq))
	      END DO
	    END DO
	    IF(sm .EQ. 0.d0) RETURN  !normal return
	    IF(i .LT. 4) THEN
	      tresh = 0.2d0 * sm ** 2
	    ELSE
	      tresh = 0.d0
	    END IF
	    DO ip = 1,  N-1
	      DO iq = ip + 1,  N
	        g = 100.d0 * DABS(A(ip, iq))
	! after 4 sweeps,  skip the rotation IF the off-diagonal element is small
	        IF((i .GT. 4) .AND. (DABS(D(ip)) + g .EQ. DABS(D(ip))) &
			.AND. (DABS(D(iq)) + g .EQ. DABS(D(iq)))) THEN
			  A(ip, iq) = 0.d0
	        ELSE IF(DABS(A(ip, iq)) .GT. tresh) THEN
		  h = D(iq)-D(ip)
		  IF ((DABS(h) + g) .EQ. DABS(h)) THEN
		    t = A(ip, iq)/h
	          ELSE
		    theta = 0.5d0*h/A(ip, iq)  
	            t = 1.d0/(DABS(theta) + DSQRT(1.d0 + theta**2))
		    IF (theta .LT. 0.d0) t = -t
	          END IF
		  c = 1.d0/DSQRT(1.d0 + t**2)
		  s = t*c
	          tau = s/(1.d0 + c)
		  h = t*A(ip, iq)
		  Z(ip) = Z(ip)-h
		  Z(iq) = Z(iq) + h
		  D(ip) = D(ip)-h
		  D(iq) = D(iq) + h
		  A(ip, iq) = 0.d0
		  DO j = 1,  ip-1
		    g = A(j, ip)
		    h = A(j, iq)
		    A(j, ip) = g-s*(h + g*tau)
		    A(j, iq) = h + s*(g-h*tau)
	          END DO
		  DO j = ip + 1,  iq-1
		    g = A(ip, j)
		    h = A(j, iq)
		    A(ip, j) = g-s*(h + g*tau)
		    A(j, iq) = h + s*(g-h*tau)
	          END DO		      
		  DO j = iq + 1,  N
		    g = A(ip, j)
		    h = A(iq, j)
		    A(ip, j) = g-s*(h + g*tau)
		    A(iq, j) = h + s*(g-h*tau)
	          END DO		  
		  DO j = 1,  N
		    g = V(j, ip)
		    h = V(j, iq)
		    V(j, ip) = g-s*(h + g*tau)
		    V(j, iq) = h + s*(g-h*tau)
	          END DO		  
	          NROT = NROT + 1
	        END IF !IF ((i.gt.4)...
	      END DO !main iq loop
	    END DO !main ip loop
	    DO ip = 1,  N
	      B(ip) = B(ip) + Z(ip)
	      D(ip) = B(ip)
	      Z(ip) = 0.d0
	    END DO
	  END DO !main i loop
		PAUSE ' 50 iterations !'
		RETURN
	END SUBROUTINE Jacobi_real8

END MODULE jacobi
 MODULE lgfactor

	IMPLICIT NONE

	DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE :: lnf, lng
	REAL(KIND = 16), DIMENSION(:), ALLOCATABLE :: ddlnf, ddlng

	INTEGER lnf_max, lng_max, ddlnf_max, ddlng_max

	PRIVATE lnf, lng, ddlnf, ddlng
	PRIVATE lnf_max, lng_max, ddlnf_max, ddlng_max

 CONTAINS

	SUBROUTINE LogFactorials_new(imax)
		INTEGER, INTENT(IN) :: imax

		INTEGER i

		ALLOCATE(lnf(0:imax))
		lnf_max = imax
		lnf(0) = 0.0
		DO i = 1, imax
			lnf(i) = LOG(DBLE(i)) + lnf(i - 1)
		END DO
		RETURN
	END SUBROUTINE LogFactorials_new

	SUBROUTINE LogSemiFactorials_new(imax)
		INTEGER, INTENT(IN) :: imax

		INTEGER i

		ALLOCATE(lng(0:imax))
		lng_max = imax
		lng(0) = -0.1207822376352452223455184
		DO i = 1, imax
			lng(i) = LOG(DBLE(i) + 0.5) + lng(i - 1)
		END DO
		RETURN
	END SUBROUTINE LogSemiFactorials_new

	SUBROUTINE DDLogFactorials_new(imax)
		INTEGER, INTENT(IN) :: imax

		INTEGER i

		ALLOCATE(ddlnf(0:imax))
		ddlnf_max = imax
		ddlnf(0) = 0.0
		DO i = 1, imax
			ddlnf(i) = LOG(DBLE(i)) + ddlnf(i - 1)
		END DO
		RETURN
	END SUBROUTINE DDLogFactorials_new

	SUBROUTINE DDLogSemiFactorials_new(imax)
		INTEGER, INTENT(IN) :: imax

		INTEGER i

		ALLOCATE(ddlng(0:imax))
		ddlng_max = imax
!		Neper log of (1/2)! = SQRT(PI) / 2
		ddlng(0) = -0.1207822376352452223455184
		DO i = 1, imax
			ddlng(i) = LOG(DBLE(i) + 0.5) + ddlng(i - 1)
		END DO
		RETURN
	END SUBROUTINE DDLogSemiFactorials_new

	FUNCTION DDLogFactorials(i)
		REAL(KIND = 16) DDLogFactorials
		INTEGER, INTENT(IN) :: i

		IF ((i .GE. 0) .AND. (i .LE. ddlnf_max)) THEN
			DDLogFactorials = ddlnf(i)
		ELSE
!			DDLogFactorials = gammln(i + 1.0)
			PRINT *, "Fuera de rango:", i, ddlnf_max
			STOP "DDLogFactorials"
		END IF
		RETURN
	END FUNCTION DDLogFactorials

	FUNCTION DDLogSemiFactorials(i)
		REAL(KIND = 16) DDLogSemiFactorials
		INTEGER, INTENT(IN) :: i

!		Neper logarithm of (-1/2)! = SQRT(PI)
		IF (i .EQ. -1) THEN
			DDLogSemiFactorials = 0.5723649429247000870717137
		ELSE IF ((i .GE. 0) .AND. (i .LE. ddlng_max)) THEN
			DDLogSemiFactorials = ddlng(i)
		ELSE
!			DDLogSemiFactorials = gammln(i + 1.5)
			PRINT *, "Fuera de rango:", i, ddlng_max
			STOP "DDLogSemiFactorials"
		END IF
		RETURN
	END FUNCTION DDLogSemiFactorials

END MODULE lgfactor
PROGRAM main

        !---------------------------------------------------------------------!
        !    								      !
        !                      INCLUDING MODULES                              !
        !    								      !
        !---------------------------------------------------------------------!
	
	USE input    ! Parametros de entrada
	USE global
	USE nucleus  ! Nucleo
	USE symden
	USE diagmeth ! Metodo de diagonalizacion
	USE wave

        !---------------------------------------------------------------------!
        !    								      !
        !                 DECLARATION OF VARIABLES                            !
        !    								      !
        !---------------------------------------------------------------------!
	
	IMPLICIT NONE
	
        TYPE (SymDensity) density
	TYPE (DiagonalizationMethod) diagonal

	INTEGER cycles_in, cycles_out, cycles_rate
	DOUBLE PRECISION min_b

        !---------------------------------------------------------------------!
        !    								      !
        !                 BEGINNING OF THE PROGRAM                            !
        !    								      !
        !---------------------------------------------------------------------!

	CALL SYSTEM_CLOCK(cycles_in)

	CALL Global_new

        ! Reading the basis form WSCOOR

	CALL ReadBasis
	
	CALL SymDensity_new(density, neutrons, protons) ! N y Z SHOULD BE NEUTRONS PROTONS INSTEAD
	CALL Nucleus_set_b(density%nucleus, b_0)
	CALL SymDensity_read(density)

	CALL DiagonalizationMethod_new(diagonal, density)
	CALL DiagonalizationMethod_goto_SelfConsistency(diagonal, DBLE(1.0e-4))

	CALL Global_del

	CALL SYSTEM_CLOCK(cycles_out, cycles_rate)
	PRINT "(/A)", "Tiempo consumido:"
	PRINT "(A,EN)", "Segundos: ", DBLE(cycles_out - cycles_in) / cycles_rate
	PRINT "(A,I)", "Ciclos de reloj: ", cycles_out - cycles_in
	
	STOP
	
END PROGRAM main
	DOUBLE PRECISION, DIMENSION(0:1, 0:1658) :: Nucleus_MassExcess
	DATA Nucleus_MassExcess / &
		 008071.380, 0000.008,  007289.029, 0000.007, &
		 013135.824, 0000.014,  014949.913, 0000.021, &
		 014931.314, 0000.021,  025840.000, 0380.000, &
		 002424.910, 0000.030,  025120.000, 0300.000, &
		 011390.000, 0050.000,  011680.000, 0050.000, &
		 017592.600, 0000.900,  014085.700, 0000.700, &
		 018374.000, 0005.000,  026110.000, 0030.000, &
		 014907.000, 0000.800,  015768.900, 0000.800, &
		 027870.000, 0070.000,  031598.000, 0007.000, &
		 020945.600, 0000.800,  004941.710, 0000.080, &
		 022920.400, 0001.200,  035094.000, 0024.000, &
		 040810.000, 0120.000,  024954.100, 0002.000, &
		 011347.700, 0000.400,  012415.900, 0001.100, &
		 028913.900, 0002.300,  033840.000, 0250.000, &
		 012607.100, 0000.400,  012050.990, 0000.270, &
		 015699.100, 0000.300,  040900.000, 0110.000, &
		 020174.000, 0006.000,  008668.200, 0000.300, &
		 010650.400, 0000.900,  024890.000, 0140.000, &
		 025077.000, 0015.000,  013369.500, 0001.300, &
		 000000.000, 0000.000,  017338.100, 0001.000, &
		 032060.000, 0040.000,  035000.000, 0500.000, &
		 016562.500, 0001.100,  003125.032, 0000.010, &
		 005345.520, 0000.270,  023113.000, 0010.000, &
		 040100.000, 0130.000,  023664.000, 0021.000, &
		 003019.908, 0000.016,  002863.433, 0000.015, &
		 008006.540, 0000.080,  028970.000, 0022.000, &
		 009873.200, 0000.800,  000101.496, 0000.024, &
		 002855.400, 0000.500,  016770.000, 0130.000, &
		 013694.000, 0004.000,  005682.100, 0002.300, &
		-004737.037, 0000.030,  010680.000, 0008.000, &
		 023989.000, 0020.000,  021035.000, 0017.000, &
		 007871.000, 0015.000, -000809.080, 0000.260, &
		 001951.780, 0000.250,  016480.000, 0050.000, &
		 024920.000, 0030.000,  013117.000, 0020.000, &
		-000782.200, 0000.800,  000873.400, 0000.600, &
		 005319.000, 0005.000,  015871.000, 0019.000, &
		 003332.100, 0002.900, -001487.430, 0000.090, &
		 001751.000, 0000.600,  012928.000, 0012.000, &
		 003796.900, 0001.200, -000017.350, 0000.170, &
		-007047.800, 0001.800,  006839.000, 0007.000, &
		 017570.000, 0027.000,  008066.000, 0015.000, &
		-000047.500, 0001.800, -005737.400, 0001.700, &
		-002189.800, 0002.000,  010913.000, 0016.000, &
		 009440.000, 0090.000,  002830.000, 0030.000, &
		-008027.200, 0001.500, -005185.200, 0001.600, &
		-000397.000, 0001.500,  018090.000, 0070.000, &
		 003350.000, 0170.000, -005156.000, 0002.500, &
		-009532.300, 0000.800, -005473.700, 0001.400, &
		 006767.000, 0025.000, -005950.000, 0010.000, &
		-008420.400, 0000.800, -013933.500, 0000.600, &
		-000055.000, 0004.000,  010755.000, 0019.000, &
		-002060.000, 0040.000, -009360.300, 0001.400, &
		-013192.800, 0000.600, -008915.800, 0000.900, &
		 003827.000, 0010.000,  000440.000, 0070.000, &
		-006904.000, 0016.000, -016214.100, 0000.600, &
		-012210.400, 0000.600, -007145.000, 0003.000, &
		-005600.000, 0040.000, -014586.300, 0000.800, &
		-017197.200, 0000.600, -012385.400, 0000.600, &
		-000750.000, 0040.000, -001140.000, 0140.000, &
		-015019.200, 0002.100, -016851.000, 0000.600, &
		-021492.900, 0000.500, -007161.000, 0004.000, &
		 004130.000, 0160.000,  002650.000, 0150.000, &
		-010661.000, 0029.000, -018215.800, 0001.300, &
		-021895.400, 0000.500, -016951.900, 0000.900, &
		-003160.000, 0050.000,  008210.000, 0250.000, &
		-009100.000, 0210.000, -015890.000, 0040.000, &
		-024433.600, 0000.500, -020200.900, 0000.700, &
		-014063.000, 0003.000,  011830.000, 0580.000, &
		-015050.000, 0070.000, -022950.600, 0000.600, &
		-024441.200, 0000.500, -019045.400, 0001.500, &
		-007060.000, 0050.000,  016550.000, 0740.000, &
		-001750.000, 1580.000, -024081.100, 0001.000, &
		-024305.500, 0000.500, -026016.370, 0000.160, &
		-013330.000, 0008.000, -002180.000, 0050.000, &
		 021470.000, 1140.000, -020492.000, 0016.000, &
		-026338.100, 0001.100, -026586.630, 0000.140, &
		-021003.800, 0000.500, -009380.000, 0030.000, &
		 026650.000, 3570.000, -019958.000, 0015.000, &
		-024557.700, 0001.200, -029932.370, 0000.130, &
		-024440.070, 0000.180, -018379.000, 0003.000, &
		-014320.000, 0050.000, -024857.900, 0001.900, &
		-028846.910, 0000.130, -029013.740, 0000.040, &
		-023048.900, 0001.300, -011167.000, 0020.000, &
		 004450.000, 0060.000, -020251.000, 0013.000, &
		-030664.250, 0000.240, -029522.100, 0000.080, &
		-030230.710, 0000.260, -017425.000, 0008.000, &
		-006440.000, 0040.000, -026896.480, 0000.260, &
		-031761.780, 0000.070, -030948.700, 0000.500, &
		-024798.700, 0001.400, -013159.000, 0022.000, &
		-026861.000, 0007.000, -029798.260, 0000.120, &
		-034715.100, 0000.800, -028802.000, 0000.900, &
		-022059.000, 0005.000, -029802.800, 0002.500, &
		-033241.000, 0005.000, -033806.300, 0001.000, &
		-027275.600, 0002.000, -014300.000, 0050.000, &
		-022520.000, 0040.000, -027530.000, 0040.000, &
		-035039.100, 0001.100, -033534.500, 0001.000, &
		-034846.100, 0001.000, -020526.000, 0004.000, &
		-009063.000, 0011.000, -027400.000, 0150.000, &
		-033066.500, 0001.200, -035558.400, 0001.000, &
		-035137.500, 0001.000, -028643.000, 0001.400, &
		-015690.000, 0013.000, -034420.000, 0040.000, &
		-035020.900, 0001.000, -038547.000, 0001.100, &
		-032121.900, 0001.300, -025121.000, 0006.000, &
		-023130.000, 0060.000, -031980.000, 0070.000, &
		-036593.000, 0009.000, -038408.600, 0001.100, &
		-036187.800, 0002.200, -029320.000, 0007.000, &
		-032260.000, 0020.000, -035810.000, 0040.000, &
		-041469.200, 0001.200, -037815.900, 0002.100, &
		-037548.200, 0001.200, -013450.000, 0030.000, &
		-029720.000, 0060.000, -036614.000, 0010.000, &
		-040812.800, 0001.200, -041069.500, 0001.300, &
		-039006.400, 0001.400, -031875.000, 0017.000, &
		-019410.000, 0100.000, -029720.000, 0040.000, &
		-035418.000, 0016.000, -043140.700, 0002.600, &
		-041758.800, 0001.300, -044125.400, 0001.200, &
		-037075.000, 0001.400, -029472.000, 0020.000, &
		-025910.000, 0100.000, -035696.000, 0008.000, &
		-042345.500, 0002.500, -044330.400, 0002.100, &
		-044931.800, 0001.000, -042004.000, 0001.200, &
		-034553.000, 0014.000, -032122.000, 0024.000, &
		-044214.000, 0004.000, -044492.000, 0005.000, &
		-048487.100, 0001.000, -044474.700, 0002.600, &
		-042818.000, 0007.000, -029211.000, 0021.000, &
		-018130.000, 0110.000, -030770.000, 0300.000, &
		-041289.000, 0004.000, -046558.000, 0004.000, &
		-048558.100, 0001.000, -047956.200, 0001.300, &
		-045328.300, 0002.700, -037611.000, 0024.000, &
		-024580.000, 0160.000, -039570.000, 0009.000, &
		-044537.000, 0016.000, -051426.000, 0001.000, &
		-049219.000, 0001.500, -050257.300, 0001.500, &
		-042625.400, 0001.500, -034470.000, 0060.000, &
		-035010.000, 0080.000, -043218.000, 0020.000, &
		-049726.900, 0001.400, -052199.000, 0001.500, &
		-051447.700, 0001.500, -048238.900, 0001.500, &
		-040217.000, 0015.000, -049464.000, 0007.000, &
		-051438.800, 0001.600, -055414.400, 0001.500, &
		-050702.900, 0002.400, -048331.000, 0010.000, &
		-034287.000, 0022.000, -022640.000, 0070.000, &
		-046830.000, 0100.000, -051846.000, 0003.000, &
		-055282.500, 0001.500, -054686.800, 0001.600, &
		-050943.100, 0002.100, -042639.000, 0018.000, &
		-029380.000, 0160.000, -049889.000, 0015.000, &
		-056930.100, 0001.500, -055553.100, 0001.800, &
		-056250.300, 0001.400, -048007.900, 0001.400, &
		-039210.000, 0050.000, -049150.000, 0100.000, &
		-055105.100, 0001.600, -057708.300, 0001.500, &
		-057476.900, 0001.400, -054025.600, 0001.400, &
		-045330.000, 0011.000, -055290.000, 0010.000, &
		-056907.500, 0001.500, -060603.700, 0001.500, &
		-056037.700, 0002.500, -053901.000, 0011.000, &
		-038584.000, 0017.000, -026130.000, 0080.000, &
		-057487.000, 0003.000, -060178.500, 0001.500, &
		-059342.600, 0001.500, -056077.400, 0003.000, &
		-047350.000, 0050.000, -032700.000, 0120.000, &
		-055830.000, 0030.000, -062151.800, 0001.500, &
		-059844.100, 0001.800, -060225.000, 0001.500, &
		-051662.300, 0002.500, -042210.000, 0100.000, &
		-055476.000, 0029.000, -060661.400, 0001.500, &
		-062226.200, 0001.500, -061153.600, 0001.500, &
		-056353.500, 0001.700, -047260.000, 0040.000, &
		-052900.000, 0100.000, -061406.000, 0004.000, &
		-061646.800, 0001.500, -064470.800, 0001.500, &
		-058344.000, 0002.600, -054185.000, 0011.000, &
		-058919.000, 0020.000, -062897.100, 0001.700, &
		-064219.600, 0001.500, -061982.000, 0001.800, &
		-056343.000, 0016.000, -058896.000, 0015.000, &
		-061423.000, 0019.000, -066745.500, 0001.500, &
		-062797.000, 0004.000, -061170.000, 0010.000, &
		-051999.000, 0028.000, -055190.000, 0060.000, &
		-061839.000, 0020.000, -065512.800, 0001.500, &
		-065578.800, 0001.500, -062211.900, 0002.200, &
		-056690.000, 0100.000, -059791.000, 0020.000, &
		-067098.000, 0001.500, -065423.600, 0001.500, &
		-066002.200, 0001.700, -058837.000, 0004.000, &
		-054430.000, 0250.000, -059160.000, 0050.000, &
		-065124.800, 0001.600, -067262.100, 0001.800, &
		-065910.400, 0001.800, -062654.900, 0002.000, &
		-056410.000, 0100.000, -066029.000, 0016.000, &
		-066256.700, 0001.800, -068898.800, 0001.600, &
		-063724.000, 0003.000, -061620.000, 0030.000, &
		-052070.000, 0060.000, -063743.000, 0019.000, &
		-067303.000, 0008.000, -067879.600, 0001.600, &
		-066878.600, 0001.700, -062656.000, 0005.000, &
		-056650.000, 0100.000, -063483.000, 0017.000, &
		-065540.000, 0050.000, -070006.500, 0001.600, &
		-067085.400, 0002.000, -066978.000, 0006.000, &
		-058880.000, 0100.000, -060460.000, 0150.000, &
		-065741.000, 0008.000, -068417.300, 0001.700, &
		-069322.600, 0002.900, -067097.000, 0004.000, &
		-063080.000, 0030.000, -056300.000, 0030.000, &
		-063390.000, 0110.000, -069561.000, 0003.000, &
		-068905.900, 0003.000, -070561.800, 0001.500, &
		-064340.000, 0050.000, -067323.000, 0011.000, &
		-070139.400, 0001.900, -069906.200, 0001.800, &
		-067894.000, 0004.000, -068131.000, 0006.000, &
		-068589.300, 0002.100, -072583.600, 0001.400, &
		-068228.000, 0004.000, -067897.000, 0012.000, &
		-065410.000, 0040.000, -069705.000, 0006.000, &
		-071295.200, 0001.400, -070955.000, 0004.000, &
		-068215.000, 0011.000, -063600.000, 0230.000, &
		-056890.000, 0140.000, -065708.000, 0019.000, &
		-068060.000, 0070.000, -073423.600, 0001.400, &
		-070861.400, 0002.200, -072215.300, 0001.500, &
		-065301.000, 0015.000, -062130.000, 0060.000, &
		-051670.000, 0460.000, -062530.000, 0090.000, &
		-068466.000, 0007.000, -071858.100, 0001.700, &
		-073035.400, 0001.600, -072171.500, 0001.500, &
		-069142.000, 0014.000, -064214.000, 0020.000, &
		-057210.000, 0100.000, -062290.000, 0170.000, &
		-066440.000, 0150.000, -073214.800, 0001.500, &
		-072290.500, 0001.800, -075254.400, 0001.500, &
		-070291.000, 0009.000, -068965.000, 0012.000, &
		-060530.000, 0060.000, -071216.000, 0001.900, &
		-073918.800, 0002.200, -074601.900, 0001.500, &
		-073237.000, 0003.000, -070194.000, 0017.000, &
		-064917.000, 0030.000, -057880.000, 0150.000, &
		-071863.000, 0004.000, -072819.000, 0010.000, &
		-077028.400, 0001.500, -073455.000, 0004.000, &
		-074147.000, 0008.000, -066980.000, 0030.000, &
		-062720.000, 0120.000, -069490.000, 0090.000, &
		-073639.000, 0006.000, -075920.000, 0001.600, &
		-076070.600, 0002.400, -074445.000, 0004.000, &
		-070839.000, 0023.000, -051890.000, 0360.000, &
		-059380.000, 0300.000, -069380.000, 0030.000, &
		-072165.000, 0024.000, -077762.500, 0001.800, &
		-075891.600, 0002.300, -077894.000, 0006.000, &
		-072176.000, 0018.000, -070190.000, 0030.000, &
		-057990.000, 0190.000, -066310.000, 0120.000, &
		-072536.000, 0006.000, -076392.200, 0001.900, &
		-077978.000, 0005.000, -077697.000, 0005.000, &
		-075459.000, 0021.000, -071470.000, 0040.000, &
		-065950.000, 0070.000, -058790.000, 0300.000, &
		-065380.000, 0140.000, -070078.000, 0025.000, &
		-077596.500, 0002.100, -077499.000, 0005.000, &
		-080592.000, 0005.000, -076203.000, 0017.000, &
		-075998.000, 0008.000, -068180.000, 0100.000, &
		-064180.000, 0510.000, -069880.000, 0220.000, &
		-075343.000, 0004.000, -079010.000, 0004.000, &
		-079982.000, 0003.000, -079049.000, 0021.000, &
		-076781.000, 0021.000, -072370.000, 0060.000, &
		-066350.000, 0100.000, -075952.000, 0015.000, &
		-077776.000, 0025.000, -082430.000, 0003.000, &
		-079748.000, 0003.000, -080641.000, 0004.000, &
		-074230.000, 0170.000, -072420.000, 0100.000, &
		-078607.000, 0019.000, -081477.000, 0003.000, &
		-082164.400, 0002.800, -081099.000, 0004.000, &
		-077845.000, 0025.000, -073150.000, 0100.000, &
		-070540.000, 0130.000, -075640.000, 0060.000, &
		-083262.000, 0005.000, -082744.200, 0002.700, &
		-084518.800, 0002.500, -079279.000, 0014.000, &
		-073856.000, 0025.000, -080706.000, 0005.000, &
		-084593.100, 0002.900, -084875.500, 0002.500, &
		-083014.200, 0002.800, -079348.000, 0008.000, &
		-074180.000, 0060.000, -067440.000, 0310.000, &
		-070720.000, 0130.000, -079688.000, 0014.000, &
		-082601.000, 0004.000, -087916.800, 0002.500, &
		-084294.200, 0002.900, -083626.000, 0010.000, &
		-076720.000, 0050.000, -081709.000, 0007.000, &
		-086211.000, 0004.000, -087703.000, 0002.500, &
		-084871.000, 0003.000, -080580.000, 0040.000, &
		-075005.000, 0015.000, -064650.000, 0120.000, &
		-074947.000, 0027.000, -079350.000, 0013.000, &
		-085942.800, 0002.900, -086488.900, 0002.500, &
		-088770.500, 0002.300, -082659.000, 0005.000, &
		-080170.000, 0006.000, -071370.000, 0080.000, &
		-077786.000, 0010.000, -083652.000, 0009.000, &
		-086349.000, 0003.000, -087893.700, 0002.300, &
		-086640.000, 0003.000, -082208.000, 0012.000, &
		-075990.000, 0200.000, -068650.000, 0080.000, &
		-074811.000, 0012.000, -082923.000, 0013.000, &
		-084833.000, 0010.000, -088457.400, 0002.300, &
		-086451.600, 0002.800, -086809.000, 0004.000, &
		-078939.000, 0026.000, -064160.000, 0120.000, &
		-072688.000, 0015.000, -080160.000, 0016.000, &
		-084245.000, 0011.000, -087120.200, 0002.300, &
		-087210.700, 0002.400, -086805.000, 0004.000, &
		-083607.000, 0004.000, -077270.000, 0090.000, &
		-068518.000, 0019.000, -078836.000, 0007.000, &
		-082348.000, 0006.000, -087268.300, 0002.400, &
		-086368.500, 0002.400, -088413.300, 0002.300, &
		-084158.000, 0005.000, -082569.000, 0013.000, &
		-072940.000, 0450.000, -065813.000, 0024.000, &
		-075050.000, 0050.000, -081214.000, 0006.000, &
		-085659.600, 0002.400, -086783.900, 0002.000, &
		-087709.500, 0002.000, -086018.000, 0006.000, &
		-083451.000, 0012.000, -078340.000, 0150.000, &
		-061150.000, 0030.000, -072880.000, 0040.000, &
		-078300.000, 0040.000, -085442.000, 0003.000, &
		-085606.000, 0004.000, -088792.400, 0002.000, &
		-085819.000, 0006.000, -086073.000, 0008.000, &
		-079626.000, 0013.000, -076180.000, 0150.000, &
		-058290.000, 0040.000, -068810.000, 0070.000, &
		-076270.000, 0060.000, -082950.000, 0003.000, &
		-085608.200, 0002.700, -087542.200, 0002.000, &
		-087222.000, 0005.000, -086113.000, 0008.000, &
		-082590.000, 0040.000, -077800.000, 0300.000, &
		-054090.000, 0060.000, -066380.000, 0060.000, &
		-072520.000, 0160.000, -081283.000, 0020.000, &
		-083528.000, 0006.000, -088113.400, 0002.000, &
		-086429.000, 0004.000, -088225.000, 0006.000, &
		-083168.000, 0012.000, -081301.000, 0022.000, &
		-050860.000, 0110.000, -062150.000, 0100.000, &
		-070170.000, 0080.000, -077790.000, 0040.000, &
		-082328.000, 0013.000, -085967.200, 0002.000, &
		-087324.300, 0002.000, -087617.700, 0002.100, &
		-085519.000, 0010.000, -082193.000, 0016.000, &
		-076760.000, 0150.000, -060200.000, 0210.000, &
		-067290.000, 0140.000, -076590.000, 0040.000, &
		-079929.000, 0028.000, -086186.000, 0006.000, &
		-086017.300, 0002.300, -089219.700, 0002.100, &
		-085590.000, 0020.000, -085221.000, 0013.000, &
		-078170.000, 0090.000, -073380.000, 0070.000, &
		-078950.000, 0040.000, -083513.000, 0006.000, &
		-086337.000, 0024.000, -087950.400, 0002.100, &
		-087410.000, 0017.000, -085430.000, 0018.000, &
		-081190.000, 0120.000, -075660.000, 0180.000, &
		-071770.000, 0060.000, -076350.000, 0050.000, &
		-083559.000, 0021.000, -084569.000, 0009.000, &
		-089099.400, 0002.200, -086821.000, 0017.000, &
		-087918.000, 0008.000, -082080.000, 0050.000, &
		-068290.000, 0130.000, -075240.000, 0090.000, &
		-080760.000, 0080.000, -084601.000, 0010.000, &
		-087260.400, 0002.200, -088024.300, 0003.000, &
		-087471.000, 0008.000, -084787.000, 0017.000, &
		-080650.000, 0016.000, -074607.000, 0025.000, &
		-072260.000, 0120.000, -080370.000, 0060.000, &
		-082490.000, 0050.000, -088093.000, 0004.000, &
		-086952.000, 0003.000, -089393.000, 0005.000, &
		-085114.000, 0006.000, -083977.000, 0010.000, &
		-070940.000, 0120.000, -077360.000, 0090.000, &
		-082350.000, 0060.000, -085932.000, 0004.000, &
		-087849.000, 0005.000, -088416.000, 0005.000, &
		-087078.000, 0009.000, -084339.000, 0010.000, &
		-079493.000, 0016.000, -073240.000, 0080.000, &
		-076270.000, 0090.000, -079790.000, 0060.000, &
		-086326.000, 0008.000, -086365.000, 0008.000, &
		-089907.000, 0005.000, -086941.000, 0005.000, &
		-087135.000, 0006.000, -080617.000, 0013.000, &
		-077450.000, 0060.000, -083710.000, 0300.000, &
		-086862.000, 0018.000, -088374.000, 0006.000, &
		-088407.000, 0005.000, -086990.000, 0007.000, &
		-083568.000, 0013.000, -083760.000, 0230.000, &
		-085080.000, 0200.000, -089523.000, 0004.000, &
		-087605.000, 0005.000, -089253.000, 0005.000, &
		-084112.000, 0029.000, -082050.000, 0040.000, &
		-085021.000, 0020.000, -087605.000, 0004.000, &
		-088721.000, 0003.000, -088507.000, 0004.000, &
		-086487.000, 0006.000, -082633.000, 0010.000, &
		-076253.000, 0019.000, -067620.000, 0070.000, &
		-082940.000, 0220.000, -088345.000, 0015.000, &
		-087459.000, 0003.000, -090351.000, 0003.000, &
		-086410.000, 0200.000, -085834.000, 0016.000, &
		-072300.000, 0060.000, -086030.000, 0040.000, &
		-088217.000, 0004.000, -089254.000, 0003.000, &
		-088391.000, 0006.000, -085943.000, 0007.000, &
		-073470.000, 0070.000, -086333.000, 0019.000, &
		-086624.000, 0017.000, -090581.200, 0002.900, &
		-087995.000, 0005.000, -088658.000, 0004.000, &
		-081603.000, 0023.000, -077270.000, 0170.000, &
		-083680.000, 0150.000, -087040.000, 0020.000, &
		-089050.000, 0002.900, -089368.000, 0003.000, &
		-088330.000, 0004.000, -084424.000, 0024.000, &
		-071120.000, 0050.000, -062090.000, 0090.000, &
		-083460.000, 0029.000, -084960.000, 0070.000, &
		-090021.800, 0002.900, -088571.000, 0003.000, &
		-090560.000, 0003.000, -084680.000, 0200.000, &
		-084950.000, 0070.000, -088091.300, 0002.900, &
		-089539.000, 0004.000, -090034.100, 0003.000, &
		-087004.000, 0020.000, -082360.000, 0230.000, &
		-080140.000, 0150.000, -082760.000, 0110.000, &
		-088720.000, 0003.000, -088252.000, 0005.000, &
		-091526.100, 0003.000, -086819.000, 0006.000, &
		-085290.000, 0100.000, -077550.000, 0140.000, &
		-062290.000, 0290.000, -082250.000, 0050.000, &
		-086416.000, 0013.000, -088945.000, 0005.000, &
		-090399.300, 0002.900, -088644.000, 0009.000, &
		-085110.000, 0019.000, -066260.000, 0180.000, &
		-079580.000, 0100.000, -086709.000, 0020.000, &
		-087232.000, 0008.000, -091654.200, 0002.900, &
		-087998.000, 0004.000, -087653.000, 0023.000, &
		-068270.000, 0130.000, -078590.000, 0070.000, &
		-083940.000, 0060.000, -087733.000, 0008.000, &
		-090068.200, 0002.800, -089475.000, 0008.000, &
		-087182.000, 0008.000, -083780.000, 0100.000, &
		-078750.000, 0140.000, -072240.000, 0100.000, &
		-075770.000, 0100.000, -083973.000, 0019.000, &
		-085800.000, 0170.000, -091103.800, 0002.600, &
		-088423.000, 0008.000, -089386.000, 0019.000, &
		-083771.000, 0024.000, -081810.000, 0050.000, &
		-073820.000, 0080.000, -074550.000, 0190.000, &
		-080950.000, 0150.000, -085841.000, 0028.000, &
		-089203.900, 0002.500, -089591.600, 0002.400, &
		-088551.000, 0026.000, -086270.000, 0020.000, &
		-082510.000, 0060.000, -077110.000, 0060.000, &
		-083580.000, 0050.000, -089946.000, 0002.600, &
		-088327.000, 0002.400, -090307.200, 0002.700, &
		-086073.000, 0006.000, -085050.000, 0140.000, &
		-078140.000, 0060.000, -083420.000, 0030.000, &
		-087820.500, 0002.600, -089223.800, 0002.000, &
		-089171.300, 0001.900, -087937.000, 0004.000, &
		-085258.000, 0016.000, -081070.000, 0040.000, &
		-081060.000, 0050.000, -088237.300, 0001.400, &
		-087619.900, 0002.000, -090525.100, 0001.500, &
		-087368.000, 0004.000, -087659.600, 0002.000, &
		-081740.000, 0040.000, -080420.000, 0080.000, &
		-085898.400, 0002.000, -088258.000, 0003.000, &
		-089024.800, 0002.300, -088846.100, 0002.500, &
		-087191.500, 0002.000, -084113.000, 0017.000, &
		-079550.000, 0250.000, -077810.000, 0080.000, &
		-086021.000, 0011.000, -086400.000, 0030.000, &
		-090067.100, 0002.300, -087916.000, 0005.000, &
		-089174.000, 0007.000, -084347.000, 0024.000, &
		-077010.000, 0070.000, -083504.000, 0025.000, &
		-086705.000, 0006.000, -088286.000, 0004.000, &
		-088982.000, 0004.000, -088319.000, 0005.000, &
		-086243.000, 0012.000, -082790.000, 0100.000, &
		-074020.000, 0170.000, -083330.000, 0050.000, &
		-084610.000, 0040.000, -088992.000, 0003.000, &
		-087736.000, 0004.000, -089860.800, 0001.600, &
		-085928.000, 0006.000, -085470.000, 0018.000, &
		-078820.000, 0400.000, -073020.000, 0170.000, &
		-080620.000, 0120.000, -084624.000, 0022.000, &
		-087006.000, 0004.000, -088507.000, 0004.000, &
		-088698.100, 0001.800, -087506.000, 0005.000, &
		-085080.000, 0011.000, -081360.000, 0050.000, &
		-070010.000, 0200.000, -080130.000, 0080.000, &
		-082330.000, 0070.000, -087348.000, 0004.000, &
		-086897.000, 0010.000, -089881.500, 0001.500, &
		-086853.000, 0008.000, -087291.000, 0007.000, &
		-068490.000, 0140.000, -077380.000, 0070.000, &
		-082020.000, 0070.000, -085206.000, 0004.000, &
		-087457.000, 0004.000, -088428.000, 0004.000, &
		-088076.000, 0006.000, -086714.000, 0007.000, &
		-083750.000, 0100.000, -079730.000, 0410.000, &
		-076610.000, 0080.000, -079730.000, 0080.000, &
		-085222.000, 0012.000, -085715.000, 0011.000, &
		-089292.000, 0004.000, -087171.000, 0005.000, &
		-088447.000, 0008.000, -083740.000, 0050.000, &
		-071190.000, 0220.000, -079020.000, 0210.000, &
		-082970.000, 0080.000, -085888.000, 0026.000, &
		-087659.000, 0005.000, -088086.000, 0005.000, &
		-087570.000, 0005.000, -074020.000, 0160.000, &
		-082430.000, 0110.000, -083990.000, 0060.000, &
		-088125.000, 0007.000, -086906.000, 0005.000, &
		-088965.000, 0005.000, -085252.000, 0026.000, &
		-084750.000, 0200.000, -077870.000, 0090.000, &
		-083821.000, 0023.000, -086506.000, 0011.000, &
		-087662.000, 0007.000, -087867.000, 0005.000, &
		-086667.000, 0011.000, -084641.000, 0012.000, &
		-080920.000, 0150.000, -074460.000, 0050.000, &
		-079550.000, 0040.000, -086429.000, 0007.000, &
		-086354.000, 0005.000, -088903.000, 0005.000, &
		-086030.000, 0070.000, -086500.000, 0050.000, &
		-081370.000, 0050.000, -079160.000, 0060.000, &
		-069480.000, 0300.000, -076507.000, 0029.000, &
		-082383.000, 0007.000, -086556.000, 0005.000, &
		-087732.000, 0005.000, -087130.000, 0050.000, &
		-085910.000, 0050.000, -083200.000, 0050.000, &
		-079700.000, 0070.000, -074020.000, 0150.000, &
		-072290.000, 0080.000, -080110.000, 0040.000, &
		-082896.000, 0022.000, -088272.000, 0005.000, &
		-086531.000, 0005.000, -087574.000, 0011.000, &
		-083137.000, 0015.000, -068880.000, 0120.000, &
		-075690.000, 0060.000, -080710.000, 0007.000, &
		-084924.000, 0005.000, -087238.000, 0004.000, &
		-086973.000, 0013.000, -084844.000, 0013.000, &
		-082060.000, 0040.000, -077540.000, 0050.000, &
		-072080.000, 0120.000, -072990.000, 0060.000, &
		-077053.000, 0016.000, -083273.000, 0012.000, &
		-084327.000, 0004.000, -088088.000, 0004.000, &
		-084700.000, 0007.000, -084471.000, 0020.000, &
		-078380.000, 0040.000, -068320.000, 0090.000, &
		-074472.000, 0016.000, -079732.000, 0021.000, &
		-082983.000, 0025.000, -085445.000, 0004.000, &
		-086026.000, 0003.000, -084203.000, 0004.000, &
		-080472.000, 0029.000, -075943.000, 0013.000, &
		-069980.000, 0040.000, -065500.000, 0100.000, &
		-070538.000, 0020.000, -077847.000, 0020.000, &
		-080027.000, 0007.000, -084542.000, 0004.000, &
		-083798.000, 0003.000, -085960.000, 0003.000, &
		-081090.000, 0040.000, -078986.000, 0015.000, &
		-071590.000, 0100.000, -067745.000, 0028.000, &
		-073979.000, 0028.000, -078200.000, 0017.000, &
		-081616.000, 0004.000, -083078.000, 0003.000, &
		-084012.000, 0003.000, -082970.000, 0004.000, &
		-079526.000, 0005.000, -074380.000, 0030.000, &
		-063370.000, 0040.000, -071840.000, 0050.000, &
		-074940.000, 0060.000, -080441.000, 0004.000, &
		-080760.000, 0004.000, -083758.000, 0003.000, &
		-081425.000, 0004.000, -081975.000, 0004.000, &
		-075646.000, 0022.000, -060210.000, 0050.000, &
		-068120.000, 0070.000, -073020.000, 0070.000, &
		-077110.000, 0040.000, -079636.000, 0008.000, &
		-081442.000, 0003.000, -081278.000, 0004.000, &
		-080660.000, 0004.000, -078000.000, 0005.000, &
		-072950.000, 0040.000, -055700.000, 0080.000, &
		-065060.000, 0080.000, -069200.000, 0070.000, &
		-075730.000, 0070.000, -076760.000, 0060.000, &
		-080935.000, 0003.000, -079458.000, 0006.000, &
		-081000.000, 0005.000, -077125.000, 0008.000, &
		-076099.000, 0011.000, -067860.000, 0150.000, &
		-052300.000, 0110.000, -061500.000, 0100.000, &
		-067250.000, 0080.000, -072190.000, 0060.000, &
		-075470.000, 0040.000, -078156.000, 0003.000, &
		-079052.000, 0003.000, -079276.000, 0003.000, &
		-077555.000, 0004.000, -075367.000, 0004.000, &
		-070880.000, 0060.000, -064330.000, 0110.000, &
		-047580.000, 0360.000, -063810.000, 0150.000, &
		-070430.000, 0120.000, -072490.000, 0220.000, &
		-077418.000, 0004.000, -076874.000, 0011.000, &
		-079346.000, 0003.000, -076239.000, 0018.000, &
		-076278.000, 0004.000, -070680.000, 0050.000, &
		-068000.000, 0060.000, -066800.000, 0080.000, &
		-070988.000, 0011.000, -074385.000, 0004.000, &
		-076073.000, 0005.000, -077146.000, 0003.000, &
		-076455.000, 0005.000, -075135.000, 0005.000, &
		-071499.000, 0005.000, -054950.000, 0900.000, &
		-064990.000, 0120.000, -068000.000, 0080.000, &
		-073693.000, 0004.000, -073606.000, 0020.000, &
		-077060.000, 0003.000, -074800.000, 0007.000, &
		-075771.000, 0007.000, -071113.000, 0009.000, &
		-069324.000, 0012.000, -062210.000, 0160.000, &
		-070956.000, 0004.000, -073398.000, 0006.000, &
		-074587.000, 0003.000, -074663.000, 0003.000, &
		-074199.000, 0004.000, -071633.000, 0005.000, &
		-068764.000, 0005.000, -063720.000, 0060.000, &
		-070160.000, 0030.000, -071270.000, 0070.000, &
		-074773.000, 0003.000, -072899.000, 0003.000, &
		-074718.000, 0003.000, -070770.000, 0070.000, &
		-070127.000, 0006.000, -063750.000, 0060.000, &
		-060640.000, 0060.000, -070669.000, 0016.000, &
		-072569.000, 0003.000, -073378.000, 0003.000, &
		-072893.000, 0003.000, -071322.000, 0005.000, &
		-069152.000, 0005.000, -065023.000, 0007.000, &
		-068410.000, 0110.000, -072465.000, 0003.000, &
		-071748.000, 0003.000, -073717.000, 0003.000, &
		-070150.000, 0050.000, -070399.000, 0009.000, &
		-064647.000, 0009.000, -062622.000, 0012.000, &
		-054700.000, 0160.000, -070201.000, 0003.000, &
		-071829.000, 0003.000, -072081.000, 0003.000, &
		-071261.000, 0012.000, -069166.000, 0012.000, &
		-066064.000, 0023.000, -062220.000, 0050.000, &
		-056730.000, 0060.000, -069374.000, 0010.000, &
		-070096.000, 0007.000, -072546.000, 0003.000, &
		-070102.000, 0005.000, -070536.000, 0007.000, &
		-056980.000, 0070.000, -053410.000, 0060.000, &
		-066870.000, 0200.000, -069472.000, 0006.000, &
		-070834.000, 0003.000, -070772.000, 0003.000, &
		-069434.000, 0007.000, -066890.000, 0050.000, &
		-063420.000, 0090.000, -067220.000, 0080.000, &
		-070701.000, 0003.000, -069480.000, 0003.000, &
		-070418.000, 0004.000, -066200.000, 0030.000, &
		-056022.000, 0016.000, -047490.000, 0170.000, &
		-066058.000, 0009.000, -068572.000, 0003.000, &
		-069542.000, 0003.000, -069176.000, 0003.000, &
		-067338.000, 0004.000, -064570.000, 0005.000, &
		-049770.000, 0080.000, -067953.000, 0003.000, &
		-067846.000, 0003.000, -069682.000, 0003.000, &
		-066391.000, 0011.000, -066063.000, 0028.000, &
		-060460.000, 0300.000, -046080.000, 0060.000, &
		-065517.000, 0003.000, -067471.000, 0003.000, &
		-068064.000, 0003.000, -067207.000, 0004.000, &
		-065203.000, 0010.000, -062100.000, 0200.000, &
		-064240.000, 0110.000, -065680.000, 0040.000, &
		-068189.000, 0003.000, -066050.000, 0005.000, &
		-066346.000, 0004.000, -061550.000, 0040.000, &
		-049178.000, 0017.000, -040060.000, 0170.000, &
		-064700.000, 0040.000, -066389.000, 0003.000, &
		-066386.000, 0003.000, -065177.000, 0006.000, &
		-062738.000, 0006.000, -059370.000, 0100.000, &
		-054770.000, 0220.000, -042600.000, 0090.000, &
		-062090.000, 0100.000, -065976.000, 0003.000, &
		-064990.000, 0003.000, -065952.000, 0004.000, &
		-061990.000, 0020.000, -038380.000, 0060.000, &
		-063621.000, 0003.000, -064907.000, 0003.000, &
		-064530.000, 0004.000, -062938.000, 0004.000, &
		-060175.000, 0020.000, -056260.000, 0080.000, &
		-062593.000, 0003.000, -063079.000, 0003.000, &
		-064933.000, 0003.000, -061894.000, 0012.000, &
		-061589.000, 0008.000, -056110.000, 0160.000, &
		-041898.000, 0018.000, -032130.000, 0180.000, &
		-059940.000, 0060.000, -062291.000, 0006.000, &
		-063298.000, 0003.000, -062550.000, 0004.000, &
		-060596.000, 0005.000, -057470.000, 0100.000, &
		-034910.000, 0100.000, -060260.000, 0100.000, &
		-062998.000, 0003.000, -061319.000, 0004.000, &
		-061575.000, 0004.000, -057090.000, 0060.000, &
		-030130.000, 0060.000, -058805.000, 0020.000, &
		-060930.000, 0003.000, -061280.000, 0003.000, &
		-060371.000, 0004.000, -058078.000, 0005.000, &
		-054810.000, 0080.000, -056250.000, 0050.000, &
		-060117.000, 0003.000, -059802.000, 0003.000, &
		-060770.000, 0003.000, -057311.000, 0019.000, &
		-033933.000, 0018.000, -023530.000, 0190.000, &
		-057727.000, 0003.000, -059217.000, 0003.000, &
		-059314.000, 0003.000, -057834.000, 0004.000, &
		-026420.000, 0110.000, -056491.000, 0005.000, &
		-057382.000, 0006.000, -059262.000, 0003.000, &
		-056741.000, 0004.000, -056390.000, 0050.000, &
		-051470.000, 0190.000, -021240.000, 0060.000, &
		-056265.000, 0005.000, -057558.000, 0003.000, &
		-056886.000, 0004.000, -053870.000, 0040.000, &
		-056951.000, 0003.000, -055575.000, 0004.000, &
		-055851.000, 0003.000, -025324.000, 0019.000, &
		-014330.000, 0190.000, -052300.000, 0050.000, &
		-054702.000, 0003.000, -055171.900, 0002.900, &
		-054488.000, 0003.000, -017210.000, 0110.000, &
		-053501.000, 0003.000, -053394.100, 0002.800, &
		-054582.600, 0003.000, -051470.000, 0100.000, &
		-011890.000, 0060.000, -050996.000, 0003.000, &
		-052394.200, 0002.800, -052892.200, 0002.800, &
		-051726.000, 0004.000, -049705.000, 0010.000, &
		-050338.000, 0024.000, -052446.500, 0002.700, &
		-050530.000, 0100.000, -050440.000, 0100.000, &
		-045780.000, 0210.000, -016321.000, 0019.000, &
		-049110.000, 0040.000, -050475.100, 0002.700, &
		-050365.000, 0006.000, -049306.000, 0016.000, &
		-046620.000, 0050.000, -046690.000, 0070.000, &
		-049791.900, 0002.700, -048939.000, 0003.000, &
		-049647.000, 0005.000, -045840.000, 0030.000, &
		-047416.200, 0002.800, -048444.000, 0003.000, &
		-048256.000, 0005.000, -046062.000, 0007.000, &
		-046436.000, 0003.000, -048250.000, 0003.000, &
		-045450.000, 0100.000, -044542.000, 0025.000, &
		-006874.000, 0028.000, -043290.000, 0030.000, &
		-045299.000, 0003.000, -046369.100, 0003.000, &
		-045813.000, 0009.000, -041500.000, 0040.000, &
		-042844.000, 0026.000, -045709.500, 0003.000, &
		-044220.000, 0005.000, -044259.000, 0003.000, &
		-039540.000, 0250.000, -041402.000, 0014.000, &
		-043393.000, 0003.000, -043826.000, 0003.000, &
		-042813.000, 0003.000, -038620.000, 0060.000, &
		-042515.000, 0003.000, -041933.000, 0003.000, &
		-043003.000, 0003.000, -039172.000, 0020.000, &
		-037790.000, 0030.000, -039910.000, 0003.000, &
		-041222.000, 0003.000, -041224.000, 0003.000, &
		-038673.000, 0004.000, -039022.000, 0003.000, &
		-041142.000, 0003.000, -038333.000, 0007.000, &
		-037827.000, 0006.000, -035480.000, 0200.000, &
		-037985.000, 0010.000, -038993.000, 0003.000, &
		-038462.000, 0013.000, -036491.000, 0011.000, &
		-034310.000, 0160.000, -035580.000, 0150.000, &
		-038714.000, 0003.000, -036710.000, 0200.000, &
		-037331.000, 0006.000, -032889.000, 0016.000, &
		-034360.000, 0011.000, -036401.000, 0003.000, &
		-036715.000, 0004.000, -035701.000, 0006.000, &
		-033870.000, 0050.000, -030690.000, 0090.000, &
		-035892.000, 0004.000, -034843.000, 0004.000, &
		-036303.000, 0004.000, -032787.000, 0016.000, &
		-033405.000, 0004.000, -034544.000, 0004.000, &
		-034487.000, 0004.000, -027450.000, 0200.000, &
		-032442.000, 0004.000, -032539.000, 0004.000, &
		-034787.000, 0004.000, -032295.000, 0012.000, &
		-032255.000, 0023.000, -029700.000, 0500.000, &
		-031700.000, 0004.000, -032821.000, 0004.000, &
		-032594.000, 0004.000, -031070.000, 0050.000, &
		-028270.000, 0140.000, -028300.000, 0040.000, &
		-029460.000, 0040.000, -032671.000, 0004.000, &
		-031166.000, 0005.000, -031852.000, 0005.000, &
		-017970.000, 0700.000, -028292.000, 0021.000, &
		-030446.000, 0004.000, -031165.000, 0004.000, &
		-030566.000, 0005.000, -028400.000, 0050.000, &
		-019640.000, 0170.000, -029932.000, 0005.000, &
		-029606.000, 0004.000, -030979.000, 0004.000, &
		-027520.000, 0080.000, -019540.000, 0150.000, &
		-027432.000, 0019.000, -029119.000, 0004.000, &
		-029572.000, 0004.000, -028140.000, 0100.000, &
		-025270.000, 0070.000, -020920.000, 0100.000, &
		-026627.000, 0021.000, -027280.000, 0050.000, &
		-029529.000, 0004.000, -027073.000, 0007.000, &
		-020400.000, 0080.000, -008940.000, 0690.000, &
		-023750.000, 0050.000, -026413.000, 0015.000, &
		-027688.000, 0004.000, -027205.000, 0016.000, &
		-025300.000, 0030.000, -021470.000, 0050.000, &
		-010740.000, 0170.000, -024420.000, 0170.000, &
		-027370.000, 0004.000, -026006.000, 0015.000, &
		-025957.000, 0010.000, -020800.000, 0060.000, &
		-010770.000, 0150.000, -023153.000, 0016.000, &
		-025292.000, 0004.000, -025784.000, 0004.000, &
		-024810.000, 0007.000, -021580.000, 0040.000, &
		-017350.000, 0070.000, -012290.000, 0100.000, &
		-024716.000, 0004.000, -024369.000, 0004.000, &
		-025132.000, 0004.000, -020730.000, 0040.000, &
		-011900.000, 0070.000,  000650.000, 0690.000, &
		-022312.000, 0006.000, -023846.000, 0004.000, &
		-023793.000, 0004.000, -021084.000, 0008.000, &
		-017555.000, 0030.000, -013030.000, 0050.000, &
		-001270.000, 0170.000, -020969.000, 0020.000, &
		-022278.000, 0004.000, -023809.000, 0004.000, &
		-020052.000, 0009.000, -018205.000, 0010.000, &
		-012490.000, 0060.000, -001420.000, 0150.000, &
		-016270.000, 0150.000, -021049.000, 0006.000, &
		-022476.000, 0004.000, -020079.000, 0004.000, &
		-017169.000, 0007.000, -013290.000, 0040.000, &
		-008670.000, 0070.000, -002960.000, 0100.000, &
		-016774.000, 0004.000, -021772.000, 0004.000, &
		-018894.000, 0004.000, -017492.000, 0004.000, &
		-012560.000, 0040.000, -002710.000, 0070.000, &
		-013652.000, 0010.000, -017638.000, 0004.000, &
		-018282.000, 0004.000, -016390.000, 0004.000, &
		-012902.000, 0008.000, -008973.000, 0029.000, &
		-003830.000, 0050.000,  008890.000, 0170.000, &
		-009262.000, 0012.000, -014752.000, 0004.000, &
		-014815.000, 0004.000, -015977.000, 0004.000, &
		-011995.000, 0009.000, -009623.000, 0011.000, &
		-003400.000, 0050.000,  008620.000, 0160.000, &
		-010494.000, 0003.000, -011873.000, 0006.000, &
		-012457.000, 0004.000, -011674.000, 0005.000, &
		-008780.000, 0008.000, -004200.000, 0040.000, &
		 000800.000, 0070.000,  007080.000, 0110.000, &
		-007571.000, 0004.000, -008142.000, 0004.000, &
		-010394.000, 0004.000, -008640.000, 0005.000, &
		-008682.000, 0005.000, -003600.000, 0040.000, &
		 007240.000, 0080.000, -005244.000, 0008.000, &
		-006676.000, 0005.000, -006603.000, 0013.000, &
		-005722.000, 0008.000, -003572.000, 0009.000, &
		 000311.000, 0030.000,  006100.000, 0070.000, &
		-000188.100, 0002.700, -001218.000, 0012.000, &
		-004493.000, 0004.000, -003403.000, 0006.000, &
		-004343.000, 0010.000, -000983.000, 0010.000, &
		 000075.000, 0011.000,  006380.000, 0070.000, &
		 001710.000, 0090.000, -000542.900, 0003.000, &
		-001269.000, 0007.000, -001193.000, 0008.000, &
		 000292.000, 0008.000,  002509.000, 0008.000, &
		 005970.000, 0060.000,  010890.000, 0070.000, &
		 017680.000, 0120.000,  001760.000, 0004.000, &
		 002231.000, 0005.000,  000231.000, 0008.000, &
		 002960.000, 0013.000,  003269.000, 0009.000, &
		 008060.000, 0040.000,  017680.000, 0100.000, &
		 004383.000, 0008.000,  003634.000, 0005.000, &
		 004293.000, 0015.000,  005864.000, 0010.000, &
		 008685.000, 0013.000,  012160.000, 0030.000, &
		 017020.000, 0090.000,  008351.700, 0002.700, &
		 008090.000, 0013.000,  005199.000, 0004.000, &
		 007036.000, 0006.000,  006627.000, 0012.000, &
		 010820.000, 0050.000,  012348.000, 0014.000, &
		 018600.000, 0090.000,  010520.000, 0080.000, &
		 008828.300, 0003.000,  008609.000, 0008.000, &
		 009363.000, 0012.000,  011540.000, 0050.000, &
		 014450.000, 0050.000,  010590.000, 0004.000, &
		 011456.000, 0005.000,  010250.000, 0011.000, &
		 013730.000, 0050.000,  014647.000, 0022.000, &
		 013266.000, 0008.000,  012938.000, 0007.000, &
		 014500.000, 0050.000,  016917.000, 0011.000, &
		 016367.000, 0002.700,  016380.000, 0040.000, &
		 014303.000, 0006.000,  016603.000, 0006.000, &
		 017182.000, 0013.000,  021940.000, 0070.000, &
		 018381.000, 0003.000,  017232.400, 0002.900, &
		 017817.000, 0008.000,  019357.000, 0028.000, &
		 022310.000, 0070.000,  021620.000, 0050.000, &
		 018804.000, 0004.000,  020204.000, 0005.000, &
		 019980.000, 0013.000,  023780.000, 0070.000, &
		 023840.000, 0090.000,  021988.000, 0003.000, &
		 021626.000, 0008.000,  022283.000, 0009.000, &
		 024310.000, 0060.000,  027210.000, 0140.000, &
		 023662.700, 0002.700,  024303.000, 0004.000, &
		 023183.000, 0006.000,  026015.000, 0012.000, &
		 027170.000, 0030.000,  029590.000, 0090.000, &
		 027172.600, 0002.700,  025848.700, 0002.800, &
		 025803.900, 0002.900,  026824.000, 0010.000, &
		 028936.000, 0004.000,  028890.000, 0004.000, &
		 026749.000, 0004.000,  028856.000, 0006.000, &
		 029209.000, 0016.000,  032660.000, 0110.000, &
		 030900.000, 0110.000,  029581.000, 0003.000, &
		 029887.000, 0009.000,  031181.000, 0009.000, &
		 033740.000, 0080.000,  030858.700, 0002.300, &
		 032168.000, 0004.000,  031600.000, 0006.000, &
		 035220.000, 0050.000,  035910.000, 0100.000, &
		 033812.100, 0002.300,  033422.400, 0002.700, &
		 033780.000, 0050.000,  035620.000, 0050.000, &
		 035444.400, 0002.100,  035924.000, 0009.000, &
		 034587.000, 0004.000,  038349.000, 0019.000, &
		 038729.400, 0002.100,  037485.800, 0002.300, &
		 036915.000, 0003.000,  040020.000, 0050.000, &
		 040607.000, 0004.000,  040334.000, 0005.000, &
		 038141.900, 0002.100,  039952.000, 0009.000, &
		 040335.000, 0008.000,  044250.000, 0050.000, &
		 042330.000, 0050.000,  040915.500, 0002.100, &
		 041039.200, 0002.300,  042160.000, 0050.000, &
		 045340.000, 0200.000,  042441.700, 0002.100, &
		 043370.000, 0050.000,  042879.000, 0004.000, &
		 047640.000, 0100.000,  045387.300, 0002.100, &
		 044868.300, 0002.100,  045090.000, 0006.000, &
		 050910.000, 0300.000,  047305.900, 0002.100, &
		 047451.600, 0002.100,  046160.100, 0002.100, &
		 048420.000, 0050.000,  049380.000, 0040.000, &
		 050570.800, 0002.100,  049306.600, 0002.300, &
		 048584.800, 0002.100,  049385.000, 0003.000, &
		 052711.000, 0005.000,  052321.000, 0014.000, &
		 050122.500, 0002.100,  051498.000, 0013.000, &
		 051702.000, 0005.000,  054260.000, 0070.000, &
		 052952.000, 0002.100,  052931.100, 0002.100, &
		 053700.000, 0006.000,  057410.000, 0200.000, &
		 054713.800, 0002.100,  055463.400, 0002.200, &
		 054800.700, 0002.200,  059320.000, 0040.000, &
		 059922.000, 0011.000,  057751.000, 0003.000, &
		 057169.500, 0002.300,  057177.200, 0002.400, &
		 058683.000, 0005.000,  059802.000, 0005.000, &
		 059877.200, 0002.300,  058449.200, 0002.100, &
		 060700.000, 0050.000,  061460.000, 0005.000, &
		 063175.000, 0014.000,  061891.900, 0002.800, &
		 060998.000, 0002.200,  061809.600, 0002.300, &
		 063380.000, 0006.000,  065391.000, 0015.000, &
		 064990.000, 0018.000,  062614.000, 0003.000, &
		 064087.400, 0002.400,  070120.000, 0040.000, &
		 065528.000, 0004.000,  065484.000, 0006.000, &
		 066130.000, 0008.000,  068550.000, 0040.000, &
		 067388.000, 0005.000,  068107.000, 0020.000, &
		 067237.000, 0004.000,  070290.000, 0060.000, &
		 071888.000, 0014.000,  070746.000, 0005.000, &
		 069842.800, 0002.600,  069717.900, 0002.300, &
		 071110.000, 0050.000,  072985.000, 0011.000, &
		 072951.000, 0006.000,  071167.000, 0003.000, &
		 074060.000, 0021.000,  076642.000, 0023.000, &
		 075222.000, 0011.000,  074129.000, 0005.000, &
		 074506.000, 0006.000,  075978.000, 0009.000, &
		 076030.000, 0005.000,  077290.000, 0050.000, &
		 076814.000, 0005.000,  082857.000, 0018.000, &
		 079296.000, 0007.000,  079007.000, 0002.600, &
		 079339.000, 0005.000,  081338.000, 0012.000, &
		 081994.000, 0006.000,  080900.000, 0004.000, &
		 084711.000, 0024.000,  084083.000, 0011.000, &
		 083788.000, 0005.000,  084835.000, 0007.000, &
		 086848.000, 0013.000,  085482.000, 0007.000, &
		 087550.000, 0050.000,  087793.000, 0017.000, &
		 094234.000, 0029.000,  088585.000, 0007.000, &
		 090220.000, 0030.000,  094018.000, 0011.000, &
		 095840.000, 0050.000,  098280.000, 0040.000, &
		 098130.000, 0070.000,  106580.000, 0040.000, &
		 110090.000, 0060.000 /
!---------------------------------------------------------------------!
!                                                                     !
!          MODULE CONTAINING USEFUL MATHEMATICAL FUNCTIONS            !                
!                                                                     !
!---------------------------------------------------------------------!

 MODULE math

	USE input
	USE lgfactor

	IMPLICIT NONE

	REAL(KIND = 16), PARAMETER :: EPS = 1.3877787807814457e-17

	REAL(KIND = 16), PARAMETER :: PI = 3.141592653589793238462643
	REAL(KIND = 16), PARAMETER :: PI_C = 0.12698727186848193957
	DOUBLE PRECISION, PARAMETER :: I_4PI = 0.0795774715459
	REAL(KIND = 16), PARAMETER :: FOUR_PI = 12.5663706143591729539

	DOUBLE PRECISION, PARAMETER :: ALPHA = 0.333333333333
	DOUBLE PRECISION, PARAMETER :: I_SALPHA3 = 0.280565858875

 CONTAINS

        !---------------------------------------------------------------------!
        !   This routine performs the composite Simpson's rule integration    !
        !   of a function f defined by a table of n equispaced values.        !
        !    								      !
        !                        See: Koonin, Computational Physics, p.9      !
        !    								      !
        !    The parameters are:  					      !
        !     f = Array of values of the function f(x)			      !
        !     n = Number of points x_k			      		      !
        !     h = The uniform spacing between x values: h = x_k+1 - x_k       !
        !    result = Estimate of the integral that is returned to caller.    !
        !---------------------------------------------------------------------!

	SUBROUTINE simps(functi,npoint,step,result)

        INTEGER :: npanel, npoint, nhalf, nbegin, nend, i

        DOUBLE PRECISION :: step, result, x
        DOUBLE PRECISION, INTENT(IN) :: functi(:)

        ! Check to see if number of panels is even.  Number of panels is N-1.

	npanel = npoint - 1
	nhalf  = npanel/2
	nbegin = 1
	result = 0.0
      
	! Number of panels is odd.  Use 3/8 rule on first three
	! panels, 1/3 rule on rest of them.

	IF ((npanel-2*nhalf).NE.0) THEN

	     result = 3.0*step*( functi(1) + 3.0*(functi(2)+functi(3)) + functi(4))/8.0
	 
	     IF (npoint.EQ.4) RETURN
	 
	     nbegin=4
	 
	END IF

	! Apply 1/3 rule - add in first, second, last values

	result = result + step*(functi(nbegin) + 4.0*functi(nbegin+1) + functi(npoint )/3.0)
	nbegin = nbegin+2
      
	IF (nbegin.EQ.npoint) THEN
	    RETURN
	ELSE
      
		x = 0.0
		nend = npoint - 2
		
		DO i = nbegin,nend,2
			x = x + functi(i) + 2.0*functi(i+1) 
		END DO
	  
		result = result + 2.0*step*x/3.0

		RETURN
	  
	END IF

        END SUBROUTINE simps
	
	
	! Funciones de apoyo
	FUNCTION c(N, L)
		REAL(KIND = 16) c
		INTEGER, INTENT(IN) :: N, L

		c = PI_C * PAR(n) * EXP(0.5 * (DDLogFactorials(n) + DDLogSemiFactorials(n + l)))
		RETURN
	END FUNCTION c

	FUNCTION L(a)
		INTEGER L
		INTEGER, INTENT(IN) :: a

		L = (a + 1) / 2
		RETURN
	END FUNCTION L

	FUNCTION J(a)
		INTEGER J
		INTEGER, INTENT(IN) :: a

		J = ((a - L(a)) * 2) + 1
		RETURN
	END FUNCTION J

	FUNCTION LS(a)
		DOUBLE PRECISION LS
		INTEGER, INTENT(IN) :: a

		LS = (0.5 * PAR(a)) / ((a / 2) + 1)
		RETURN
	END FUNCTION LS

	FUNCTION DIM(a)
		INTEGER DIM
		INTEGER, INTENT(IN) :: a

		DIM = ((N_0 - L(a)) / 2) + 1
		RETURN
	END FUNCTION DIM

        ! Giving the parity of an integer n (+1 or -1)
	FUNCTION PAR(n)
		INTEGER PAR
		INTEGER, INTENT(IN) :: n

		IF (MOD(n, 2) .EQ. 0) THEN
			PAR = 1
		ELSE
			PAR = -1
		END IF
		RETURN
	END FUNCTION PAR

	SUBROUTINE SWAP(a, b)
		INTEGER, INTENT(INOUT) :: a, b

		INTEGER c

		c = a
		a = b
		b = c
		RETURN
	END SUBROUTINE SWAP

	FUNCTION CUAD2(la, lb, k)
		DOUBLE PRECISION CUAD2
		INTEGER, INTENT(IN) :: la, lb, k

		CUAD2 = (la * (la + 1.0)) + (lb * (lb + 1.0)) - (k * (k + 1.0))
		RETURN
	END FUNCTION CUAD2

	FUNCTION MIN_3N(N1, N2, k)
		INTEGER MIN_3N
		INTEGER, INTENT(IN) :: N1, N2, k

		MIN_3N = MAX((ABS(N1 - N2) - k), 0) / 2
		RETURN
	END FUNCTION MIN_3N

	FUNCTION MIN_5N(n1, l1, n2, l2, k)
		INTEGER MIN_5N
		INTEGER, INTENT(IN) :: n1, l1, n2, l2, k

		INTEGER N1_arg, N2_arg

		N1_arg = 2 * n1 + l1
		N2_arg = 2 * n2 + l2
		MIN_5N = MAX((ABS(N1_arg - N2_arg) - k) / 2, 0)
		RETURN
	END FUNCTION MIN_5N

	FUNCTION Char2Int(str)
		INTEGER Char2Int
		CHARACTER(*), INTENT(IN) :: str

		INTEGER idx

		idx = 1
		Char2Int = 0
		DO WHILE (idx .LE. LEN(str))
			SELECT CASE (str(idx:idx))
			CASE ('0')
				Char2Int = Char2Int * 10
			CASE ('1')
				Char2Int = (Char2Int * 10) + 1
			CASE ('2')
				Char2Int = (Char2Int * 10) + 2
			CASE ('3')
				Char2Int = (Char2Int * 10) + 3
			CASE ('4')
				Char2Int = (Char2Int * 10) + 4
			CASE ('5')
				Char2Int = (Char2Int * 10) + 5
			CASE ('6')
				Char2Int = (Char2Int * 10) + 6
			CASE ('7')
				Char2Int = (Char2Int * 10) + 7
			CASE ('8')
				Char2Int = (Char2Int * 10) + 8
			CASE ('9')
				Char2Int = (Char2Int * 10) + 9
			CASE DEFAULT
				RETURN
			END SELECT
			idx = idx + 1
		END DO
		RETURN
	END FUNCTION Char2Int

	SUBROUTINE Int2Char(char_out, num_in)
		CHARACTER(*), INTENT(INOUT) :: char_out
		INTEGER, INTENT(IN) :: num_in

		INTEGER max_len, cur_len, num, i
		CHARACTER digit

		max_len = LEN(char_out)
		cur_len = 0
		char_out = ""
		num = num_in
		DO WHILE ((cur_len .LT. max_len) .AND. (num .GT. 0))
			digit = CHAR(MOD(num, 10) + 48)
			num = num / 10
			cur_len = cur_len + 1
			IF (cur_len .GT. 1) THEN
				DO i = cur_len, 2, -1
					char_out(i:i) = char_out(i - 1:i - 1)
				END DO
			END IF
			char_out(1:1) = digit
		END DO
		char_out(cur_len + 1:cur_len + 1) = CHAR(0)
		RETURN
	END SUBROUTINE Int2Char

END MODULE math
	CHARACTER(5), DIMENSION(0:102) :: Nucleus_specie
	DATA Nucleus_specie / "n", &
		"H",  "He", "Li", "Be", "B",  "C",  "N",  "O",  "F",  "Ne", &
		"Na", "Mg", "Al", "Si", "P",  "S",  "Cl", "Ar", "K",        &
		"Ca", "Sc", "Ti", "V",  "Cr", "Mn", "Fe", "Co", "Ni",       &
		"Cu", "Zn", "Ga", "Ge", "As", "Se", "Br", "Kr", "Rb",       &
		"Sr", "Y",  "Zr", "Nb", "Mo", "Tc", "Ru", "Rh", "Pd",       &
		"Ag", "Cd", "In", "Sn", "Sb", "Te", "I",  "Xe", "Cs", "Ba", &
		"La", "Ce", "Pr", "Nd", "Pm", "Sm", "Eu", "Gd", "Tb", "Dy", &
		"Ho", "Er", "Tm", "Yb", "Lu", "Hf", "Ta", "W",  "Re", "Os", &
		"Ir", "Pt", "Au", "Hg", "Tl", "Pb", "Bi", "Po", "At", "Rn", &
		"Fr", "Ra", "Ac", "Th", "Pa", "U",  "Np", "Pu",             &
		"Am", "Cm", "Bk", "Cf", "Es", "Fm", "Md", "No"/

	CHARACTER(5), DIMENSION(0:1659) :: Nucleus_name
	DATA Nucleus_name / "n1", &
		"H1",    "H2",    "H3",    "He3",   "H4",    "He4",   "Li4",   &
		"He5",   "Li5",   "He6",   "Li6",   "Be6",   "He7",   "Li7",   &
		"Be7",   "B7",    "He8",   "Li8",   "Be8",   "B8",    "C8",    &
		"He9",   "Li9",   "Be9",   "B9",    "C9",    "Li10",  "Be10",  &
		"B10",   "C10",   "Li11",  "Be11",  "B11",   "C11",   "N11",   &
		"Be12",  "B12",   "C12",   "N12",   "O12",   "Be13",  "B13",   &
		"C13",   "N13",   "O13",   "Be14",  "B14",   "C14",   "N14",   &
		"O14",   "B15",   "C15",   "N15",   "O15",   "F15",   "C16",   &
		"N16",   "O16",   "F16",   "Ne16",  "C17",   "N17",   "O17",   &
		"F17",   "Ne17",  "C18",   "N18",   "O18",   "F18",   "Ne18",  &
		"N19",   "O19",   "F19",   "Ne19",  "Na19",  "O20",   "F20",   &
		"Ne20",  "Na20",  "Mg20",  "O21",   "F21",   "Ne21",  "Na21",  &
		"Mg21",  "O22",   "F22",   "Ne22",  "Na22",  "Mg22",  "Al22",  &
		"F23",   "Ne23",  "Na23",  "Mg23",  "Al23",  "Ne24",  "Na24",  &
		"Mg24",  "Al24",  "Si24",  "Ne25",  "Na25",  "Mg25",  "Al25",  &
		"Si25",  "Ne26",  "Na26",  "Mg26",  "Al26",  "Si26",  "Na27",  &
		"Mg27",  "Al27",  "Si27",  "P27",   "Na28",  "Mg28",  "Al28",  &
		"Si28",  "P28",   "S28",   "Na29",  "Mg29",  "Al29",  "Si29",  &
		"P29",   "S29",   "Na30",  "Mg30",  "Al30",  "Si30",  "P30",   &
		"S30",   "Na31",  "Al31",  "Si31",  "P31",   "S31",   "Cl31",  &
		"Na32",  "Mg32",  "Si32",  "P32",   "S32",   "Cl32",  "Ar32",  &
		"Na33",  "Si33",  "P33",   "S33",   "Cl33",  "Ar33",  "Na34",  &
		"Si34",  "P34",   "S34",   "Cl34",  "Ar34",  "Si35",  "P35",   &
		"S35",   "Cl35",  "Ar35",  "K35",   "Ca35",  "P36",   "S36",   &
		"Cl36",  "Ar36",  "K36",   "Ca36",  "S37",   "Cl37",  "Ar37",  &
		"K37",   "Ca37",  "S38",   "Cl38",  "Ar38",  "K38",   "Ca38",  &
		"Cl39",  "Ar39",  "K39",   "Ca39",  "Sc39",  "S40",   "Cl40",  &
		"Ar40",  "K40",   "Ca40",  "Sc40",  "Ti40",  "Cl41",  "Ar41",  &
		"K41",   "Ca41",  "Sc41",  "Ti41",  "Ar42",  "K42",   "Ca42",  &
		"Sc42",  "Ti42",  "Cl43",  "Ar43",  "K43",   "Ca43",  "Sc43",  &
		"Ti43",  "Ar44",  "K44",   "Ca44",  "Sc44",  "Ti44",  "Cr44",  &
		"Ar45",  "K45",   "Ca45",  "Sc45",  "Ti45",  "V45",   "Cr45",  &
		"Ar46",  "K46",   "Ca46",  "Sc46",  "Ti46",  "V46",   "Cr46",  &
		"Ar47",  "K47",   "Ca47",  "Sc47",  "Ti47",  "V47",   "Cr47",  &
		"K48",   "Ca48",  "Sc48",  "Ti48",  "V48",   "Cr48",  "Mn48",  &
		"Fe48",  "K49",   "Ca49",  "Sc49",  "Ti49",  "V49",   "Cr49",  &
		"Mn49",  "Fe49",  "Ca50",  "Sc50",  "Ti50",  "V50",   "Cr50",  &
		"Mn50",  "Fe50",  "Ca51",  "Sc51",  "Ti51",  "V51",   "Cr51",  &
		"Mn51",  "Fe51",  "Ti52",  "V52",   "Cr52",  "Mn52",  "Fe52",  &
		"Co52",  "Ni52",  "Ti53",  "V53",   "Cr53",  "Mn53",  "Fe53",  &
		"Co53",  "Ni53",  "V54",   "Cr54",  "Mn54",  "Fe54",  "Co54",  &
		"Ni54",  "V55",   "Cr55",  "Mn55",  "Fe55",  "Co55",  "Ni55",  &
		"Cr56",  "Mn56",  "Fe56",  "Co56",  "Ni56",  "Cu56",  "Zn56",  &
		"Mn57",  "Fe57",  "Co57",  "Ni57",  "Cu57",  "Zn57",  "Mn58",  &
		"Fe58",  "Co58",  "Ni58",  "Cu58",  "Zn58",  "Mn59",  "Fe59",  &
		"Co59",  "Ni59",  "Cu59",  "Zn59",  "Mn60",  "Fe60",  "Co60",  &
		"Ni60",  "Cu60",  "Zn60",  "Fe61",  "Co61",  "Ni61",  "Cu61",  &
		"Zn61",  "Fe62",  "Co62",  "Ni62",  "Cu62",  "Zn62",  "Ga62",  &
		"Fe63",  "Co63",  "Ni63",  "Cu63",  "Zn63",  "Ga63",  "Co64",  &
		"Ni64",  "Cu64",  "Zn64",  "Ga64",  "Ge64",  "Co65",  "Ni65",  &
		"Cu65",  "Zn65",  "Ga65",  "Ge65",  "Ni66",  "Cu66",  "Zn66",  &
		"Ga66",  "Ge66",  "As66",  "Ni67",  "Cu67",  "Zn67",  "Ga67",  &
		"Ge67",  "As67",  "Ni68",  "Cu68",  "Zn68",  "Ga68",  "Ge68",  &
		"As68",  "Ni69",  "Cu69",  "Zn69",  "Ga69",  "Ge69",  "As69",  &
		"Se69",  "Cu70",  "Zn70",  "Ga70",  "Ge70",  "As70",  "Zn71",  &
		"Ga71",  "Ge71",  "As71",  "Zn72",  "Ga72",  "Ge72",  "As72",  &
		"Se72",  "Zn73",  "Ga73",  "Ge73",  "As73",  "Se73",  "Br73",  &
		"Kr73",  "Zn74",  "Ga74",  "Ge74",  "As74",  "Se74",  "Br74",  &
		"Kr74",  "Rb74",  "Zn75",  "Ga75",  "Ge75",  "As75",  "Se75",  &
		"Br75",  "Kr75",  "Rb75",  "Zn76",  "Ga76",  "Ge76",  "As76",  &
		"Se76",  "Br76",  "Kr76",  "Rb76",  "Ge77",  "As77",  "Se77",  &
		"Br77",  "Kr77",  "Rb77",  "Sr77",  "Ge78",  "As78",  "Se78",  &
		"Br78",  "Kr78",  "Rb78",  "Ga79",  "Ge79",  "As79",  "Se79",  &
		"Br79",  "Kr79",  "Rb79",  "Zn80",  "Ga80",  "Ge80",  "As80",  &
		"Se80",  "Br80",  "Kr80",  "Rb80",  "Sr80",  "Ga81",  "Ge81",  &
		"As81",  "Se81",  "Br81",  "Kr81",  "Rb81",  "Sr81",  "Y81",   &
		"Zr81",  "Ge82",  "As82",  "Se82",  "Br82",  "Kr82",  "Rb82",  &
		"Sr82",  "Y82",   "Zr82",  "As83",  "Se83",  "Br83",  "Kr83",  &
		"Rb83",  "Sr83",  "Y83",   "Zr83",  "Se84",  "Br84",  "Kr84",  &
		"Rb84",  "Sr84",  "Y84",   "Se85",  "Br85",  "Kr85",  "Rb85",  &
		"Sr85",  "Y85",   "Zr85",  "Se86",  "Br86",  "Kr86",  "Rb86",  &
		"Sr86",  "Y86",   "Br87",  "Kr87",  "Rb87",  "Sr87",  "Y87",   &
		"Zr87",  "Nb87",  "Mo87",  "Br88",  "Kr88",  "Rb88",  "Sr88",  &
		"Y88",   "Zr88",  "Kr89",  "Rb89",  "Sr89",  "Y89",   "Zr89",  &
		"Nb89",  "Mo89",  "Br90",  "Kr90",  "Rb90",  "Sr90",  "Y90",   &
		"Zr90",  "Nb90",  "Mo90",  "Kr91",  "Rb91",  "Sr91",  "Y91",   &
		"Zr91",  "Nb91",  "Mo91",  "Tc91",  "Kr92",  "Rb92",  "Sr92",  &
		"Y92",   "Zr92",  "Nb92",  "Mo92",  "Tc92",  "Kr93",  "Rb93",  &
		"Sr93",  "Y93",   "Zr93",  "Nb93",  "Mo93",  "Tc93",  "Ru93",  &
		"Rb94",  "Sr94",  "Y94",   "Zr94",  "Nb94",  "Mo94",  "Tc94",  &
		"Ru94",  "Rh94",  "Rb95",  "Sr95",  "Y95",   "Zr95",  "Nb95",  &
		"Mo95",  "Tc95",  "Ru95",  "Rh95",  "Rb96",  "Sr96",  "Y96",   &
		"Zr96",  "Nb96",  "Mo96",  "Tc96",  "Ru96",  "Rh96",  "Pd96",  &
		"Rb97",  "Sr97",  "Y97",   "Zr97",  "Nb97",  "Mo97",  "Tc97",  &
		"Ru97",  "Rh97",  "Pd97",  "Rb98",  "Sr98",  "Y98",   "Zr98",  &
		"Nb98",  "Mo98",  "Tc98",  "Ru98",  "Rh98",  "Pd98",  "Rb99",  &
		"Sr99",  "Y99",   "Zr99",  "Nb99",  "Mo99",  "Tc99",  "Ru99",  &
		"Rh99",  "Pd99",  "Ag99",  "Sr100", "Y100",  "Zr100", "Nb100", &
		"Mo100", "Tc100", "Ru100", "Rh100", "Pd100", "Ag100", "Zr101", &
		"Nb101", "Mo101", "Tc101", "Ru101", "Rh101", "Pd101", "Ag101", &
		"Cd101", "Zr102", "Nb102", "Mo102", "Tc102", "Ru102", "Rh102", &
		"Pd102", "Ag102", "Zr103", "Nb103", "Mo103", "Tc103", "Ru103", &
		"Rh103", "Pd103", "Ag103", "Cd103", "In103", "Nb104", "Mo104", &
		"Tc104", "Ru104", "Rh104", "Pd104", "Ag104", "Cd104", "Nb105", &
		"Mo105", "Tc105", "Ru105", "Rh105", "Pd105", "Ag105", "Cd105", &
		"In105", "Sn105", "Mo106", "Tc106", "Ru106", "Rh106", "Pd106", &
		"Ag106", "Cd106", "In106", "Sn106", "Ru107", "Rh107", "Pd107", &
		"Ag107", "Cd107", "In107", "Ru108", "Rh108", "Pd108", "Ag108", &
		"Cd108", "In108", "Sn108", "Rh109", "Pd109", "Ag109", "Cd109", &
		"In109", "Sn109", "Sb109", "Te109", "Rh110", "Pd110", "Ag110", &
		"Cd110", "In110", "Sn110", "Te110", "Pd111", "Ag111", "Cd111", &
		"In111", "Sn111", "Te111", "Pd112", "Ag112", "Cd112", "In112", &
		"Sn112", "Sb112", "Te112", "Pd113", "Ag113", "Cd113", "In113", &
		"Sn113", "Sb113", "I113",  "Xe113", "Pd114", "Ag114", "Cd114", &
		"In114", "Sn114", "Sb114", "Ag115", "Cd115", "In115", "Sn115", &
		"Sb115", "Te115", "Pd116", "Ag116", "Cd116", "In116", "Sn116", &
		"Sb116", "Te116", "I116",  "Cs116", "Ag117", "Cd117", "In117", &
		"Sn117", "Sb117", "Te117", "Cs117", "Ag118", "Cd118", "In118", &
		"Sn118", "Sb118", "Te118", "Cs118", "Ag119", "Cd119", "In119", &
		"Sn119", "Sb119", "Te119", "I119",  "Xe119", "Cs119", "Ag120", &
		"Cd120", "In120", "Sn120", "Sb120", "Te120", "I120",  "Xe120", &
		"Cs120", "Ag121", "Cd121", "In121", "Sn121", "Sb121", "Te121", &
		"I121",  "Xe121", "Cs121", "In122", "Sn122", "Sb122", "Te122", &
		"I122",  "Xe122", "Cs122", "In123", "Sn123", "Sb123", "Te123", &
		"I123",  "Xe123", "Cs123", "In124", "Sn124", "Sb124", "Te124", &
		"I124",  "Xe124", "Cs124", "In125", "Sn125", "Sb125", "Te125", &
		"I125",  "Xe125", "Cs125", "Ba125", "In126", "Sn126", "Sb126", &
		"Te126", "I126",  "Xe126", "Cs126", "In127", "Sn127", "Sb127", &
		"Te127", "I127",  "Xe127", "Cs127", "Ba127", "In128", "Sn128", &
		"Sb128", "Te128", "I128",  "Xe128", "Cs128", "Ba128", "La128", &
		"In129", "Sn129", "Sb129", "Te129", "I129",  "Xe129", "Cs129", &
		"Ba129", "La129", "In130", "Sn130", "Sb130", "Te130", "I130",  &
		"Xe130", "Cs130", "Ba130", "In131", "Sn131", "Sb131", "Te131", &
		"I131",  "Xe131", "Cs131", "Ba131", "La131", "Ce131", "Sn132", &
		"Sb132", "Te132", "I132",  "Xe132", "Cs132", "Ba132", "La132", &
		"Sn133", "Sb133", "Te133", "I133",  "Xe133", "Cs133", "Ba133", &
		"Sb134", "Te134", "I134",  "Xe134", "Cs134", "Ba134", "La134", &
		"Ce134", "Te135", "I135",  "Xe135", "Cs135", "Ba135", "La135", &
		"Ce135", "Pr135", "Te136", "I136",  "Xe136", "Cs136", "Ba136", &
		"La136", "Ce136", "Pr136", "Nd136", "Te137", "I137",  "Xe137", &
		"Cs137", "Ba137", "La137", "Ce137", "Pr137", "Nd137", "Pm137", &
		"I138",  "Xe138", "Cs138", "Ba138", "La138", "Ce138", "Pr138", &
		"I139",  "Xe139", "Cs139", "Ba139", "La139", "Ce139", "Pr139", &
		"Nd139", "Pm139", "Sm139", "Xe140", "Cs140", "Ba140", "La140", &
		"Ce140", "Pr140", "Nd140", "Pm140", "Xe141", "Cs141", "Ba141", &
		"La141", "Ce141", "Pr141", "Nd141", "Pm141", "Sm141", "Eu141", &
		"Xe142", "Cs142", "Ba142", "La142", "Ce142", "Pr142", "Nd142", &
		"Pm142", "Sm142", "Eu142", "Cs143", "Ba143", "La143", "Ce143", &
		"Pr143", "Nd143", "Pm143", "Sm143", "Eu143", "Cs144", "Ba144", &
		"La144", "Ce144", "Pr144", "Nd144", "Pm144", "Sm144", "Eu144", &
		"Cs145", "Ba145", "La145", "Ce145", "Pr145", "Nd145", "Pm145", &
		"Sm145", "Eu145", "Gd145", "Cs146", "Ba146", "La146", "Ce146", &
		"Pr146", "Nd146", "Pm146", "Sm146", "Eu146", "Gd146", "Tb146", &
		"Cs147", "Ba147", "La147", "Ce147", "Pr147", "Nd147", "Pm147", &
		"Sm147", "Eu147", "Gd147", "Tb147", "Dy147", "Cs148", "La148", &
		"Ce148", "Pr148", "Nd148", "Pm148", "Sm148", "Eu148", "Gd148", &
		"Tb148", "Dy148", "Ce149", "Pr149", "Nd149", "Pm149", "Sm149", &
		"Eu149", "Gd149", "Tb149", "Er149", "Ce150", "Pr150", "Nd150", &
		"Pm150", "Sm150", "Eu150", "Gd150", "Tb150", "Dy150", "Ho150", &
		"Nd151", "Pm151", "Sm151", "Eu151", "Gd151", "Tb151", "Dy151", &
		"Ho151", "Nd152", "Pm152", "Sm152", "Eu152", "Gd152", "Tb152", &
		"Dy152", "Ho152", "Er152", "Pm153", "Sm153", "Eu153", "Gd153", &
		"Tb153", "Dy153", "Ho153", "Pm154", "Sm154", "Eu154", "Gd154", &
		"Tb154", "Dy154", "Ho154", "Er154", "Tm154", "Sm155", "Eu155", &
		"Gd155", "Tb155", "Dy155", "Ho155", "Er155", "Tm155", "Sm156", &
		"Eu156", "Gd156", "Tb156", "Dy156", "Tm156", "Yb156", "Sm157", &
		"Eu157", "Gd157", "Tb157", "Dy157", "Ho157", "Er157", "Eu158", &
		"Gd158", "Tb158", "Dy158", "Ho158", "Yb158", "Lu158", "Eu159", &
		"Gd159", "Tb159", "Dy159", "Ho159", "Er159", "Lu159", "Gd160", &
		"Tb160", "Dy160", "Ho160", "Er160", "Tm160", "Hf160", "Gd161", &
		"Tb161", "Dy161", "Ho161", "Er161", "Tm161", "Gd162", "Tb162", &
		"Dy162", "Ho162", "Er162", "Tm162", "Hf162", "Ta162", "Tb163", &
		"Dy163", "Ho163", "Er163", "Tm163", "Yb163", "Lu163", "Ta163", &
		"Tb164", "Dy164", "Ho164", "Er164", "Tm164", "W164",  "Dy165", &
		"Ho165", "Er165", "Tm165", "Yb165", "Lu165", "Dy166", "Ho166", &
		"Er166", "Tm166", "Yb166", "Lu166", "W166",  "Re166", "Dy167", &
		"Ho167", "Er167", "Tm167", "Yb167", "Lu167", "Re167", "Ho168", &
		"Er168", "Tm168", "Yb168", "Lu168", "Os168", "Ho169", "Er169", &
		"Tm169", "Yb169", "Lu169", "Hf169", "Ho170", "Er170", "Tm170", &
		"Yb170", "Lu170", "Os170", "Ir170", "Er171", "Tm171", "Yb171", &
		"Lu171", "Ir171", "Er172", "Tm172", "Yb172", "Lu172", "Hf172", &
		"Ta172", "Pt172", "Tm173", "Yb173", "Lu173", "Tm174", "Yb174", &
		"Lu174", "Hf174", "Pt174", "Au174", "Tm175", "Yb175", "Lu175", &
		"Hf175", "Au175", "Yb176", "Lu176", "Hf176", "Ta176", "Hg176", &
		"Yb177", "Lu177", "Hf177", "Ta177", "Yb178", "Lu178", "Hf178", &
		"Ta178", "W178",  "Re178", "Hg178", "Lu179", "Hf179", "Ta179", &
		"W179",  "Re179", "Lu180", "Hf180", "Ta180", "W180",  "Re180", &
		"Hf181", "Ta181", "W181",  "Hf182", "Ta182", "W182",  "Re182", &
		"Os182", "Pb182", "Hf183", "Ta183", "W183",  "Re183", "Hf184", &
		"Ta184", "W184",  "Re184", "Os184", "Ir184", "Ta185", "W185",  &
		"Re185", "Os185", "Ta186", "W186",  "Re186", "Os186", "Ir186", &
		"Pt186", "W187",  "Re187", "Os187", "W188",  "Re188", "Os188", &
		"Ir188", "Pt188", "W189",  "Re189", "Os189", "Ir189", "Pt189", &
		"W190",  "Re190", "Os190", "Ir190", "Pt190", "Au190", "Re191", &
		"Os191", "Ir191", "Pt191", "Au191", "Hg191", "Os192", "Ir192", &
		"Pt192", "Au192", "Os193", "Ir193", "Pt193", "Tl193", "Os194", &
		"Ir194", "Pt194", "Au194", "Hg194", "Os195", "Ir195", "Pt195", &
		"Au195", "Hg195", "Tl195", "Os196", "Ir196", "Pt196", "Au196", &
		"Hg196", "Bi196", "Ir197", "Pt197", "Au197", "Hg197", "Tl197", &
		"Bi197", "Pt198", "Au198", "Hg198", "Tl198", "Bi198", "Pt199", &
		"Au199", "Hg199", "Tl199", "Pb199", "Bi199", "Pt200", "Au200", &
		"Hg200", "Tl200", "Bi200", "At200", "Pt201", "Au201", "Hg201", &
		"Tl201", "Pb201", "Bi201", "At201", "Au202", "Hg202", "Tl202", &
		"Pb202", "Bi202", "At202", "Au203", "Hg203", "Tl203", "Pb203", &
		"Bi203", "Po203", "At203", "Hg204", "Tl204", "Pb204", "Bi204", &
		"At204", "Fr204", "Hg205", "Tl205", "Pb205", "Bi205", "Po205", &
		"At205", "Fr205", "Hg206", "Tl206", "Pb206", "Bi206", "Po206", &
		"At206", "Fr206", "Hg207", "Tl207", "Pb207", "Bi207", "Po207", &
		"At207", "Rn207", "Fr207", "Tl208", "Pb208", "Bi208", "Po208", &
		"At208", "Fr208", "Tl209", "Pb209", "Bi209", "Po209", "At209", &
		"Rn209", "Fr209", "Ac209", "Tl210", "Pb210", "Bi210", "Po210", &
		"At210", "Rn210", "Fr210", "Ac210", "Pb211", "Bi211", "Po211", &
		"At211", "Rn211", "Fr211", "Ra211", "Ac211", "Pb212", "Bi212", &
		"Po212", "At212", "Rn212", "Fr212", "Ac212", "Bi213", "Po213", &
		"At213", "Rn213", "Fr213", "Ra213", "Ac213", "Pb214", "Bi214", &
		"Po214", "At214", "Rn214", "Fr214", "Ra214", "Ac214", "Bi215", &
		"Po215", "At215", "Rn215", "Fr215", "Ra215", "Ac215", "Th215", &
		"Pa215", "Po216", "At216", "Rn216", "Fr216", "Ra216", "Ac216", &
		"Pa216", "At217", "Rn217", "Fr217", "Ra217", "Ac217", "Th217", &
		"Pa217", "Po218", "At218", "Rn218", "Fr218", "Ra218", "Ac218", &
		"Th218", "Pa218", "At219", "Rn219", "Fr219", "Ra219", "Ac219", &
		"Th219", "Rn220", "Fr220", "Ra220", "Ac220", "Th220", "Fr221", &
		"Ra221", "Ac221", "Th221", "Rn222", "Fr222", "Ra222", "Ac222", &
		"Th222", "Pa222", "Fr223", "Ra223", "Ac223", "Th223", "Pa223", &
		"Fr224", "Ra224", "Ac224", "Th224", "Pa224", "Fr225", "Ra225", &
		"Ac225", "Th225", "Pa225", "Fr226", "Ra226", "Ac226", "Th226", &
		"Pa226", "U226",  "Fr227", "Ra227", "Ac227", "Th227", "Pa227", &
		"Ra228", "Ac228", "Th228", "Pa228", "U228",  "Ra229", "Ac229", &
		"Th229", "Pa229", "U229",  "Np229", "Th230", "Pa230", "U230",  &
		"Np230", "Ac231", "Th231", "Pa231", "U231",  "Np231", "Th232", &
		"Pa232", "U232",  "Pu232", "Th233", "Pa233", "U233",  "Pu233", &
		"Th234", "Pa234", "U234",  "Np234", "Pu234", "Th235", "Pa235", &
		"U235",  "Np235", "Pu235", "Pa236", "U236",  "Np236", "Pu236", &
		"Pa237", "U237",  "Np237", "Pu237", "Pa238", "U238",  "Np238", &
		"Pu238", "Am238", "Cm238", "U239",  "Np239", "Pu239", "Am239", &
		"U240",  "Np240", "Pu240", "Am240", "Cm240", "Np241", "Pu241", &
		"Am241", "Cm241", "Np242", "Pu242", "Am242", "Cm242", "Cf242", &
		"Np243", "Pu243", "Am243", "Cm243", "Bk243", "Pu244", "Am244", &
		"Cm244", "Bk244", "Cf244", "Pu245", "Am245", "Cm245", "Bk245", &
		"Cf245", "Pu246", "Am246", "Cm246", "Cf246", "Fm246", "Cm247", &
		"Bk247", "Cf247", "Es247", "Cm248", "Bk248", "Cf248", "Es248", &
		"Fm248", "Cm249", "Bk249", "Cf249", "Es249", "Cm250", "Bk250", &
		"Cf250", "Fm250", "Cm251", "Bk251", "Cf251", "Es251", "Fm251", &
		"Cf252", "Es252", "Fm252", "No252", "Cf253", "Es253", "Fm253", &
		"Cf254", "Es254", "Fm254", "No254", "Es255", "Fm255", "Md255", &
		"No255", "Fm256", "Md256", "No256", "Rf256", "Fm257", "No257", &
		"No259", "Lr259", "Rf259", "Lr260", "Nh260", "Nh263", "Nh263" /
MODULE nucleus

	USE math
	USE r1r1

	IMPLICIT NONE

	CHARACTER(LEN = 10), DIMENSION(0:1) :: Nucleus_type
	DATA Nucleus_type / "protones", "neutrones" /

	TYPE NucleusType
		TYPE (R1R1Function) func
		INTEGER, DIMENSION(0:2) :: np
		DOUBLE PRECISION, DIMENSION(0:1) :: actual_np, lambda_np, lambda_R2
		DOUBLE PRECISION, DIMENSION(0:2) :: actual_R2
		DOUBLE PRECISION eHFB, R2, norma
		DOUBLE PRECISION pairing ! Apareamiento
		LOGICAL is_blocking(0:1)
		INTEGER num
		INTEGER, DIMENSION(0:1) :: ia, la, ja, mu0
		CHARACTER(LEN = 64) :: filename
	END TYPE

	INTERFACE ASSIGNMENT(=)
		MODULE PROCEDURE Nucleus_copy
	END INTERFACE

	INCLUDE "name.f90"
	INCLUDE "binding.f90"
	INCLUDE "atomic.f90"
	INCLUDE "mass.f90"

CONTAINS

	SUBROUTINE Nucleus_new(nuc, N, Z, b)
		! Recibe como parmetros de entrada
		! el registro de densidad y el nmero de protones y electrones
		TYPE (NucleusType), INTENT(INOUT) :: nuc
		INTEGER, INTENT(IN) :: N, Z
		DOUBLE PRECISION, INTENT(IN), OPTIONAL:: b

		CHARACTER(LEN = 32) :: specie, N_0_str, A_str

		CALL R1R1Function_new(nuc%func)

		nuc%eHFB    = 0.0
		nuc%pairing = 0.0
		nuc%R2      = 0.0
		nuc%norma   = 1.0
		nuc%num     = 0
		nuc%np(0)   = Z
		nuc%np(1)   = N
		nuc%np(2)   = N + Z
		nuc%actual_np = (/ 0.0,  0.0     /)
		nuc%lambda_np = (/-8.0, -8.0     /)
		nuc%actual_R2 = (/ 0.0,  0.0, 0.0/)
		nuc%lambda_R2 = (/ 0.0,  0.0     /)

		IF (PRESENT(b)) THEN
			nuc%func%x = b
		ELSE
			nuc%func%x = Nucleus_get_InitialOscillatorLength(nuc)
		END IF

		CALL Nucleus_set_NeutronBlocking(nuc)
		CALL Nucleus_set_ProtonBlocking(nuc)

		! Nombre de fichero
		IF (nuc%np(0) .LE. 102) THEN
			specie = Nucleus_specie(nuc%np(0))
		ELSE
			CALL Int2Char(specie, nuc%np(0))
		END IF
		CALL Int2Char(A_str, nuc%np(2))
		CALL Int2Char(N_0_str, N_0)
		nuc%filename = "data/" // TRIM(specie) // TRIM(A_str) // "_" // TRIM(N_0_str)
		RETURN
	END SUBROUTINE Nucleus_new

	SUBROUTINE Nucleus_new_Isotope(nuc, isotope)
		TYPE (NucleusType), INTENT(INOUT) :: nuc
		INTEGER, INTENT(IN) :: isotope

		INTEGER idx, lenght, Z
		CHARACTER(LEN = 32) :: N_0_str
		CHARACTER(LEN = 50) :: Z_str, A_str

		CALL R1R1Function_new(nuc%func)

		nuc%eHFB    = 0.0
		nuc%pairing = 0.0
		nuc%R2      = 0.0
		nuc%norma   = 1.0
		nuc%num     = isotope

		idx = 1
		lenght = LEN(Nucleus_name(isotope))
iso:		DO
			IF (idx .GT. lenght) THEN
				PRINT *, "Isotopo: ", Nucleus_name(isotope)
				STOP "ERROR! Imposible procesar isotopo"
			END IF
			SELECT CASE (Nucleus_name(isotope)(idx:idx))
			CASE ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9')
				Z_str = Nucleus_name(isotope)(1:idx - 1)
				A_str = Nucleus_name(isotope)(idx:lenght)
				EXIT iso
			END SELECT
			idx = idx + 1
		END DO iso

		Z = 1
		DO WHILE (Z_str .NE. Nucleus_specie(Z))
			Z = Z + 1
			IF (Z .GT. SIZE(Nucleus_specie)) THEN
				PRINT *, "Isotopo: ", Nucleus_name(isotope), isotope
				PRINT *, "Nombre del nucleo: ", Z_str
				STOP "ERROR! Imposible encontrar especie"
			END IF
		END DO
		nuc%np(0) = Z
		nuc%np(1) = Char2Int(A_str) - Z
		nuc%np(2) = Char2Int(A_str)
		nuc%actual_np = (/ 0.0,  0.0     /)
		nuc%lambda_np = (/-8.0, -8.0     /)
		nuc%actual_R2 = (/ 0.0,  0.0, 0.0/)
		nuc%lambda_R2 = (/ 0.0,  0.0     /)

		nuc%func%x = Nucleus_get_InitialOscillatorLength(nuc)

		CALL Nucleus_set_NeutronBlocking(nuc)
		CALL Nucleus_set_ProtonBlocking(nuc)

		CALL Int2Char(N_0_str, N_0)
		nuc%filename = "data/" // TRIM(Nucleus_name(isotope)) // "_" // TRIM(N_0_str)
		PRINT "(A,I3,A,I3,A,I4,A,A)", &
			"Nucleo: Z=", nuc%np(0), &
			" N=", nuc%np(1), &
			" Isotopo=", isotope , &
			" Archivo=", nuc%filename
		RETURN
	END SUBROUTINE Nucleus_new_Isotope

	SUBROUTINE Nucleus_new_Name(nuc, name_in)
		TYPE (NucleusType), INTENT(INOUT) :: nuc
		CHARACTER(*), INTENT(IN) :: name_in

		INTEGER idx, lenght, Z
		CHARACTER(LEN = 50) :: Z_str, A_str
		CHARACTER(LEN = 32) :: N_0_str

		CALL R1R1Function_new(nuc%func)

		nuc%eHFB    = 0.0
		nuc%pairing = 0.0
		nuc%R2      = 0.0
		nuc%norma   = 1.0
		nuc%num     = 0

		idx = 1
		lenght = LEN(name_in)
lname:	DO
			IF (idx .GT. lenght) STOP "Unparseable name"
			SELECT CASE (name_in(idx:idx))
			CASE ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9')
				Z_str = name_in(1:idx - 1)
				A_str = name_in(idx:lenght)
				EXIT lname
			END SELECT
			idx = idx + 1
		END DO lname

		Z = 1
		DO WHILE (Z_str .NE. Nucleus_specie(Z))
			Z = Z + 1
			IF (Z .GT. SIZE(Nucleus_specie)) STOP "Unable to find specie"
		END DO
		nuc%np(0) = Z
		nuc%np(1) = Char2Int(A_str) - Z
		nuc%np(2) = Char2Int(A_str)
		nuc%actual_np = (/ 0.0,  0.0     /)
		nuc%lambda_np = (/-8.0, -8.0     /)
		nuc%actual_R2 = (/ 0.0,  0.0, 0.0/)
		nuc%lambda_R2 = (/ 0.0,  0.0     /)

		nuc%func%x = Nucleus_get_InitialOscillatorLength(nuc)

		CALL Nucleus_set_NeutronBlocking(nuc)
		CALL Nucleus_set_ProtonBlocking(nuc)

		CALL Int2Char(N_0_str, N_0)
		nuc%filename = "data/" // TRIM(name_in) // "_" // TRIM(N_0_str)
		PRINT "(A,I3,A,I3,A,A,A,A)", &
			"Nucleo: Z=", nuc%np(0), &
			" N=", nuc%np(1), &
			" Name=", name_in, &
			" Archivo=", nuc%filename
		RETURN
	END SUBROUTINE Nucleus_new_Name

	SUBROUTINE Nucleus_new_Nucleus(n1, n2)
		TYPE (NucleusType), INTENT(INOUT) :: n1
		TYPE (NucleusType), INTENT(IN) :: n2

		CALL R1R1Function_new(n1%func)
		CALL Nucleus_copy(n1, n2)
		RETURN
	END SUBROUTINE Nucleus_new_Nucleus

	FUNCTION Nucleus_read(nucleus_out, file_desc, file_error)
		LOGICAL Nucleus_read
		TYPE (NucleusType), INTENT(INOUT) :: nucleus_out
		INTEGER, INTENT(IN) :: file_desc
		INTEGER, INTENT(INOUT) :: file_error

		DOUBLE PRECISION x

		Nucleus_read = .FALSE.
		READ (file_desc, FMT="(E)", IOSTAT=file_error) x
		IF (file_error .NE. 0) RETURN
		CALL R1R1Function_set(nucleus_out%func, x)

		READ (file_desc, FMT="(E)", IOSTAT=file_error) nucleus_out%eHFB
		IF (file_error .NE. 0) RETURN

		READ (file_desc, FMT="(E)", IOSTAT=file_error) nucleus_out%R2
		IF (file_error .NE. 0) RETURN

		READ (file_desc, FMT="(E)", IOSTAT=file_error) nucleus_out%pairing
		IF (file_error .NE. 0) RETURN

		READ (file_desc, FMT="(E,E)", IOSTAT=file_error) nucleus_out%actual_R2(1), nucleus_out%actual_R2(0)
		IF (file_error .NE. 0) RETURN

		READ (file_desc, FMT="(E,E)", IOSTAT=file_error) nucleus_out%lambda_R2(1), nucleus_out%lambda_R2(0)
		IF (file_error .NE. 0) RETURN

		READ (file_desc, FMT="(E,E)", IOSTAT=file_error) nucleus_out%actual_np(1), nucleus_out%actual_np(0)
		IF (file_error .NE. 0) RETURN

		READ (file_desc, FMT="(E,E)", IOSTAT=file_error) nucleus_out%lambda_np(1), nucleus_out%lambda_np(0)
		IF (file_error .NE. 0) RETURN

		READ (file_desc, FMT="(E)", IOSTAT=file_error) nucleus_out%norma
		IF (file_error .NE. 0) RETURN

		Nucleus_read = .TRUE.
		RETURN
	END FUNCTION Nucleus_read

	SUBROUTINE Nucleus_write(nucleus_in, file_desc, file_error)
		TYPE (NucleusType), INTENT(IN) :: nucleus_in
		INTEGER, INTENT(IN) :: file_desc
		INTEGER, INTENT(INOUT) :: file_error

		WRITE (file_desc, FMT="(E)", IOSTAT=file_error) nucleus_in%func%x
		WRITE (file_desc, FMT="(E)", IOSTAT=file_error) nucleus_in%eHFB
		WRITE (file_desc, FMT="(E)", IOSTAT=file_error) nucleus_in%R2
		WRITE (file_desc, FMT="(E)", IOSTAT=file_error) nucleus_in%pairing
		WRITE (file_desc, FMT="(E,E)", IOSTAT=file_error) nucleus_in%actual_R2(1), nucleus_in%actual_R2(0)
		WRITE (file_desc, FMT="(E,E)", IOSTAT=file_error) nucleus_in%lambda_R2(1), nucleus_in%lambda_R2(0)
		WRITE (file_desc, FMT="(E,E)", IOSTAT=file_error) nucleus_in%actual_np(1), nucleus_in%actual_np(0)
		WRITE (file_desc, FMT="(E,E)", IOSTAT=file_error) nucleus_in%lambda_np(1), nucleus_in%lambda_np(0)
		WRITE (file_desc, FMT="(E)", IOSTAT=file_error) nucleus_in%norma
		RETURN
	END SUBROUTINE Nucleus_write

	SUBROUTINE Nucleus_copy(n1, n2)
		TYPE (NucleusType), INTENT(INOUT) :: n1
		TYPE (NucleusType), INTENT(IN) :: n2

		INTEGER ta

		n1%eHFB = n2%eHFB
		n1%pairing = n2%pairing
		n1%R2 = n2%R2
		n1%num = n2%num
		DO ta = 0, 1
			n1%np(ta) = n2%np(ta)
			n1%actual_np(ta) = n2%actual_np(ta)
			n1%lambda_np(ta) = n2%lambda_np(ta)
			n1%actual_R2(ta) = n2%actual_R2(ta)
			n1%lambda_R2(ta) = n2%lambda_R2(ta)
			n1%is_blocking(ta) = n2%is_blocking(ta)
			IF (n1%is_blocking(ta) .EQV. .TRUE.) THEN
				n1%ia(ta) = n2%ia(ta)
				n1%la(ta) = n2%la(ta)
				n1%ja(ta) = n2%ja(ta)
				n1%mu0(ta) = n2%mu0(ta)      
			END IF
		END DO
		n1%np(2) = n1%np(0) + n1%np(1)
		n1%actual_R2(2) = ((n1%np(0) * n1%actual_R2(0)) + (n1%np(1) * n1%actual_R2(1))) / (n1%np(0) + n1%np(1))
  
		CALL Nucleus_set_b(n1, Nucleus_get_b(n2))
		n1%norma = n2%norma
		n1%filename = n2%filename
		RETURN
	END SUBROUTINE Nucleus_copy

	FUNCTION Nucleus_get_InitialOscillatorLength(nuc)
		DOUBLE PRECISION Nucleus_get_InitialOscillatorLength
		TYPE (NucleusType), INTENT(IN) :: nuc

		Nucleus_get_InitialOscillatorLength = 1.01 * (DBLE(nuc%np(0) + nuc%np(1)) ** (1.0 / 6.0))
		RETURN
	END FUNCTION Nucleus_get_InitialOscillatorLength

	SUBROUTINE Nucleus_set_ProtonBlocking(nuc)
		TYPE (NucleusType), INTENT(INOUT) :: nuc

		INTEGER Z, N, A
		INTEGER lp, jp, ip, mu0p

		IF (nuc%num .EQ. 0) THEN
			nuc%is_blocking(0) = .FALSE.
			RETURN
		END IF

		Z = nuc%np(0)
		N = nuc%np(1)
		A = nuc%np(0) + nuc%np(1)

		nuc%is_blocking(0) = IS_ODD(Z)
		IF (nuc%is_blocking(0)) THEN
			IF (Z .EQ. 3) THEN
				lp = 1
				jp = 3 ! Li
			ELSE IF ((Z .GT. 8) .AND. (Z .LT. 14)) THEN
				lp = 2
				jp = 5
			ELSE IF ((Z .GT. 14) .AND. (Z .LT. 16)) THEN
				lp = 0
				jp = 1 ! Capa sd
			ELSE IF ((Z .GT. 16) .AND. (Z .LT. 20)) THEN
				lp = 2
				jp = 3
			ELSE IF (Z .EQ. 41) THEN
				lp = 4
				jp = 9 ! Nb
			ELSE IF ((Z .EQ. 23) .OR. (Z .EQ. 27)) THEN
				lp = 3
				jp = 7 ! V y Co
			ELSE
				PRINT *, "Definir el bloqueo de protones"
				RETURN
			END IF

			ip = lp * 2
			IF (jp .EQ. ((2 * lp) - 1)) THEN
				ip = ip - 1
			END IF
			mu0p = 1

			! Se bloquea el estado mas proximo al nivel de Fermi
			PRINT *, "Hay bloqueo de protones en l =", lp, ", j =", jp, ", mu0p =", mu0p

			nuc%la(0) = lp
			nuc%ja(0) = jp
			nuc%ia(0) = ip
			nuc%mu0(0) = mu0p
		END IF
		RETURN
	END SUBROUTINE Nucleus_set_ProtonBlocking

	SUBROUTINE Nucleus_set_NeutronBlocking(nuc)
		TYPE (NucleusType), INTENT(INOUT) :: nuc

		INTEGER Z, N, A
		INTEGER ln, jn, in, mu0n

		IF (nuc%num .EQ. 0) THEN
			nuc%is_blocking(1) = .FALSE.
			RETURN
		END IF

		Z = nuc%np(0)
		N = nuc%np(1)
		A = nuc%np(0) + nuc%np(1)

		nuc%is_blocking(1) = IS_ODD(N)

		IF (nuc%is_blocking(1)) THEN
			IF ((Z .EQ. 3) .AND. (A .EQ. 6)) THEN
				ln = 1
				jn = 3 ! Li
			ELSE IF ((Z .EQ. 8) .AND. (A .EQ. 17)) THEN
				ln = 2
				jn = 5 ! O
			ELSE IF ((N .GT. 8) .AND. (N .LT. 14)) THEN
				ln = 2
				jn = 5
			ELSE IF ((N .GT. 14) .AND. (N .LT. 16)) THEN
				ln = 0
				jn = 1 ! Capa sd
			ELSE IF ((N .GT. 16) .AND. (N .LT. 20)) THEN
				ln = 2
				jn = 3
			ELSE IF (Z .EQ. 18) THEN
				! Isotopos del Argon
				IF (A .EQ. 51) THEN
					ln = 0
					jn = 1
				ELSE IF ((A .EQ. 53) .OR. (A .EQ. 55)) THEN
					ln = 2
					jn = 3
				ELSE IF ((A .EQ. 57) .OR. (A .EQ. 59)) THEN
					ln = 3
					jn = 7
				ELSE
					PRINT *, "Definir el bloqueo de neutrones"
					RETURN
				END IF
			ELSE IF (Z .EQ. 20) THEN
				! Isotopos del Calcio
				IF ((A .EQ. 57) .OR. (A .EQ. 59)) THEN
					ln = 2
					jn = 3
				ELSE IF ((A .GE. 61) .AND. (A .LE. 67)) THEN
					ln = 3
					jn = 7
				ELSE IF ((A .GE. 69) .AND. (A .LE. 73)) THEN
					ln = 1
					jn = 3
				ELSE
					PRINT *, "Definir el bloqueo de neutrones"
					RETURN
				END IF
			ELSE IF ((Z .EQ. 38) .AND. (A .EQ. 87)) THEN
				ln = 4
				jn = 9 ! Sr
			ELSE IF ((Z .EQ. 22) .AND. (A .EQ. 49)) THEN
				ln = 3
				jn = 7 ! Ti
			ELSE IF (Z .EQ. 50) THEN ! Sn
				IF ((A .GE. 113) .AND. (A .LE. 119)) THEN
					ln = 0
					jn = 1
				ELSE IF ((A .GE. 121) .AND. (A .LE. 125)) THEN
					ln = 5
					jn = 11
				ELSE
					PRINT *, "Definir el bloqueo de neutrones"
					RETURN
				END IF
			ELSE
				PRINT *, "Definir el bloqueo de neutrones"
				RETURN
			END IF

			in = ln * 2
			IF (jn .EQ. ((2 * ln) - 1)) THEN
				in = in - 1
			END IF
			mu0n = 1

			! Se bloquea el estado mas proximo al nivel de Fermi
			PRINT *, "Hay bloqueo de neutrones en l =", ln, ", j =", jn, "/2, mu0n =", mu0n

			nuc%la(1) = ln
			nuc%ja(1) = jn
			nuc%ia(1) = in
			nuc%mu0(1) = mu0n
		END IF
		RETURN
	END SUBROUTINE Nucleus_set_NeutronBlocking

	SUBROUTINE Nucleus_show_ExperimentalData(nuc)
		TYPE (NucleusType), INTENT(IN) :: nuc

		CHARACTER(128) str

		IF (nuc%num .EQ. 0) RETURN

		PRINT "(/A,A)", "Datos experimentales para: ", Nucleus_name(nuc%num)
!		PRINT *, "Binding Energy:", Expm(Nucleus_BindingEnergy(0, nuc%num), Nucleus_BindingEnergy(1, nuc%num), "eV", "k")
!		PRINT *, "Atomic Mass:", Expm(Nucleus_AtomicMass(0, nuc%num), Nucleus_AtomicMass(1, nuc%num), "amu", "micro")
!		PRINT *, "Mass Excess:", Expm(Nucleus_MassExcess(0, nuc%num), Nucleus_MassExcess(1, nuc%num), "eV", "k")
		PRINT "(A16,E,A,E,A)", "Binding Energy:", Nucleus_BindingEnergy(0, nuc%num), " +/-", Nucleus_BindingEnergy(1, nuc%num), " eV"
		PRINT "(A16,E,A,E,A)", "Atomic Mass:", Nucleus_AtomicMass(0, nuc%num), " +/-", Nucleus_AtomicMass(1, nuc%num), " amu"
		PRINT "(A16,E,A,E,A)", "Mass Excess:", Nucleus_MassExcess(0, nuc%num), " +/-", Nucleus_MassExcess(1, nuc%num), " eV"
		RETURN
	END SUBROUTINE Nucleus_show_ExperimentalData

	FUNCTION IS_ODD(n)
		LOGICAL IS_ODD
		INTEGER, INTENT(IN) :: n

		IS_ODD = BTEST(n, 0)
		RETURN
	END FUNCTION IS_ODD

	FUNCTION Nucleus_get_A(nuc)
		INTEGER Nucleus_get_A
		TYPE (NucleusType), INTENT(IN) :: nuc

		Nucleus_get_A = nuc%np(0) + nuc%np(1)
		RETURN
	END FUNCTION Nucleus_get_A

	FUNCTION Nucleus_get_b(nuc)
		DOUBLE PRECISION Nucleus_get_b
		TYPE (NucleusType), INTENT(IN) :: nuc

		Nucleus_get_b = nuc%func%x
		RETURN
	END FUNCTION Nucleus_get_b

	! Devuelve el nmero de neutrones del ncleo
	FUNCTION Nucleus_get_N(nuc)
		INTEGER Nucleus_get_N
		TYPE (NucleusType), INTENT(IN) :: nuc

		Nucleus_get_N = nuc%np(1)
		RETURN
	END FUNCTION Nucleus_get_N

	! Devuelve el nmero de protones del ncleo
	FUNCTION Nucleus_get_Z(nuc)
		INTEGER Nucleus_get_Z
		TYPE (NucleusType), INTENT(IN) :: nuc

		Nucleus_get_Z = nuc%np(0)
		RETURN
	END FUNCTION Nucleus_get_Z

	FUNCTION Nucleus_get_actual_R2(nuc)
		DOUBLE PRECISION Nucleus_get_actual_R2
		TYPE (NucleusType), INTENT(IN) :: nuc

		Nucleus_get_actual_R2 = ((nuc%np(0) * nuc%actual_R2(0))  &
		                       + (nuc%np(1) * nuc%actual_R2(1))) &
		                       / DBLE(nuc%np(0) + nuc%np(1))
		RETURN
	END FUNCTION Nucleus_get_actual_R2

	FUNCTION Nucleus_get_R2n(nuc)
		DOUBLE PRECISION Nucleus_get_R2n
		TYPE (NucleusType), INTENT(IN) :: nuc

		Nucleus_get_R2n = nuc%actual_R2(1)
		RETURN
	END FUNCTION Nucleus_get_R2n

	FUNCTION Nucleus_get_R2p(nuc)
		DOUBLE PRECISION Nucleus_get_R2p
		TYPE (NucleusType), INTENT(IN) :: nuc

		Nucleus_get_R2p = nuc%actual_R2(0)
		RETURN
	END FUNCTION Nucleus_get_R2p

	SUBROUTINE Nucleus_set_N(nuc, N)
		TYPE (NucleusType), INTENT(INOUT) :: nuc
		INTEGER, INTENT(IN) :: N

		nuc%np(1) = N
		nuc%np(2) = nuc%np(0) + nuc%np(1)
		RETURN
	END SUBROUTINE Nucleus_set_N

	SUBROUTINE Nucleus_set_Z(nuc, Z)
		TYPE (NucleusType), INTENT(INOUT) :: nuc
		INTEGER, INTENT(IN) :: Z

		nuc%np(0) = Z
		nuc%np(2) = nuc%np(0) + nuc%np(1)
		RETURN
	END SUBROUTINE Nucleus_set_Z

	SUBROUTINE Nucleus_set_b(nuc, b)
		TYPE (NucleusType), INTENT(INOUT) :: nuc
		DOUBLE PRECISION, INTENT(IN) :: b

		CALL R1R1Function_set(nuc%func, b)
		RETURN
	END SUBROUTINE Nucleus_set_b

	! Muestra los valores del ncleo
	SUBROUTINE Nucleus_show_Status(nuc)
		TYPE (NucleusType), INTENT(IN) :: nuc

		INTEGER i

		PRINT *
		PRINT "(A)", "Nucleo:"
		PRINT "(70A1)", ("-", i = 1, 70) ! Muestra una lnea de separacin

		PRINT "(A30,F15.5)", "Longitud del oscinador (b):", nuc%func%x
		PRINT "(A30,I15,I15)", "Numero de particulas (np):", nuc%np(0), nuc%np(1)
		PRINT "(A30,F15.5,F15.5)", "(actual_np):", nuc%actual_np(0), nuc%actual_np(1)
		PRINT "(A30,F15.5,F15.5)", "(lambda_np):", nuc%lambda_np(0), nuc%lambda_np(1)
		PRINT "(A30,F15.5,F15.5,F15.5)", "(actual_R2):", nuc%actual_R2(0), nuc%actual_R2(1), nuc%actual_R2(2)
		PRINT "(A30,E15.5,E15.5)", "(lambda_R2):", nuc%lambda_R2(0), nuc%lambda_R2(1)
		PRINT "(A30,F15.5)", "Energia total (eHFB):", nuc%eHFB
		PRINT "(A30,E15.5)", "Apareamiento:", nuc%pairing
		PRINT "(A30,E15.5)", "R2:", nuc%R2
		PRINT "(A30,F15.5)", "Norma:", nuc%norma

		PRINT "(70A1)", ("-", i = 1, 70)

		IF (nuc%is_blocking(0)) THEN
			PRINT "(A,I5,A,I5,A,I5)", "Hay bloqueo de neutrones en: la=", nuc%la(0), "ja=", nuc%ja(0), "mu0=", nuc%mu0(0)
		END IF
		IF (nuc%is_blocking(1)) THEN
			PRINT "(A,I5,A,I5,A,I5)", "Hay bloqueo de neutrones en: la=", nuc%la(1), "ja=", nuc%ja(1), "mu0=", nuc%mu0(1)
		END IF
	END SUBROUTINE Nucleus_show_Status

	SUBROUTINE Nucleus_del(nuc)
		TYPE (NucleusType), INTENT(INOUT) :: nuc

		CALL R1R1Function_del(nuc%func)
	END SUBROUTINE Nucleus_del

END MODULE nucleus
 MODULE r1r1

	IMPLICIT NONE

	TYPE R1R1Function
		DOUBLE PRECISION x
		LOGICAL x_set ! Tiene "x" un valor asignado?
		DOUBLE PRECISION x_min, x_max ! Rango de "x"
		LOGICAL infinite_x_min, infinite_x_max ! Es el rango infinito?
		LOGICAL is_even ! is_odd
!		DOUBLE PRECISION func
	END TYPE

 CONTAINS

	SUBROUTINE R1R1Function_new(func)
		TYPE (R1R1Function), INTENT(INOUT) :: func

		func%x_set = .FALSE.
		func%infinite_x_min = .TRUE.
		func%infinite_x_max = .TRUE.
		func%is_even = .FALSE. ! is_odd?
		RETURN
	END SUBROUTINE R1R1Function_new

	SUBROUTINE R1R1Function_new_R1R1Function(func_out, func_in)
		TYPE (R1R1Function), INTENT(INOUT) :: func_out
		TYPE (R1R1Function), INTENT(IN) :: func_in

		func_out%infinite_x_min = func_in%infinite_x_min
		func_out%infinite_x_max = func_in%infinite_x_max
		func_out%x_set = func_in%x_set
		func_out%x = 0 !TODO func_in%x
		func_out%is_even = func_in%is_even
		RETURN
	END SUBROUTINE R1R1Function_new_R1R1Function

	SUBROUTINE R1R1Function_set(func, X) 
		TYPE (R1R1Function), INTENT(INOUT) :: func
		DOUBLE PRECISION, INTENT(IN) :: X

!		The function is assumed constant outside its range
		IF (.NOT. func%infinite_x_min .AND. (X .LE. func%x_min)) THEN
			func%x = func%x_min
		ELSE IF (.NOT. func%infinite_x_max .AND. (X .GE. func%x_max)) THEN
			func%x = func%x_max
		ELSE
			func%x = X
		END IF
		func%x_set = .TRUE.
		RETURN
	END SUBROUTINE R1R1Function_set

	FUNCTION R1R1Function_isValid(func, X)
		LOGICAL R1R1Function_isValid
		TYPE (R1R1Function), INTENT(INOUT) :: func
		DOUBLE PRECISION, INTENT(IN) :: X

		CALL R1R1Function_set(func, X)
		IF (((func%infinite_x_min) .OR. (func%x .GT. func%x_min)) .AND. &
		    ((func%infinite_x_max) .OR. (func%x .LT. func%x_max))) THEN
			R1R1Function_isValid = .TRUE.
		ELSE
			R1R1Function_isValid = .FALSE.
		END IF
		RETURN
	END FUNCTION R1R1Function_isValid

	SUBROUTINE R1R1Function_del(func)
		TYPE (R1R1Function), INTENT(INOUT) :: func

		func%x_set = .FALSE.
		RETURN
	END SUBROUTINE R1R1Function_del

END MODULE r1r1
MODULE selfc

	USE input
	USE nucleus
	USE symden
	USE symke2b
	USE symvbb
	USE symvc
	USE symvls
	USE symgdd

	IMPLICIT NONE

	TYPE SelfConsistencyMethod
		TYPE (SymKineticEnergy2Body) vEkCMph
		TYPE (SymVBBph) vBBph
		TYPE (SymVBBpp) vBBpp
		TYPE (SymVCph) vCph
		TYPE (SymVCpp) vCpp
		TYPE (SymVLSph) vLSph
		TYPE (SymVLSpp) vLSpp
		TYPE (SymGDDph) gDDph
		TYPE (SymDensity), POINTER :: density
	END TYPE

CONTAINS

	SUBROUTINE SelfConsistencyMethod_new(consistency, density)
		TYPE (SelfConsistencyMethod), INTENT(INOUT) :: consistency
		TYPE (SymDensity), TARGET, INTENT(IN) :: density

		DOUBLE PRECISION b

		b = Nucleus_get_b(density%nucleus)
		CALL SymKineticEnergy2Body_new(consistency%vEkCMph)
		CALL SymVBBph_new(consistency%vBBph, b)
		CALL SymVBBpp_new(consistency%vBBpp, b)
		CALL SymVCph_new(consistency%vCph)
		CALL SymVCpp_new(consistency%vCpp)
		CALL SymVLSph_new(consistency%vLSph)
		CALL SymVLSpp_new(consistency%vLSpp)
		CALL SymGDDph_new(consistency%gDDph)
		consistency%density => density
		RETURN
	END SUBROUTINE SelfConsistencyMethod_new

	SUBROUTINE SelfConsistencyMethod_store_eHFB(consistency)
		TYPE (SelfConsistencyMethod), INTENT(INOUT) :: consistency

		DOUBLE PRECISION eHF
		DOUBLE PRECISION kinetic_energy, kinetic_CM_energy
		DOUBLE PRECISION local_energy_BB, exchange_energy_BB ! Brink-Booker
		DOUBLE PRECISION local_energy_Coulomb, exchange_energy_Coulomb
		DOUBLE PRECISION dd_energy ! Density Dependent
		DOUBLE PRECISION ls_energy

		DOUBLE PRECISION pairing
		DOUBLE PRECISION pairing_BB ! BrinkBooker
		DOUBLE PRECISION pairing_Coulomb
		DOUBLE PRECISION pairing_LS !

		kinetic_energy          = SelfConsistencyMethod_get_Ek(consistency)
		kinetic_CM_energy       = SelfConsistencyMethod_get_EkCM(consistency)
		local_energy_BB         = SelfConsistencyMethod_get_LocalBBEnergy(consistency)
 		local_energy_Coulomb    = SelfConsistencyMethod_get_LocalCoulombEnergy(consistency)
		exchange_energy_BB      = SelfConsistencyMethod_get_ExchangeBBEnergy(consistency)
		exchange_energy_Coulomb = SelfConsistencyMethod_get_ExchangeCoulombEnergy(consistency)
		dd_energy               = SelfConsistencyMethod_get_DDEnergy(consistency)
		ls_energy               = SelfConsistencyMethod_get_LSEnergy(consistency)

		eHF = kinetic_energy + kinetic_CM_energy &
			+ local_energy_BB + exchange_energy_BB &
			+ local_energy_Coulomb + exchange_energy_Coulomb &
			+ dd_energy + ls_energy

		pairing_BB      = SelfConsistencyMethod_get_BBPairing(consistency)
		pairing_Coulomb = SelfConsistencyMethod_get_CoulombPairing(consistency)
		pairing_LS      = SelfConsistencyMethod_get_LSPairing(consistency)

		pairing = pairing_BB + pairing_Coulomb + pairing_LS

!	print *, "eHF & pairing =", eHF, pairing
!	print *, "kinetic_energy=", kinetic_energy
!	print *, "kinetic_CM_energy=", kinetic_CM_energy
!	print *, "local_energy_BB=", local_energy_BB
!	print *, "local_energy_Coulomb=", local_energy_Coulomb
!	print *, "exchange_energy_BB=", exchange_energy_BB
!	print *, "exchange_energy_Coulomb=", exchange_energy_Coulomb
!	print *, "dd_energy=", dd_energy
!	print *, "ls_energy=", ls_energy
!	print *, "pairing_BB=", pairing_BB
!	print *, "pairing_Coulomb=", pairing_Coulomb
!	print *, "pairing_LS=", pairing_LS
		consistency%density%nucleus%eHFB = eHF + pairing
		consistency%density%nucleus%pairing = pairing
		RETURN
	END SUBROUTINE SelfConsistencyMethod_store_eHFB

	! Energa cintica
	FUNCTION SelfConsistencyMethod_get_Ek(consistency)
		DOUBLE PRECISION SelfConsistencyMethod_get_Ek
		TYPE (SelfConsistencyMethod), INTENT(IN) :: consistency

		INTEGER A
		DOUBLE PRECISION b
		DOUBLE PRECISION factor
		INTEGER ta
		DOUBLE PRECISION, DIMENSION(0:1) :: Ek

		A = Nucleus_get_A(consistency%density%nucleus)
		b = Nucleus_get_b(consistency%density%nucleus)
		factor = (1.0 - (1.0 / A)) / (b ** 2.0)
		DO ta = 0, 1
			Ek(ta) = factor * (EkField * consistency%density%field%rho%p(ta))
		END DO
		SelfConsistencyMethod_get_Ek = Ek(0) + Ek(1)
		RETURN
	END FUNCTION SelfConsistencyMethod_get_Ek

	FUNCTION SelfConsistencyMethod_get_EkCM(consistency)
		DOUBLE PRECISION SelfConsistencyMethod_get_EkCM
		TYPE (SelfConsistencyMethod), INTENT(IN) :: consistency

		INTEGER A
		DOUBLE PRECISION b
		TYPE (SymHartreeFockField) HF_Gamma

		CALL SymHartreeFockField_new(HF_Gamma)
		CALL SymKineticEnergy2Body_get_Gamma(HF_Gamma, consistency%vEkCMph, consistency%density%field%rho)

		A = Nucleus_get_A(consistency%density%nucleus)
		b = Nucleus_get_b(consistency%density%nucleus)
		IF ((A .LE. 1) .OR. (b .LE. 0.1)) STOP "Abortado"
		SelfConsistencyMethod_get_EkCM = (0.5 / (A * (b ** 2))) * (consistency%density%field%rho * HF_Gamma)

		CALL SymHartreeFockField_del(HF_Gamma)
		RETURN
	END FUNCTION SelfConsistencyMethod_get_EkCM

	! Energa local de Brink-Booker
	FUNCTION SelfConsistencyMethod_get_LocalBBEnergy(consistency)
		DOUBLE PRECISION SelfConsistencyMethod_get_LocalBBEnergy
		TYPE (SelfConsistencyMethod), INTENT(IN) :: consistency

		TYPE (SymHartreeFockField) local_gamma

		CALL SymHartreeFockField_new(local_gamma)
		CALL SymVBBph_get_LocalGamma(local_gamma, consistency%vBBph, consistency%density%field%rho)

		SelfConsistencyMethod_get_LocalBBEnergy = 0.5 * (consistency%density%field%rho * local_gamma)

		CALL SymHartreeFockField_del(local_gamma)
		RETURN
	END FUNCTION SelfConsistencyMethod_get_LocalBBEnergy

	! Energa de intercambio de Brink-Booker
	FUNCTION SelfConsistencyMethod_get_ExchangeBBEnergy(consistency)
		DOUBLE PRECISION SelfConsistencyMethod_get_ExchangeBBEnergy
		TYPE (SelfConsistencyMethod), INTENT(IN) :: consistency

		TYPE (SymHartreeFockField) exchange_gamma

		CALL SymHartreeFockField_new(exchange_gamma)
		CALL SymVBBph_get_ExchangeGamma(exchange_gamma, consistency%vBBph, consistency%density%field%rho)

		SelfConsistencyMethod_get_ExchangeBBEnergy = 0.5 * (consistency%density%field%rho * exchange_gamma)

		CALL SymHartreeFockField_del(exchange_gamma)
		RETURN
	END FUNCTION SelfConsistencyMethod_get_ExchangeBBEnergy

	! Energa local de Coulomb
	FUNCTION SelfConsistencyMethod_get_LocalCoulombEnergy(consistency)
		DOUBLE PRECISION SelfConsistencyMethod_get_LocalCoulombEnergy
		TYPE (SelfConsistencyMethod), INTENT(IN) :: consistency

		DOUBLE PRECISION b
		TYPE (SymHartreeFockField) local_gamma

		CALL SymHartreeFockField_new(local_gamma)
		CALL SymVCph_get_LocalGamma(local_gamma, consistency%vCph, consistency%density%field%rho)

		b = Nucleus_get_b(consistency%density%nucleus)
		SelfConsistencyMethod_get_LocalCoulombEnergy = (0.5 / b) * (consistency%density%field%rho * local_gamma)

		CALL SymHartreeFockField_del(local_gamma)
		RETURN
	END FUNCTION SelfConsistencyMethod_get_LocalCoulombEnergy

	! Energa de intercambio de Coulomb
	FUNCTION SelfConsistencyMethod_get_ExchangeCoulombEnergy(consistency)
		DOUBLE PRECISION SelfConsistencyMethod_get_ExchangeCoulombEnergy
		TYPE (SelfConsistencyMethod), INTENT(IN) :: consistency

		DOUBLE PRECISION b
		TYPE (SymHartreeFockField) exchange_gamma

		CALL SymHartreeFockField_new(exchange_gamma)
		CALL SymVCph_get_ExchangeGamma(exchange_gamma, consistency%vCph, consistency%density%field%rho)

		b = Nucleus_get_b(consistency%density%nucleus)
		SelfConsistencyMethod_get_ExchangeCoulombEnergy = (0.5 / b) * (consistency%density%field%rho * exchange_gamma)

		CALL SymHartreeFockField_del(exchange_gamma)
		RETURN
	END FUNCTION SelfConsistencyMethod_get_ExchangeCoulombEnergy

	! Energa dependiente de la densidad
	FUNCTION SelfConsistencyMethod_get_DDEnergy(consistency)
		DOUBLE PRECISION SelfConsistencyMethod_get_DDEnergy
		TYPE (SelfConsistencyMethod), INTENT(INOUT) :: consistency

		DOUBLE PRECISION b

		b = Nucleus_get_b(consistency%density%nucleus)
		CALL SymGDDph_make_DD(consistency%gDDph, consistency%density%field%rho)
		SelfConsistencyMethod_get_DDEnergy = SymGDDph_get_edd(consistency%gDDph) / (b ** 4.0)
		RETURN
	END FUNCTION SelfConsistencyMethod_get_DDEnergy

	FUNCTION SelfConsistencyMethod_get_LSEnergy(consistency)
		DOUBLE PRECISION SelfConsistencyMethod_get_LSEnergy
		TYPE (SelfConsistencyMethod), INTENT(IN) :: consistency

		DOUBLE PRECISION b
		TYPE (SymHartreeFockField) HF_Gamma

		CALL SymHartreeFockField_new(HF_Gamma)
		CALL SymVLSph_get_Gamma(HF_Gamma, consistency%vLSph, consistency%density%field%rho)

		b = Nucleus_get_b(consistency%density%nucleus)
		SelfConsistencyMethod_get_LSEnergy = (0.5 / (b ** 5.0)) * (consistency%density%field%rho * HF_Gamma)

		CALL SymHartreeFockField_del(HF_Gamma)
		RETURN
	END FUNCTION SelfConsistencyMethod_get_LSEnergy

	! Apareamiento de Brink-Booker
	FUNCTION SelfConsistencyMethod_get_BBPairing(consistency)
		DOUBLE PRECISION SelfConsistencyMethod_get_BBPairing
		TYPE (SelfConsistencyMethod), INTENT(IN) :: consistency

		TYPE (SymHartreeFockField) vbb_field

		CALL SymHartreeFockField_new(vbb_field)
		CALL SymVBBpp_product(vbb_field, consistency%vBBpp, consistency%density%field%kap)

		SelfConsistencyMethod_get_BBPairing = 0.5 * (consistency%density%field%kap * vbb_field)

		CALL SymHartreeFockField_del(vbb_field)
		RETURN
	END FUNCTION SelfConsistencyMethod_get_BBPairing

	! Apareamiento de Coulomb
	FUNCTION SelfConsistencyMethod_get_CoulombPairing(consistency)
		DOUBLE PRECISION SelfConsistencyMethod_get_CoulombPairing
		TYPE (SelfConsistencyMethod), INTENT(IN) :: consistency

		DOUBLE PRECISION b
		TYPE (SymHartreeFockField) delta

		CALL SymHartreeFockField_new(delta)
		CALL SymVCpp_get_Delta(delta, consistency%vCpp, consistency%density%field%kap)

		b = Nucleus_get_b(consistency%density%nucleus)
		SelfConsistencyMethod_get_CoulombPairing = (0.5 / b) * (consistency%density%field%kap * delta)

		CALL SymHartreeFockField_del(delta)
		RETURN
	END FUNCTION SelfConsistencyMethod_get_CoulombPairing

	FUNCTION SelfConsistencyMethod_get_LSPairing(consistency)
		DOUBLE PRECISION SelfConsistencyMethod_get_LSPairing
		TYPE (SelfConsistencyMethod), INTENT(IN) :: consistency

		DOUBLE PRECISION b
		TYPE (SymHartreeFockField) delta

		CALL SymHartreeFockField_new(delta)
		CALL SymVLSpp_get_Delta(delta, consistency%vLSpp, consistency%density%field%kap)

		b = Nucleus_get_b(consistency%density%nucleus)
		SelfConsistencyMethod_get_LSPairing = (0.5 / (b ** 5.0)) * (consistency%density%field%kap * delta)

		CALL SymHartreeFockField_del(delta)
		RETURN
	END FUNCTION SelfConsistencyMethod_get_LSPairing

	FUNCTION SelfConsistencyMethod_accuracy(consistency)
		DOUBLE PRECISION SelfConsistencyMethod_accuracy
		TYPE (SelfConsistencyMethod), INTENT(INOUT) :: consistency

		DOUBLE PRECISION old_eHFB

		old_eHFB = consistency%density%nucleus%eHFB
		CALL SelfConsistencyMethod_store_eHFB(consistency)
		SelfConsistencyMethod_accuracy = ABS(old_eHFB - consistency%density%nucleus%eHFB)
		RETURN
	END FUNCTION SelfConsistencyMethod_accuracy

	SUBROUTINE SelfConsistencyMethod_show_Status(consistency)
		TYPE (SelfConsistencyMethod), INTENT(INOUT) :: consistency

		INTEGER i
		DOUBLE PRECISION b

		DOUBLE PRECISION eHF
		DOUBLE PRECISION kinetic_energy, kinetic_CM_energy
		DOUBLE PRECISION local_energy_BB, exchange_energy_BB ! Brink-Booker
		DOUBLE PRECISION local_energy_Coulomb, exchange_energy_Coulomb
		DOUBLE PRECISION dd_energy ! Density Dependent
		DOUBLE PRECISION ls_energy

		DOUBLE PRECISION pairing
		DOUBLE PRECISION pairing_BB ! BrinkBooker
		DOUBLE PRECISION pairing_Coulomb
		DOUBLE PRECISION pairing_LS !

		DOUBLE PRECISION N, Z

		b = Nucleus_get_b(consistency%density%nucleus)
		PRINT *
		PRINT "(A50,F20.10)", "Longitud del oscilador:", b
		PRINT "(70A1)", ("-", i = 1, 70)

		kinetic_energy = SelfConsistencyMethod_get_Ek(consistency)
		kinetic_CM_energy = SelfConsistencyMethod_get_EkCM(consistency)
		local_energy_BB = SelfConsistencyMethod_get_LocalBBEnergy(consistency)
 		local_energy_Coulomb = SelfConsistencyMethod_get_LocalCoulombEnergy(consistency)
		exchange_energy_BB = SelfConsistencyMethod_get_ExchangeBBEnergy(consistency)
		exchange_energy_Coulomb = SelfConsistencyMethod_get_ExchangeCoulombEnergy(consistency)
		dd_energy = SelfConsistencyMethod_get_DDEnergy(consistency)
		ls_energy = SelfConsistencyMethod_get_LSEnergy(consistency)
		PRINT "(A50,F20.10)", "Energia cinetica:", kinetic_energy
		PRINT "(A50,F20.10)", "Energia cinetica del centro de masas:", kinetic_CM_energy
		PRINT "(A50,F20.10)", "Energia local de Brink-Booker:", local_energy_BB
		PRINT "(A50,F20.10)", "Energia local de Coulomb:", local_energy_Coulomb
		PRINT "(A50,F20.10)", "Energia de intercambio de Brink-Booker:", exchange_energy_BB
		PRINT "(A50,F20.10)", "Energia de intercambio de Coulomb:", exchange_energy_Coulomb
		PRINT "(A50,F20.10)", "Energia dependiente de la densidad:", dd_energy
		PRINT "(A50,F20.10)", "Energia de spin-orbita:", ls_energy
		PRINT "(70A1)", ("-", i = 1, 70)

		eHF = kinetic_energy + kinetic_CM_energy &
			+ local_energy_BB + exchange_energy_BB &
			+ local_energy_Coulomb + exchange_energy_Coulomb &
			+ dd_energy + ls_energy
		PRINT "(A50,F20.10)", "Enertia total de Brink-Booker:", local_energy_BB + exchange_energy_BB
		PRINT "(A50,F20.10)", "Enertia total de Coulomb:", local_energy_Coulomb + exchange_energy_Coulomb
		PRINT "(A50,F20.10)", "Energia total (Hartree-Fock):", eHF
		PRINT "(70A1)", ("-", i = 1, 70)

		pairing_BB = SelfConsistencyMethod_get_BBPairing(consistency)
		pairing_Coulomb = SelfConsistencyMethod_get_CoulombPairing(consistency)
		pairing_LS = SelfConsistencyMethod_get_LSPairing(consistency)
		PRINT "(A50,E20.10)", "Apareamiento de Brink-Booker:", pairing_BB
		PRINT "(A50,E20.10)", "Apareamiento de Coulomb:", pairing_Coulomb
		PRINT "(A50,E20.10)", "Apareamiento de spin-orbita:", pairing_LS
		PRINT "(70A1)", ("-", i = 1, 70)

		pairing = pairing_BB + pairing_Coulomb + pairing_LS
		PRINT "(A50,E20.10)", "Apareamiento total:", pairing
		PRINT "(70A1)", ("-", i = 1, 70)

		PRINT "(A50,F20.10)", "TOTAL:", eHF + pairing

		PRINT *
		PRINT "(A40,A15,A15)", "Neutrones", "Protones", "Total"
		N = consistency%density%nucleus%actual_np(0)
		Z = consistency%density%nucleus%actual_np(1)
		PRINT "(A25,F15.5,F15.5,F15.5)", "Particulas:", N, Z, N + Z
		PRINT "(A25,F15.5,F15.5)", "Potenciales quimicos:", &
			consistency%density%nucleus%lambda_np(0), &
			consistency%density%nucleus%lambda_np(1)
		PRINT "(A25,F15.5,F15.5,F15.5)", "Radio:", &
			SQRT(consistency%density%nucleus%actual_R2(0)), &
			SQRT(consistency%density%nucleus%actual_R2(1)), &
			SQRT(Nucleus_get_actual_R2(consistency%density%nucleus))
		PRINT "(A25,F15.5,F15.5,F15.5)", "Multiplicadores y error:", &
			consistency%density%nucleus%lambda_R2(0), &
			consistency%density%nucleus%lambda_R2(1), &
			Nucleus_get_actual_R2(consistency%density%nucleus) - consistency%density%nucleus%R2
! D.showSpatialDistribution(NEU)
!TODO		CALL Nucleus_show_ExperimentalData(consistency%density%nucleus)
		RETURN
	END SUBROUTINE SelfConsistencyMethod_show_Status

	SUBROUTINE SelfConsistencyMethod_del(consistency)
		TYPE (SelfConsistencyMethod), INTENT(INOUT) :: consistency

		CALL SymKineticEnergy2Body_del(consistency%vEkCMph)
		CALL SymVBBph_del(consistency%vBBph)
		CALL SymVBBpp_del(consistency%vBBpp)
		CALL SymVCph_del(consistency%vCph)
		CALL SymVCpp_del(consistency%vCpp)
		CALL SymVLSph_del(consistency%vLSph)
		CALL SymVLSpp_del(consistency%vLSpp)
		CALL SymGDDph_del(consistency%gDDph)
		NULLIFY(consistency%density)
		RETURN
	END SUBROUTINE SelfConsistencyMethod_del

END MODULE selfc
!------------------------------------------------------------------------------!
!                                                                              !
!                       DEFINITION OF SPECIFIC TYPES                           !
!                                                                              !
!                                                                              !
!  In spherical symmetry, the calculation of the matrix elements often makes   !
!  use of tensors of the form:                                                 !
!                           T_{la, na, nb}                                     !
!                                                                              !
!  which correspond to the reduced form of a more general object               !
!                                                                              !
!         T_{na, nb, la} = delta_{ac} * T_{a,c}, with a = (na, la ja)          !
!                                                                              !
!  See infamous PhD, page 45, top of the page. THIS IS SPECIFIC TO SPHERICAL   !
!  SYMMETRY.                                                                   !
!                                                                              !
!  The definitions of the types below and of their related operations provide  !
!  an appropriate storage facility for all these objects. Each of these "3D    !
!  tensors" has a total size:                                                  !
!                                                                              !
!        (N+1) * n_max(l) * n_max(l),     with: n_max(l) = (N - l)/ 2 + 1      !
!                                                                              !
!  SymD2Tensor: n_max(l) * n_max(l) array T_{la, na, nb} for a given la        !
!  SymD3Tensor: Full (N+1) * n_max(l) * n_max(l) array T_{la, na, nb}          !
!  SymD2Tensor_SymD3Tensor:                                                    !
!  SymD3Tensor_SymD3Tensor: "Matrix" of SymD3Tensor's                          !
!                                                                              !
!                                                                              !
!  NOTA BENE: FOR ADAPTATION TO THE CASE OF A RANDOM SPHERICAL BASIS (NOT THE  !
!             HARMONIC OSCILLATOR) A METHOD MUST BE FOUND TO DEFINE N0        !
!                                                                              !
!------------------------------------------------------------------------------!

 MODULE symd3t

	USE input

	IMPLICIT NONE
 
        ! SymD2Tensor points to a 2D array or real numbers	
	TYPE SymD2Tensor
		DOUBLE PRECISION, DIMENSION(:, :), POINTER :: d2
	END TYPE

        ! SymD3Tensor points to a vector or SymD2Tensor, so it points to a vector of 
	! matrices. 
	! It is the sophisticated version of a 3D array	
	TYPE SymD3Tensor
		TYPE (SymD2Tensor), DIMENSION(:), POINTER :: d3tensor
	END TYPE

        ! SymD2Tensor_ SymD3Tensor points to an array or SymD3Tensor. 
	! This is the sophisticated version of a 5D array
	TYPE SymD2Tensor_SymD3Tensor
		TYPE (SymD3Tensor), DIMENSION(:, :), POINTER :: d2
	END TYPE

        ! SymD3Tensor_ SymD3Tensor points to a vector or SymD2Tensor_SymD3Tensor. 
	! This is the sophisticated version of a 6D array
	TYPE SymD3Tensor_SymD3Tensor
		TYPE (SymD2Tensor_SymD3Tensor), DIMENSION(:), POINTER :: d3tensor
	END TYPE

	INTERFACE ASSIGNMENT(=)
		MODULE PROCEDURE &
			SymD3Tensor_assign1, &
			SymD3Tensor_assign2, &
			SymD3Tensor_SymD3Tensor_assign1, &
			SymD3Tensor_SymD3Tensor_assign2
	END INTERFACE

!	INTERFACE OPERATOR(+)
!		MODULE PROCEDURE &
!			SymD3Tensor_add, &
!			SymD3Tensor_SymD3Tensor_add
!	END INTERFACE

	INTERFACE OPERATOR(*)
		MODULE PROCEDURE SymD3Tensor_product2
	END INTERFACE

 CONTAINS

	! Creating an object SymD3Tensor by allocating memory for it
	SUBROUTINE SymD3Tensor_new(t)
		TYPE (SymD3Tensor), INTENT(INOUT) :: t

		INTEGER u1, d

                ! Allocating memory for the vector of SymD2Tensor tensors
		ALLOCATE(t%d3tensor(0:N_0))
                ! For each SymD2Tensor of the aforementioned vector, allocating memory for the 
		! corresponding array
		DO u1 = 0, N_0
			d = ((N_0 - u1) / 2) + 1
			ALLOCATE(t%d3tensor(u1)%d2(d, d))
		END DO
		RETURN
	END SUBROUTINE SymD3Tensor_new

	FUNCTION SymD3Tensor_read(t, file_desc, file_error)
		LOGICAL SymD3Tensor_read
		TYPE (SymD3Tensor), INTENT(INOUT) :: t
		INTEGER, INTENT(IN) :: file_desc
		INTEGER, INTENT(INOUT) :: file_error

		INTEGER u1, u2, u3, d
		INTEGER v1, v2, v3

		DO u1 = 0, N_0
			d = ((N_0 - u1) / 2) + 1
			DO u2 = 1, d
				DO u3 = 1, u2
					READ (file_desc, FMT="(I3,I3,I3,E)", IOSTAT=file_error) &
						v1, v2, v3, t%d3tensor(u1)%d2(u2, u3)
					IF ((file_error .NE. 0) .OR. &
					    (u1 .NE. v1) .OR. (u2 .NE. v2) .OR. (u3 .NE. v3)) THEN
						SymD3Tensor_read = .FALSE.
						RETURN
					END IF
				END DO
			END DO
		END DO
		SymD3Tensor_read = .TRUE.
		RETURN
	END FUNCTION SymD3Tensor_read

	SUBROUTINE SymD3Tensor_write(t, file_desc, file_error)
		TYPE (SymD3Tensor), INTENT(IN) :: t
		INTEGER, INTENT(IN) :: file_desc
		INTEGER, INTENT(INOUT) :: file_error

		INTEGER u1, u2, u3, d

		DO u1 = 0, N_0
			d = ((N_0 - u1) / 2) + 1
			DO u2 = 1, d
				DO u3 = 1, u2
					WRITE (file_desc, FMT="(I3,I3,I3,E)", IOSTAT=file_error) &
						u1, u2, u3, t%d3tensor(u1)%d2(u2, u3)
				END DO
			END DO
		END DO
		RETURN
	END SUBROUTINE SymD3Tensor_write

	! Calculating the trace of a 3D tensor
	FUNCTION SymD3Tensor_trace(t_in)
		DOUBLE PRECISION SymD3Tensor_trace
		TYPE (SymD3Tensor), INTENT(IN) :: t_in

		INTEGER la, na, d

		SymD3Tensor_trace = 0.0
		DO la = 0, N_0
			d = ((N_0 - la) / 2) + 1
			DO na = 1, d
				SymD3Tensor_trace = SymD3Tensor_trace + t_in%d3tensor(la)%d2(na, na)
			END DO
		END DO
		RETURN
	END FUNCTION SymD3Tensor_trace

	! Function which gives as output a square matrix containing the matrix of a given tensor
	! operator in the harmonic oscillator basis
	
	FUNCTION SymD3Tensor_matrix(t_in, la)
		DOUBLE PRECISION, DIMENSION(((N_0 - la) / 2) + 1, ((N_0 - la) / 2) + 1) :: SymD3Tensor_matrix
		TYPE (SymD3Tensor), INTENT(INOUT) :: t_in
		INTEGER, INTENT(IN) :: la

		INTEGER u1, u2, d

		! Reconstruction of the matrix of the tensor from the lower triangular part
		
		d = ((N_0 - la) / 2) + 1
		DO u1 = 1, d
			DO u2 = 1, u1
				SymD3Tensor_matrix(u1, u2) = t_in%d3tensor(la)%d2(u1, u2)
				IF (u1 .NE. u2) THEN
					SymD3Tensor_matrix(u2, u1) = t_in%d3tensor(la)%d2(u1, u2)
				END IF
			END DO
		END DO
		RETURN
	END FUNCTION SymD3Tensor_matrix

	SUBROUTINE SymD3Tensor_assign1(t_out, t_in)
		TYPE (SymD3Tensor), INTENT(INOUT) :: t_out
		TYPE (SymD3Tensor), INTENT(IN) :: t_in

		INTEGER u1, u2, u3, d

		DO u1 = 0, N_0
			d = ((N_0 - u1) / 2) + 1
			DO u2 = 1, d
				DO u3 = 1, u2
					t_out%d3tensor(u1)%d2(u2, u3) = t_in%d3tensor(u1)%d2(u2, u3)
				END DO
			END DO
		END DO
		RETURN
	END SUBROUTINE SymD3Tensor_assign1

	SUBROUTINE SymD3Tensor_assign2(t_out, R1)
		TYPE (SymD3Tensor), INTENT(INOUT) :: t_out
		DOUBLE PRECISION, INTENT(IN) :: R1

		INTEGER u1, u2, u3, d

		DO u1 = 0, N_0
			d = ((N_0 - u1) / 2) + 1
			DO u2 = 1, d
				DO u3 = 1, u2
					t_out%d3tensor(u1)%d2(u2, u3) = R1
				END DO
			END DO
		END DO
		RETURN
	END SUBROUTINE SymD3Tensor_assign2

	SUBROUTINE SymD3Tensor_assign_Matrix(t_out, u1, M)
		TYPE (SymD3Tensor), INTENT(INOUT) :: t_out
		INTEGER, INTENT(IN) :: u1
		DOUBLE PRECISION, DIMENSION(:, :), INTENT(IN) :: M

		INTEGER u2, u3, d

		d = ((N_0 - u1) / 2) + 1
		DO u2 = 1, d
			DO u3 = 1, u2
				t_out%d3tensor(u1)%d2(u2, u3) = M(u2, u3)
			END DO
		END DO
		RETURN
	END SUBROUTINE SymD3Tensor_assign_Matrix

	SUBROUTINE SymD3Tensor_add(t_out, t1_in, t2_in)
		TYPE (SymD3Tensor), INTENT(INOUT) :: t_out
		TYPE (SymD3Tensor), INTENT(IN) :: t1_in, t2_in

		INTEGER u1, u2, u3, d

		DO u1 = 0, N_0
			d = ((N_0 - u1) / 2) + 1
			DO u2 = 1, d
				DO u3 = 1, u2
					t_out%d3tensor(u1)%d2(u2, u3) = &
						t1_in%d3tensor(u1)%d2(u2, u3) + &
						t2_in%d3tensor(u1)%d2(u2, u3)
				END DO
			END DO
		END DO
		RETURN
	END SUBROUTINE SymD3Tensor_add

	SUBROUTINE SymD3Tensor_product(t_out, R1, t_in)
		TYPE (SymD3Tensor), INTENT(INOUT) :: t_out
		DOUBLE PRECISION, INTENT(IN) :: R1
		TYPE (SymD3Tensor), INTENT(IN) :: t_in

		INTEGER u1, u2, u3, d

		DO u1 = 0, N_0
			d = ((N_0 - u1) / 2) + 1
			DO u2 = 1, d
				DO u3 = 1, u2
					t_out%d3tensor(u1)%d2(u2, u3) = R1 * t_in%d3tensor(u1)%d2(u2, u3)
				END DO
			END DO
		END DO
		RETURN
	END SUBROUTINE SymD3Tensor_product

	FUNCTION SymD3Tensor_product2(t1_in, t2_in)
		DOUBLE PRECISION SymD3Tensor_product2
		TYPE (SymD3Tensor), INTENT(IN) :: t1_in, t2_in

		INTEGER u1, u2, u3, d
		DOUBLE PRECISION sum_la, sum1

		SymD3Tensor_product2 = 0.0
		DO u1 = 0, N_0
			d = ((N_0 - u1) / 2) + 1
			sum_la = 0.0
			DO u2 = 1, d
				DO u3 = 1, u2
					sum1 = t1_in%d3tensor(u1)%d2(u2, u3) * t2_in%d3tensor(u1)%d2(u2, u3)
					IF (u2 .EQ. u3) THEN
						sum_la = sum_la + sum1
					ELSE
						sum_la = sum_la + (2.0 * sum1)
					END IF
				END DO
			END DO
			SymD3Tensor_product2 = SymD3Tensor_product2 + sum_la
		END DO
		RETURN
	END FUNCTION SymD3Tensor_product2

	FUNCTION SymD3Tensor_distance(t1_in, t2_in)
		DOUBLE PRECISION SymD3Tensor_distance
		TYPE (SymD3Tensor), INTENT(IN) :: t1_in, t2_in

		INTEGER u1, u2, u3, d
		DOUBLE PRECISION distance

		SymD3Tensor_distance = 0.0
		DO u1 = 0, N_0
			d = ((N_0 - u1) / 2) + 1
			DO u2 = 1, d
				DO u3 = 1, u2
!					SymD3Tensor_distance = MAX(SymD3Tensor_distance, ABS(t1_in%d3tensor(u1)%d2(u2, u3) - t2_in%d3tensor(u1)%d2(u2, u3)))
					distance = ABS(t1_in%d3tensor(u1)%d2(u2, u3) - t2_in%d3tensor(u1)%d2(u2, u3))
					IF (distance .GT. SymD3Tensor_distance) THEN
						SymD3Tensor_distance = distance
					END IF
				END DO
			END DO
		END DO
		RETURN
	END FUNCTION SymD3Tensor_distance

	SUBROUTINE SymD3Tensor_print(t)
		TYPE (SymD3Tensor), INTENT(IN) :: t

		INTEGER u1, u2, u3, d

		DO u1 = 0, N_0
			PRINT "(I2,A)", u1, ":"
			d = ((N_0 - u1) / 2) + 1
			DO u2 = 1, d
				PRINT "(13F10.5)", (t%d3tensor(u1)%d2(u2, u3), u3=1, u2)
			END DO
		END DO
		RETURN
	END SUBROUTINE SymD3Tensor_print

	! Empty the memory reserved for a 3D tensor
	
	SUBROUTINE SymD3Tensor_del(t)
		TYPE (SymD3Tensor), INTENT(IN) :: t

		INTEGER u1

		DO u1 = 0, N_0
			DEALLOCATE(t%d3tensor(u1)%d2)
		END DO
		DEALLOCATE(t%d3tensor)
		RETURN
	END SUBROUTINE SymD3Tensor_del

	! Reserves (allocates) the memory for a "matrix" of 3D tensors
	
	SUBROUTINE SymD3Tensor_SymD3Tensor_new(t)
		TYPE (SymD3Tensor_SymD3Tensor), INTENT(INOUT) :: t

		INTEGER u1, u2, u3, d

		ALLOCATE(t%d3tensor(0:N_0))
		DO u1 = 0, N_0
			d = ((N_0 - u1) / 2) + 1
			ALLOCATE(t%d3tensor(u1)%d2(d, d))
			DO u2 = 1, d
				DO u3 = 1, u2
					CALL SymD3Tensor_new(t%d3tensor(u1)%d2(u2, u3))
				END DO
			END DO
		END DO
		RETURN
	END SUBROUTINE SymD3Tensor_SymD3Tensor_new

	SUBROUTINE SymD3Tensor_SymD3Tensor_assign(t_out, la, na, nc, lb, nb, nd, R1)
		TYPE (SymD3Tensor_SymD3Tensor), INTENT(INOUT) :: t_out
		INTEGER, INTENT(IN) :: la, na, nc, lb, nb, nd
		DOUBLE PRECISION, INTENT(IN) :: R1

		t_out%d3tensor(la)%d2(na, nc)%d3tensor(lb)%d2(nb, nd) = R1
		RETURN
	END SUBROUTINE SymD3Tensor_SymD3Tensor_assign

	SUBROUTINE SymD3Tensor_SymD3Tensor_assign1(t_out, t_in)
		TYPE (SymD3Tensor_SymD3Tensor), INTENT(INOUT) :: t_out
		TYPE (SymD3Tensor_SymD3Tensor), INTENT(IN) :: t_in

		INTEGER u1, u2, u3, d

		DO u1 = 0, N_0
			d = ((N_0 - u1) / 2) + 1
			DO u2 = 1, d
				DO u3 = 1, u2
					t_out%d3tensor(u1)%d2(u2, u3) = t_in%d3tensor(u1)%d2(u2, u3)
				END DO
			END DO
		END DO
		RETURN
	END SUBROUTINE SymD3Tensor_SymD3Tensor_assign1

	SUBROUTINE SymD3Tensor_SymD3Tensor_assign2(t_out, R1)
		TYPE (SymD3Tensor_SymD3Tensor), INTENT(INOUT) :: t_out
		DOUBLE PRECISION, INTENT(IN) :: R1

		INTEGER u1, u2, u3, d

		DO u1 = 0, N_0
			d = ((N_0 - u1) / 2) + 1
			DO u2 = 1, d
				DO u3 = 1, u2
					t_out%d3tensor(u1)%d2(u2, u3) = R1
				END DO
			END DO
		END DO
		RETURN
	END SUBROUTINE SymD3Tensor_SymD3Tensor_assign2

	! Defines the addition of 2 "matrices" of 3D tensors
	
	SUBROUTINE SymD3Tensor_SymD3Tensor_add(t_out, t1_in, t2_in)
		TYPE (SymD3Tensor_SymD3Tensor), INTENT(INOUT) :: t_out
		TYPE (SymD3Tensor_SymD3Tensor), INTENT(IN) :: t1_in, t2_in

		INTEGER u1, u2, u3, d

		DO u1 = 0, N_0
			d = ((N_0 - u1) / 2) + 1
			DO u2 = 1, d
				DO u3 = 1, u2
					CALL SymD3Tensor_add(t_out%d3tensor(u1)%d2(u2, u3), &
						t1_in%d3tensor(u1)%d2(u2, u3), &
						t2_in%d3tensor(u1)%d2(u2, u3))
				END DO
			END DO
		END DO
		RETURN
	END SUBROUTINE SymD3Tensor_SymD3Tensor_add

	! Defines the product of 2 "matrices" of 3D tensors
	
	SUBROUTINE SymD3Tensor_SymD3Tensor_product(t_out, t1_in, t2_in)
		TYPE (SymD3Tensor), INTENT(INOUT) :: t_out
		TYPE (SymD3Tensor_SymD3Tensor), INTENT(IN) :: t1_in
		TYPE (SymD3Tensor), INTENT(IN) :: t2_in

		INTEGER u1, u2, u3, d

		DO u1 = 0, N_0
			d = ((N_0 - u1) / 2) + 1
			DO u2 = 1, d
				DO u3 = 1, u2
					t_out%d3tensor(u1)%d2(u2, u3) = t1_in%d3tensor(u1)%d2(u2, u3) * t2_in
				END DO
			END DO
		END DO
		RETURN
	END SUBROUTINE SymD3Tensor_SymD3Tensor_product

	! Empty the memory reserved for a "matrix" of 3D tensors
	
	SUBROUTINE SymD3Tensor_SymD3Tensor_del(t)
		TYPE (SymD3Tensor_SymD3Tensor), INTENT(IN) :: t

		INTEGER u1, u2, u3, d

		DO u1 = 0, N_0
			d = ((N_0 - u1) / 2) + 1
			DO u2 = 1, d
				DO u3 = 1, u2
					CALL SymD3Tensor_del(t%d3tensor(u1)%d2(u2, u3))
				END DO
			END DO
			DEALLOCATE(t%d3tensor(u1)%d2)
		END DO
		DEALLOCATE(t%d3tensor)
		RETURN
	END SUBROUTINE SymD3Tensor_SymD3Tensor_del

END MODULE symd3t
 MODULE symden

	USE input
	USE math
	USE global
	USE symd3t
	USE nucleus
	USE symfield

	IMPLICIT NONE

	TYPE SymDensity
		TYPE (NucleusType) nucleus
		TYPE (SymHartreeFockBogolField) field
	END TYPE

	INTERFACE ASSIGNMENT(=)
		MODULE PROCEDURE SymDensity_assign
	END INTERFACE

 CONTAINS

	SUBROUTINE SymDensity_new(density, N, Z)
		! Recibe como parmetros de entrada el registro de densidad
		! y el nmero de protones y electrones
		TYPE (SymDensity), INTENT(INOUT) :: density
		INTEGER, INTENT(IN) :: N, Z

		CALL SymHartreeFockBogolField_new(density%field)
		CALL Nucleus_new(density%nucleus, N, Z)
		CALL SymDensity_initialize(density)
		RETURN
	END SUBROUTINE SymDensity_new

	SUBROUTINE SymDensity_new_SymDensity(density_out, density_in)
		TYPE (SymDensity), INTENT(INOUT) :: density_out
		TYPE (SymDensity), INTENT(IN) :: density_in

		CALL SymHartreeFockBogolField_new(density_out%field)
		CALL Nucleus_new_Nucleus(density_out%nucleus, density_in%nucleus)
		density_out%field%rho = density_in%field%rho
		density_out%field%kap = density_in%field%kap
		RETURN
	END SUBROUTINE SymDensity_new_SymDensity

	SUBROUTINE SymDensity_new_Isotope(density, isotope)
		TYPE (SymDensity), INTENT(INOUT) :: density
		INTEGER, INTENT(IN) :: isotope

		CALL SymHartreeFockBogolField_new(density%field)
		CALL Nucleus_new_Isotope(density%nucleus, isotope)
		CALL SymDensity_initialize(density)
		RETURN
	END SUBROUTINE SymDensity_new_Isotope

	SUBROUTINE SymDensity_new_Name(density, name_in)
		TYPE (SymDensity), INTENT(INOUT) :: density
		CHARACTER(*), INTENT(IN) :: name_in

		CALL SymHartreeFockBogolField_new(density%field)
		CALL Nucleus_new_Name(density%nucleus, name_in)
		CALL SymDensity_initialize(density)
		RETURN
	END SUBROUTINE SymDensity_new_Name

	SUBROUTINE SymDensity_initialize(density)
		TYPE (SymDensity), INTENT(INOUT) :: density

		INTEGER ta, la, na, i
		INTEGER nosc, fin_apa, ini_apa, num, den
		DOUBLE PRECISION vv, vu

		! Calculo de la densidad inicial
		DO ta = 0, 1
			! Inicializamos a 0 las matrices de densidad
			density%field%rho%p(ta) = DBLE(0.0)
			density%field%rho%a(ta) = DBLE(0.0)
			density%field%kap%p(ta) = DBLE(0.0)
			density%field%kap%a(ta) = DBLE(0.0)

			! actual number of particles for isospin ta
			num = density%nucleus%np(ta)
			
			i = 1
			IF (N_0 .LE. 8) THEN
				IF (num .GE. MagicNumber(N_0)) STOP "Abortado: SymDensity_initialize (num >= MagicNumber(N_0))"
			END IF

			! Find out the current j-shell i
			DO WHILE (MagicNumber(i) .LE. num)
				i = i + 1
			END DO
			fin_apa = i

			IF (ta .EQ. 1) THEN
				PRINT "(/A,I2,A,I3)", "Hay apareamiento de los ", density%nucleus%np(ta), " neutrones hasta el estado mas bajo de la capa ", i
			ELSE
				PRINT "(/A,I2,A,I3)", "Hay apareamiento de los ", density%nucleus%np(ta), " protones hasta el estado mas bajo de la capa ", i
			END IF

 			den = MagicNumber(i)
			vv = DBLE(num) / DBLE(den)
   			vu = SQRT(vv) * SQRT(1.0 - vv)
			DO nosc = i - 1, 0, -1
				! Convenio u = (-1) ^ nosc * |u|
				vu = vu * PAR(nosc)
				DO la = nosc, 0, -2
					na = ((nosc - la) / 2) + 1
					density%field%rho%p(ta)%d3tensor(la)%d2(na, na) = 2 * ( 2*la + 1) * vv
					density%field%kap%p(ta)%d3tensor(la)%d2(na, na) = 2 * ( 2*la + 1) * vu
				END DO
			END DO

			la = fin_apa
			na = 1
			
			density%field%rho%p(ta)%d3tensor(la)%d2(na, na) = 2 * (la + 1) * vv
			density%field%rho%a(ta)%d3tensor(la)%d2(na, na) = vv
			density%field%kap%p(ta)%d3tensor(la)%d2(na, na) = 2 * (la + 1) * vu
			density%field%kap%a(ta)%d3tensor(la)%d2(na, na) = vu

!			CALL SymD3Tensor_print(density%field%rho%p(ta))
!			CALL SymD3Tensor_print(density%field%rho%a(ta))
!			CALL SymD3Tensor_print(density%field%kap%p(ta))
!			CALL SymD3Tensor_print(density%field%kap%a(ta))

			density%nucleus%actual_np(ta) = SymD3Tensor_trace(density%field%rho%p(ta))
		END DO
		RETURN
	END SUBROUTINE SymDensity_initialize

	SUBROUTINE SymDensity_read(density)
		TYPE (SymDensity), INTENT(INOUT) :: density

		IF(.NOT. SymHartreeFockBogolField_read(density%field, density%nucleus%filename)) THEN
			density%nucleus%actual_np(0) = SymD3Tensor_trace(density%field%rho%p(0))
			density%nucleus%actual_np(1) = SymD3Tensor_trace(density%field%rho%p(1))
			PRINT *, "Leida densidad con N = ", density%nucleus%actual_np(1), " Z = ", density%nucleus%actual_np(0)
		ELSE
			CALL SymDensity_initialize(density)
		END IF
		RETURN
	END SUBROUTINE SymDensity_read

	SUBROUTINE SymDensity_save(density)
		TYPE (SymDensity), INTENT(INOUT) :: density

		CALL SymHartreeFockBogolField_write(density%field, density%nucleus%filename)
		RETURN
	END SUBROUTINE SymDensity_save

	SUBROUTINE SymDensity_assign(density_out, density_in)
		TYPE (SymDensity), INTENT(INOUT) :: density_out
		TYPE (SymDensity), INTENT(IN) :: density_in

		density_out%field = density_in%field
		RETURN
	END SUBROUTINE SymDensity_assign

	SUBROUTINE SymDensity_store_actual_R2(density)
		TYPE (SymDensity), INTENT(INOUT) :: density

		DOUBLE PRECISION b2
		INTEGER ta

		b2 = Nucleus_get_b(density%nucleus) ** 2
		DO ta=0, 1
			density%nucleus%actual_R2(ta) = b2 * (R2Field * density%field%rho%p(ta)) &
				/ density%nucleus%np(ta)
		END DO
		density%nucleus%actual_R2(2) = &
			 ((density%nucleus%np(0) * density%nucleus%actual_R2(0))  &
			+ (density%nucleus%np(1) * density%nucleus%actual_R2(1))) &
			/ (density%nucleus%np(0) + density%nucleus%np(1))
		RETURN
	END SUBROUTINE SymDensity_store_actual_R2

	SUBROUTINE SymDensity_shuffle(density)
		TYPE (SymDensity), INTENT(INOUT) :: density

		INTEGER ta, la, nosc
		INTEGER i, fin_apa, ini_apa, num, den, na
		DOUBLE PRECISION vv, vu

		DO ta = 0, 1
			density%field%kap%p(ta) = DBLE(0.0)
			density%field%kap%a(ta) = DBLE(0.0)
			num = density%nucleus%np(ta)
			IF (N_0 .LE. 8) THEN
				IF (num .GE. MagicNumber(N_0)) STOP "Numero de particulas no valido"
			END IF
			i = 1
			DO WHILE (MagicNumber(i) .LE. num)
				i = i + 1
			END DO
			fin_apa = i

			den = MagicNumber(i)
			vv = DBLE(num) / den
			vu = SQRT(vv) * SQRT(1.0 - vv)
			DO nosc = i - 1, 0, -1
				vu = vu * PAR(nosc) ! convenio u = (-)^l * |u|
				DO la = nosc, 0, -2
					na = ((nosc - la) / 2) + 1
					density%field%kap%p(ta)%d3tensor(la)%d2(na, na) = 2.0 * ((2.0 * la) + 1.0) * vu
				END DO
			END DO
			la = fin_apa
			na = 1

			density%field%kap.p(ta)%d3tensor(la)%d2(na, na) = 2.0 * (la + 1.0) * vu
			density%field%kap.a(ta)%d3tensor(la)%d2(na, na) = vu
		END DO
		RETURN
	END SUBROUTINE SymDensity_shuffle

	SUBROUTINE SymDensity_show_SpatialDistribution(density, ta)
		TYPE (SymDensity), INTENT(INOUT) :: density
		INTEGER, INTENT(IN) :: ta

!TODO
		RETURN
	END SUBROUTINE SymDensity_show_SpatialDistribution

	SUBROUTINE SymDensity_show_ParticleDensity(density)
		TYPE (SymDensity), INTENT(INOUT) :: density

!TODO Donde esta?
		RETURN
	END SUBROUTINE SymDensity_show_ParticleDensity

	SUBROUTINE SymDensity_del(density)
		TYPE (SymDensity), INTENT(INOUT) :: density

		CALL Nucleus_del(density%nucleus)
		CALL SymHartreeFockBogolField_del(density%field)
		RETURN
	END SUBROUTINE SymDensity_del

END MODULE symden
MODULE symfield

	USE input
	USE global
	USE symd3t
!	USE symgden
	USE symtalm

	IMPLICIT NONE

	TYPE SymHartreeFockField
		TYPE (SymD3Tensor), DIMENSION(0:1) :: p
		TYPE (SymD3Tensor), DIMENSION(0:1) :: a
	END TYPE

	TYPE SymHartreeFockBogolField
		TYPE (SymHartreeFockField) rho
		TYPE (SymHartreeFockField) kap
	END TYPE

	INTERFACE ASSIGNMENT(=)
		MODULE PROCEDURE &
			SymHartreeFockField_assign, &
			SymHartreeFockBogolField_assign
	END INTERFACE

!	INTERFACE OPERATOR(+)
!		MODULE PROCEDURE SymHartreeFockField_add
!	END INTERFACE

	INTERFACE OPERATOR(*)
		MODULE PROCEDURE SymHartreeFockField_product2
	END INTERFACE

CONTAINS

	SUBROUTINE SymHartreeFockBogolField_new(HFB)
		TYPE (SymHartreeFockBogolField), INTENT(INOUT) :: HFB

		CALL SymHartreeFockField_new(HFB%rho)
		CALL SymHartreeFockField_new(HFB%kap)
		RETURN
	END SUBROUTINE SymHartreeFockBogolField_new

	FUNCTION SymHartreeFockBogolField_read(HFB, filename)
		LOGICAL SymHartreeFockBogolField_read
		TYPE (SymHartreeFockBogolField), INTENT(INOUT) :: HFB
		CHARACTER(*), INTENT(IN) :: filename

		INTEGER, PARAMETER :: file_desc = 6 ! Descriptor de fichero
		INTEGER file_error, new_N_0

		OPEN (file_desc, FILE=TRIM(filename), ACTION="READ", IOSTAT=file_error)
		IF (file_error .NE. 0) THEN
			PRINT *, "No se pudo leer ", filename, " del disco"
			SymHartreeFockBogolField_read = .FALSE.
			RETURN
		END IF

		READ (file_desc, *) new_N_0
		PRINT *, "La funcion de onda es para un espacio de dimension ", new_N_0
		IF (new_N_0 .NE. N_0) THEN
			PRINT *, "Asi que no se puede usar"
			CLOSE (file_desc)
			SymHartreeFockBogolField_read = .FALSE.
			RETURN
		END IF

		IF ((SymHartreeFockField_read(HFB%rho, file_desc, file_error)) .AND. &
		    (SymHartreeFockField_read(HFB%kap, file_desc, file_error))) THEN
			SymHartreeFockBogolField_read = .TRUE.
		ELSE
			SymHartreeFockBogolField_read = .FALSE.
		END IF
		CLOSE (file_desc)
		RETURN
	END FUNCTION SymHartreeFockBogolField_read

	! Almacena los datos de los campos rho y kap en un fichero
	SUBROUTINE SymHartreeFockBogolField_write(HBF, filename)
		TYPE (SymHartreeFockBogolField), INTENT(IN) :: HBF
		CHARACTER(*), INTENT(IN) :: filename

		INTEGER, PARAMETER :: file_desc = 6 ! Descriptor de fichero
		INTEGER file_error

		OPEN (file_desc, FILE=TRIM(filename), ACTION="WRITE", IOSTAT=file_error)
		IF (file_error .NE. 0) RETURN
		! El primer valor almacenado en el fichero es el nmero de capas: N_0
		WRITE (file_desc, FMT="(I)", IOSTAT=file_error) N_0
		! A continuacin se almacenan rho y kap
		CALL SymHartreeFockField_write(HBF%rho, file_desc, file_error)
		CALL SymHartreeFockField_write(HBF%kap, file_desc, file_error)
		CLOSE (file_desc)
		RETURN
	END SUBROUTINE SymHartreeFockBogolField_write

	SUBROUTINE SymHartreeFockBogolField_assign(HBF1, HBF2)
		TYPE (SymHartreeFockBogolField), INTENT(INOUT) :: HBF1
		TYPE (SymHartreeFockBogolField), INTENT(IN) :: HBF2

		HBF1%rho = HBF2%rho
		HBF1%kap = HBF2%kap
		RETURN
	END SUBROUTINE SymHartreeFockBogolField_assign

	SUBROUTINE SymHartreeFockBogolField_del(HFB)
		TYPE (SymHartreeFockBogolField), INTENT(INOUT) :: HFB

		CALL SymHartreeFockField_del(HFB%rho)
		CALL SymHartreeFockField_del(HFB%kap)
		RETURN
	END SUBROUTINE SymHartreeFockBogolField_del

	SUBROUTINE SymHartreeFockField_new(HF)
		TYPE (SymHartreeFockField), INTENT(INOUT) :: HF

		INTEGER ta

		DO ta = 0, 1
			CALL SymD3Tensor_new(HF%p(ta))
			CALL SymD3Tensor_new(HF%a(ta))
		END DO
		RETURN
	END SUBROUTINE SymHartreeFockField_new

	FUNCTION SymHartreeFockField_read(HF, file_desc, file_error)
		LOGICAL SymHartreeFockField_read
		TYPE (SymHartreeFockField), INTENT(INOUT) :: HF
		INTEGER, INTENT(IN) :: file_desc
		INTEGER, INTENT(INOUT) :: file_error

		INTEGER ta, length

		DO ta = 0, 1
			IF (.NOT. SymD3Tensor_read(HF%p(ta), file_desc, file_error)) THEN
				SymHartreeFockField_read = .FALSE.
				RETURN
			END IF
			IF (.NOT. SymD3Tensor_read(HF%a(ta), file_desc, file_error)) THEN
				SymHartreeFockField_read = .FALSE.
				RETURN
			END IF
		END DO
		SymHartreeFockField_read = .TRUE.
		RETURN
	END FUNCTION SymHartreeFockField_read

	SUBROUTINE SymHartreeFockField_write(HF, file_desc, file_error)
		TYPE (SymHartreeFockField), INTENT(IN) :: HF
		INTEGER, INTENT(IN) :: file_desc
		INTEGER, INTENT(INOUT) :: file_error

		INTEGER ta

		DO ta = 0, 1
			CALL SymD3Tensor_write(HF%p(ta), file_desc, file_error)
			CALL SymD3Tensor_write(HF%a(ta), file_desc, file_error)
		END DO
		RETURN
	END SUBROUTINE SymHartreeFockField_write

	SUBROUTINE SymHartreeFockField_assign(HF_out, HF_in)
		TYPE (SymHartreeFockField), INTENT(INOUT) :: HF_out
		TYPE (SymHartreeFockField), INTENT(IN) :: HF_in

		INTEGER ta

		DO ta = 0, 1
			HF_out%p(ta) = HF_in%p(ta)
			HF_out%a(ta) = HF_in%a(ta)
		END DO
		RETURN
	END SUBROUTINE SymHartreeFockField_assign

	SUBROUTINE SymHartreeFockField_add(HF_out, HF1_in, HF2_in)
		TYPE (SymHartreeFockField), INTENT(INOUT) :: HF_out
		TYPE (SymHartreeFockField), INTENT(IN) :: HF1_in, HF2_in

		CALL SymD3Tensor_add(HF_out%p(0), HF1_in%p(0), HF2_in%p(0))
		CALL SymD3Tensor_add(HF_out%p(1), HF1_in%p(1), HF2_in%p(1))
		CALL SymD3Tensor_add(HF_out%a(0), HF1_in%a(0), HF2_in%a(0))
		CALL SymD3Tensor_add(HF_out%a(1), HF1_in%a(1), HF2_in%a(1))
		RETURN
	END SUBROUTINE SymHartreeFockField_add

	SUBROUTINE SymHartreeFockField_add_SymD3Tensor(HF_out, t_in, HF_in)
		TYPE (SymHartreeFockField), INTENT(INOUT) :: HF_out
		TYPE (SymD3Tensor), INTENT(IN) :: t_in
		TYPE (SymHartreeFockField), INTENT(IN) :: HF_in

		CALL SymD3Tensor_add(HF_out%p(0), t_in, HF_in%p(0))
		CALL SymD3Tensor_add(HF_out%p(1), t_in, HF_in%p(1))
		HF_out%a(0) = HF_in%a(0)
		HF_out%a(1) = HF_in%a(1)
		RETURN
	END SUBROUTINE SymHartreeFockField_add_SymD3Tensor

	SUBROUTINE SymHartreeFockField_product(HT_out, R1, HF_in)
		TYPE (SymHartreeFockField), INTENT(INOUT) :: HT_out
		DOUBLE PRECISION, INTENT(IN) :: R1
		TYPE (SymHartreeFockField), INTENT(IN) :: HF_in

		CALL SymD3Tensor_product(HT_out%p(0), R1, HF_in%p(0))
		CALL SymD3Tensor_product(HT_out%p(1), R1, HF_in%p(1))
		CALL SymD3Tensor_product(HT_out%a(0), R1, HF_in%a(0))
		CALL SymD3Tensor_product(HT_out%a(1), R1, HF_in%a(1))
		RETURN
	END SUBROUTINE SymHartreeFockField_product

	FUNCTION SymHartreeFockField_product2(HF1_in, HF2_in)
		DOUBLE PRECISION SymHartreeFockField_product2
		TYPE (SymHartreeFockField), INTENT(IN) :: HF1_in, HF2_in

		DOUBLE PRECISION, DIMENSION(0:1) :: sum2
		INTEGER ta

		DO ta = 0, 1
			sum2(ta) = (HF1_in%p(ta) * HF2_in%p(ta)) &
			         + (HF1_in%a(ta) * HF2_in%a(ta))
		END DO
		SymHartreeFockField_product2 = sum2(0) + sum2(1)
		RETURN
	END FUNCTION SymHartreeFockField_product2

	FUNCTION SymHartreeFockField_distance(HF1_in, HF2_in)
		DOUBLE PRECISION SymHartreeFockField_distance
		TYPE (SymHartreeFockField), INTENT(IN) :: HF1_in, HF2_in

		SymHartreeFockField_distance = MAX( &
			SymD3Tensor_distance(HF1_in%p(0), HF2_in%p(0)), &
			SymD3Tensor_distance(HF1_in%p(1), HF2_in%p(1)))
		RETURN
	END FUNCTION SymHartreeFockField_distance

!	SUBROUTINE SymHartreeFockField_inject(HF_out, HF2)
!		TYPE (SymHartreeFockField), INTENT(INOUT) :: HF_out
!		TYPE (SymHartreeFockField), INTENT(IN) :: HF2
!
!		INTEGER ta
!
!		DO ta=0, 1
!			HF_out%p(ta) = HF2%p(ta)
!			HF_out%a(ta) = HF2%a(ta)
!		END DO
!		IF (HF2%temporal) CALL SymHartreeFockField_del(HF2)
!	END SUBROUTINE SymHartreeFockField_inject

	FUNCTION SymHartreeFockField_ChargeDensity(HF, r)
		DOUBLE PRECISION SymHartreeFockField_ChargeDensity
		TYPE (SymHartreeFockField), INTENT(IN) :: HF
		DOUBLE PRECISION, INTENT(IN) :: r

		DOUBLE PRECISION x, d1, xk, sum1, sumlb
		INTEGER k, lb, nb, nd, nbmax, p2max, p2

		x = r * r
		xk = 1.0
		sum1 = 0.0
		DO k = 0, N_0
 			sumlb = 0.0
			DO lb = 0, k
				nbmax = ((N_0 - lb) / 2) + 1
				DO nb = 1, nbmax
					DO nd = 1, nbmax
						p2max = nb + nd - 2
						p2 = k - lb
						IF (p2 .GT. p2max) CYCLE
						d1 = SymCoefficientB_get(nb - 1, lb, nd - 1, lb, p2)
						sumlb = sumlb + (d1 * HF%p(PROTON)%d3tensor(lb)%d2(nd, nb))
					END DO
				END DO
			END DO
			sum1 = sum1 + (xk * sumlb)
			xk = xk * x
		END DO
		SymHartreeFockField_ChargeDensity = EXP(-x) * sum1
		RETURN
	END FUNCTION SymHartreeFockField_ChargeDensity

	SUBROUTINE SymHartreeFockField_del(HF)
		TYPE (SymHartreeFockField), INTENT(IN) :: HF

		INTEGER ta

		DO ta = 0, 1
			CALL SymD3Tensor_del(HF%p(ta))
			CALL SymD3Tensor_del(HF%a(ta))
		END DO
		RETURN
	END SUBROUTINE SymHartreeFockField_del

END MODULE symfield
MODULE symgdd

	USE input
	USE global
	USE math
	USE symtalm
	USE symfield

	IMPLICIT NONE

	TYPE SymGDDph
		DOUBLE PRECISION, DIMENSION(:, :), POINTER :: dLag
	END TYPE

CONTAINS

	SUBROUTINE SymGDDph_new(gDDph)
		TYPE (SymGDDph), INTENT(INOUT) :: gDDph

		ALLOCATE(gDDph%dLag(0:2, NLag))
		IF (.NOT. ASSOCIATED(gDDph%dLag)) STOP "Unable to allocate memory"
		RETURN
	END SUBROUTINE SymGDDph_new

	SUBROUTINE SymGDDph_update(HF_out, gDDph, HF_in)
		TYPE (SymHartreeFockField), INTENT(INOUT) :: HF_out
		TYPE (SymGDDph), INTENT(INOUT) :: gDDph
		TYPE (SymHartreeFockField), INTENT(IN) :: HF_in

		INTEGER ta, la, na, namax, nc

		CALL SymGDDph_make_DD(gDDph, HF_in)
		DO ta = 0, 1
			DO la = 0, N_0
				namax = ((N_0 - la) / 2) + 1
				DO na = 1, namax
					DO nc = 1, na
						HF_out%p(ta)%d3tensor(la)%d2(na, nc) = SymGDDph_G1dd(gDDph, na - 1, nc - 1, la, ta)
						HF_out%a(ta)%d3tensor(la)%d2(na, nc) = 0.0
					END DO
				END DO
			END DO
		END DO
		RETURN
	END SUBROUTINE SymGDDph_update

	FUNCTION SymGDDph_G1dd(gDDph, na, nc, la, ta)
		DOUBLE PRECISION SymGDDph_G1dd
		TYPE (SymGDDph), INTENT(IN) :: gDDph
		INTEGER, INTENT(IN) :: na, nc, la, ta

		DOUBLE PRECISION d1, d2, d3, d4, d5
		INTEGER p1, p1max, i
		REAL(KIND = 16) sump1, sumi

		p1max = na + nc
		sump1 = 0.0
		DO p1 = 0, p1max
			sumi = 0.0
			DO i = 1, NLag
				d1 = gDDph%dLag(    ta, i)
				d2 = gDDph%dLag(1 - ta, i)
				d3 = d1 + d2
				IF (d3 .LT. 0.0) STOP "ERROR! Fuera de rango"
				d4 = d3 ** (ALPHA - 1.0)
				d5 = (1.0 + 0.5 * x0) * d3 * d3 - (x0 + 0.5) * d1 * (d3 - ALPHA * d2)
! aLag = x/(ALPHA+2.)
!TODO			sumi =  sumi + EXP(LOG(GaussLQ%gauss%w(i)) + LOG(aLag(i)) * (p1 + la) + LOG(d3) * (ALPHA - 1) + LOG(d5))
				sumi =  sumi + EXP(LOG(GaussLQ%gauss%w(i)) &
					+ LOG(GaussLQ%gauss%x(i) / (ALPHA + 2.0)) &
					* DBLE(p1 + la) + LOG(d3) * (ALPHA - 1) + LOG(d5))
			END DO
			sump1 = sump1 + SymCoefficientB_get(na, la, nc, la, p1) * sumi
		END DO
		SymGDDph_G1dd = Gogny_t0(Gogny) * 0.5 * sump1 * I_SALPHA3
		RETURN
	END FUNCTION SymGDDph_G1dd

	SUBROUTINE SymGDDph_make_DD(gDDph, HF)
		TYPE (SymGDDph), INTENT(INOUT) :: gDDph
		TYPE (SymHartreeFockField), INTENT(IN) :: HF

		DOUBLE PRECISION d1
		DOUBLE PRECISION, DIMENSION(:, :), ALLOCATABLE :: wksp
		INTEGER s, i, lb, nb, nbmax, nd, p2, p2max
		DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE :: pows

		ALLOCATE(wksp(0:1, 0:N_0))
		ALLOCATE(pows(NLag))
		DO s = 0, N_0
			wksp(1, s) = 0.0
			wksp(0, s) = 0.0
			DO lb = 0, s
				nbmax = ((N_0 - lb) / 2) + 1
				p2 = s - lb
				DO nb = 1, nbmax
					DO nd = 1, nb
						p2max = nb + nd - 2
						IF (p2 .GT. p2max) CYCLE
						IF (nb .EQ. nd) THEN
							d1 = DBLE(      I_4PI * SymCoefficientB_get(nb - 1, lb, nd - 1, lb, p2))
						ELSE
							d1 = DBLE(2.0 * I_4PI * SymCoefficientB_get(nb - 1, lb, nd - 1, lb, p2))
						END IF
						wksp(1, s) = wksp(1, s) + (d1 * HF%p(1)%d3tensor(lb)%d2(nb, nd))
						wksp(0, s) = wksp(0, s) + (d1 * HF%p(0)%d3tensor(lb)%d2(nb, nd))
					END DO
				END DO
			END DO
		END DO

		! Inicializamos a 1 la tabla "pows" y a 0 las tablas "dLag"
		DO i = 1, NLag
			pows(i) = 1.0
			gDDph%dLag(1, i) = 0.0
			gDDph%dLag(0, i) = 0.0
		END DO
		DO s = 0, N_0
			DO i = 1, NLag
				gDDph%dLag(1, i) = gDDph%dLag(1, i) + (pows(i) * wksp(1, s))
				gDDph%dLag(0, i) = gDDph%dLag(0, i) + (pows(i) * wksp(0, s))
! aLag = x/(ALPHA+2.)
!TODO			pows(i) = pows(i) * aLag(i)
				pows(i) = pows(i) * (GaussLQ%gauss%x(i) / DBLE(ALPHA + 2.0))
			END DO
		END DO
		DEALLOCATE(wksp)
		DEALLOCATE(pows)
		RETURN
	END SUBROUTINE SymGDDph_make_DD

	FUNCTION SymGDDph_get_edd(gDDph)
		DOUBLE PRECISION SymGDDph_get_edd
		TYPE (SymGDDph), INTENT(IN) :: gDDph

		DOUBLE PRECISION sumi, d1, d2, d3
		INTEGER i

		sumi = 0.0
		DO i = 1, NLag
			d1 = gDDph%dLag(NEUTRON, i)
			d2 = gDDph%dLag(PROTON,  i)
			d3 = d1 + d2
			IF (d3 .LT. 0.0) STOP "ERROR! Fuera de rango"
			sumi = sumi + GaussLQ%gauss%w(i) * (d3 ** ALPHA) * d1 * d2
		END DO
		SymGDDph_get_edd = 3.0 * Gogny_t0(Gogny) * I_SALPHA3 * PI * sumi
		RETURN
	END FUNCTION SymGDDph_get_edd

	SUBROUTINE SymGDDph_del(gDDph)
		TYPE (SymGDDph), INTENT(INOUT) :: gDDph

		DEALLOCATE(gDDph%dLag)
		RETURN
	END SUBROUTINE SymGDDph_del

END MODULE symgdd
MODULE symgden

	USE input
	USE symd3t
	USE nucleus
	USE symfield
	USE symden
	USE symgdhf

	IMPLICIT NONE

	TYPE SymGenDensity
		TYPE (NucleusType) nucleus
		TYPE (SymGenDensityHF) rho, kap
	END TYPE

CONTAINS

	SUBROUTINE SymGenDensity_new(genden)
		TYPE (SymGenDensity), INTENT(INOUT) :: genden

		CALL SymGenDensityHF_new(genden%rho)
		CALL SymGenDensityHF_new(genden%kap)
		RETURN
	END SUBROUTINE SymGenDensity_new

	SUBROUTINE SymGenDensity_new_Nucleus(genden, N, Z)
		TYPE (SymGenDensity), INTENT(INOUT) :: genden
		INTEGER, INTENT(IN) :: N, Z

		CALL Nucleus_new(genden%nucleus, N, Z)
		CALL SymGenDensityHF_new(genden%rho)
		CALL SymGenDensityHF_new(genden%kap)
		RETURN
	END SUBROUTINE SymGenDensity_new_Nucleus

	SUBROUTINE SymGenDensity_new_SymDensity(genden, density)
		TYPE (SymGenDensity), INTENT(INOUT) :: genden
		TYPE (SymDensity), INTENT(INOUT) :: density

		INTEGER ta, la, lla
		DOUBLE PRECISION, DIMENSION(1:((N_0 / 2) + 1), 1:((N_0 / 2) + 1)) :: tmp

		CALL Nucleus_new_Nucleus(genden%nucleus, density%nucleus)
		CALL SymGenDensityHF_new(genden%rho)
		CALL SymGenDensityHF_new(genden%kap)
		DO ta = 0, 1
			DO la = 0, N_0
				lla = 2 * (2 * la + 1)

				genden%rho%rho(ta, 2 * la)%store = &
					(SymD3Tensor_matrix(density%field%rho%p(ta), la) * DBLE(2.0 * la) * &
					 SymD3Tensor_matrix(density%field%rho%a(ta), la)) / lla
				genden%kap%rho(ta, 2 * la)%store = &
					(SymD3Tensor_matrix(density%field%kap%p(ta), la) * DBLE(2.0 * la) * &
					 SymD3Tensor_matrix(density%field%kap%a(ta), la)) / lla

				IF (la .EQ. 0) CYCLE

				genden%rho%rho(ta, (2 * la) - 1)%store = &
					(SymD3Tensor_matrix(density%field%rho%p(ta), la) * DBLE(2.0 * (la + 1)) * &
					 SymD3Tensor_matrix(density%field%rho%a(ta), la)) / lla
				genden%kap%rho(ta, (2 * la) - 1)%store = &
					(SymD3Tensor_matrix(density%field%kap%p(ta), la) * DBLE(2.0 * (la + 1)) * &
					 SymD3Tensor_matrix(density%field%kap%a(ta), la)) / lla
			END DO
		END DO
		RETURN
	END SUBROUTINE SymGenDensity_new_SymDensity

	SUBROUTINE SymDensity_new_GenDensity(density, genden)
		! Recibe como parmetros de entrada el registro de densidad
		! y el nmero de protones y electrones
		TYPE (SymDensity), INTENT(INOUT) :: density
		TYPE (SymGenDensity), INTENT(IN) :: genden

		CALL Nucleus_new_Nucleus(density%nucleus, genden%nucleus)
		CALL SymHartreeFockBogolField_new(density%field)
		density%field%rho = genden%rho
		density%field%kap = genden%kap
		RETURN
	END SUBROUTINE SymDensity_new_GenDensity

	SUBROUTINE SymGenDensity_new_GammaDelta(genden, HF_gamma, HF_delta, b)
		TYPE (SymGenDensity), INTENT(INOUT) :: genden
		TYPE (SymGenDensityHF), INTENT(IN) :: HF_gamma, HF_delta
!		TYPE (SymHartreeFockField), INTENT(IN) :: HF_gamma, HF_delta
		DOUBLE PRECISION, INTENT(IN) :: b

		CALL Nucleus_new(genden%nucleus, 8, 8, b)
		CALL SymGenDensityHF_new(genden%rho)
		CALL SymGenDensityHF_new(genden%kap)
		genden%rho = HF_gamma
		genden%kap = HF_delta
!		CALL SymGenDensityHF_copy(genden%rho, HF_gamma)
!		CALL SymGenDensityHF_copy(genden%kap, HF_delta)
		RETURN
	END SUBROUTINE SymGenDensity_new_GammaDelta

	SUBROUTINE SymGenDensity_make_Block(genden, ta, a, U, V)
		TYPE (SymGenDensity), INTENT(INOUT) :: genden
		INTEGER, INTENT(IN) :: ta, a
		DOUBLE PRECISION, DIMENSION(:, :), INTENT(INOUT) :: U, V !TODO(INOUT?)

		INTEGER d, i
		DOUBLE PRECISION, DIMENSION(:, :), ALLOCATABLE :: S0, S1, S2, S3
		DOUBLE PRECISION U0, V0

		d = DIM(a)
		ALLOCATE(S0(d, d))
		ALLOCATE(S2(d, d))
		S0 = MATMUL(V, TRANSPOSE(V))
		S2 = MATMUL(V, TRANSPOSE(U))
		IF (genden%nucleus%is_blocking(ta) .AND. (a .EQ. genden%nucleus%ia(ta))) THEN
			ALLOCATE(S1(d, d))
			ALLOCATE(S3(d, d))

			DO i = 1, d
				U0 = U(i, genden%nucleus%mu0(ta)) ! Column???
				V0 = V(i, genden%nucleus%mu0(ta))
				U(i, genden%nucleus%mu0(ta)) =   V0
				V(i, genden%nucleus%mu0(ta)) = - U0
			END DO
			S1 = MATMUL(V, TRANSPOSE(V))
			S3 = MATMUL(V, TRANSPOSE(U))
			S0 = S0 + (DBLE(1.0 / (genden%nucleus%ja(ta) + 1.0)) * (S1 - S0))
			S2 = S2 + (DBLE(1.0 / (genden%nucleus%ja(ta) + 1.0)) * (S3 - S2))

			DEALLOCATE(S1)
			DEALLOCATE(S3)
		END IF
		genden%rho%rho(ta, a)%store = S0
		genden%kap%rho(ta, a)%store = S2
		DEALLOCATE(S0)
		DEALLOCATE(S2)
		RETURN
	END SUBROUTINE SymGenDensity_make_Block

	SUBROUTINE SymGenDensity_reduce(genden_out, genden_in, t_in)
		TYPE (SymGenDensity), INTENT(INOUT) :: genden_out
		TYPE (SymGenDensity), INTENT(IN) :: genden_in
		TYPE (SymD3Tensor), INTENT(IN) :: t_in

		DOUBLE PRECISION b
		TYPE (SymGenDensityHF) tmp

		b = Nucleus_get_b(genden_in%nucleus)
		CALL SymGenDensityHF_new(tmp)
		CALL SymGenDensityHF_reduce(tmp, genden_in%rho, t_in)
		CALL SymGenDensity_new_GammaDelta(genden_out, tmp, genden_in%kap, b)
		CALL SymGenDensityHF_del(tmp)
		RETURN
	END SUBROUTINE SymGenDensity_reduce

	SUBROUTINE SymGenDensity_del(genden)
		TYPE (SymGenDensity), INTENT(INOUT) :: genden

		CALL Nucleus_del(genden%nucleus)
		CALL SymGenDensityHF_del(genden%rho)
		CALL SymGenDensityHF_del(genden%kap)
		RETURN
	END SUBROUTINE SymGenDensity_del

END MODULE symgden
 MODULE symgdhf

	USE input
	USE math
	USE symd3t
	USE symfield

	IMPLICIT NONE

	TYPE MatrixType2
		DOUBLE PRECISION, DIMENSION(:, :), POINTER :: store
	END TYPE

	TYPE SymGenDensityHF
		TYPE (MatrixType2), DIMENSION(:, :), POINTER :: rho
	END TYPE

	INTERFACE ASSIGNMENT(=)
		MODULE PROCEDURE SymGenDensityHF_assign1, SymGenDensityHF_assign2
	END INTERFACE

 CONTAINS

	SUBROUTINE SymGenDensityHF_new(gendenhf)
		TYPE (SymGenDensityHF), INTENT(INOUT) :: gendenhf

		INTEGER ta, a, d

		ALLOCATE(gendenhf%rho(0:1, 0:(2 * N_0)))
		DO ta = 0, 1
			DO a = 0, 2 * N_0
				d = DIM(a)
				ALLOCATE(gendenhf%rho(ta, a)%store(d, d))
			END DO
		END DO
		RETURN
	END SUBROUTINE SymGenDensityHF_new

	SUBROUTINE SymGenDensityHF_copy(gendenhf, HF)
		TYPE (SymGenDensityHF), INTENT(INOUT) :: gendenhf
		TYPE (SymHartreeFockField), INTENT(IN) :: HF

		INTEGER ta, a, la, d

		INTEGER u1, u2
		DOUBLE PRECISION, DIMENSION(:, :), ALLOCATABLE :: HF_p, HF_a

		DO ta = 0, 1
			DO a = 0, 2 * N_0
				la = L(a)
				d = DIM(a)

				ALLOCATE(HF_p(d, d), HF_a(d, d))

				HF_p = 0.0
				HF_a = 0.0
				DO u1 = 1, d
					DO u2 = 1, u1
						HF_p(u1, u2) = HF%p(ta)%d3tensor(la)%d2(u1, u2)
						HF_a(u1, u2) = HF%a(ta)%d3tensor(la)%d2(u1, u2)
						IF (u1 .NE. u2) THEN
							HF_p(u2, u1) = HF%p(ta)%d3tensor(la)%d2(u1, u2)
							HF_a(u2, u1) = HF%a(ta)%d3tensor(la)%d2(u1, u2)
						END IF
					END DO
				END DO
				gendenhf%rho(ta, a)%store = HF_p + (LS(a) * HF_a)

				DEALLOCATE(HF_p, HF_a)
			END DO
		END DO
		RETURN
	END SUBROUTINE SymGenDensityHF_copy

	SUBROUTINE SymGenDensityHF_assign1(gendenhf_out, gendenhf_in)
		TYPE (SymGenDensityHF), INTENT(INOUT) :: gendenhf_out
		TYPE (SymGenDensityHF), INTENT(IN) :: gendenhf_in

		INTEGER ta, a

		DO ta = 0, 1
			DO a = 0, 2 * N_0
				gendenhf_out%rho(ta, a)%store = gendenhf_in%rho(ta, a)%store
			END DO
		END DO
		RETURN
	END SUBROUTINE SymGenDensityHF_assign1

	SUBROUTINE SymGenDensityHF_assign2(HF, gendenhf)
		TYPE (SymHartreeFockField), INTENT(INOUT) :: HF
		TYPE (SymGenDensityHF), INTENT(IN) :: gendenhf

		INTEGER ta, la, d
		DOUBLE PRECISION, DIMENSION(:, :), ALLOCATABLE :: m

		DO ta = 0, 1
			DO la = 0, N_0
				d = DIM(2 * la)
				ALLOCATE(m(d, d))

				m = DBLE(2.0 * (la + 1)) * gendenhf%rho(ta, 2 * la)%store
				IF (la .NE. 0) THEN
					m = m + (DBLE(2.0 * la) * gendenhf%rho(ta, (2 * la) - 1)%store)
				END IF

				CALL SymD3Tensor_assign_Matrix(HF%p(ta), la, m)

				m = gendenhf%rho(ta, 2 * la)%store
				IF (la .NE. 0) THEN
					m = m - gendenhf%rho(ta, (2 * la) - 1)%store
				END IF

				CALL SymD3Tensor_assign_Matrix(HF%a(ta), la, m)

				DEALLOCATE(m)
			END DO
		END DO
		RETURN
	END SUBROUTINE SymGenDensityHF_assign2

	SUBROUTINE SymGenDensityHF_reduce(gendenhf_out, gendenhf_in, t_in)
		TYPE (SymGenDensityHF), INTENT(INOUT) :: gendenhf_out
		TYPE (SymGenDensityHF), INTENT(IN) :: gendenhf_in
		TYPE (SymD3Tensor), INTENT(IN) :: t_in

		INTEGER ta, a, d, la
!		DOUBLE PRECISION, DIMENSION(:, :), ALLOCATABLE :: S1, S2

		DO ta = 0, 1
			DO a = 0, 2 * N_0
				d = DIM(a)
				la = L(a)
!				ALLOCATE(S1(d, d))
!				ALLOCATE(S2(d, d))
!				S1 = gendenhf_in%rho(ta, a)%store
!				S2 = t_in%d3tensor(la)%d2
!				SymGenDensityHF_assign(gendenhf_out, ta, a, S1 - S2)
!				DEALLOCATE(S1)
!				DEALLOCATE(S2)
				gendenhf_out%rho(ta, a)%store = gendenhf_in%rho(ta, a)%store - t_in%d3tensor(la)%d2
			END DO
		END DO
		RETURN
	END SUBROUTINE SymGenDensityHF_reduce

	SUBROUTINE SymGenDensityHF_print(gendenhf)
		TYPE (SymGenDensityHF), INTENT(IN) :: gendenhf

		INTEGER ta, a, d, u1, u2

		DO ta = 0, 1
			DO a = 0, 2 * N_0
!TODO				PRINT "()"
				d = DIM(a)
				DO u1 = 1, d
					PRINT "(24F10.3)", (gendenhf%rho(ta, a)%store(u1, u2), u2 = 1, d)
				END DO
			END DO
		END DO
		RETURN
	END SUBROUTINE SymGenDensityHF_print

	SUBROUTINE SymGenDensityHF_del(gendenhf)
		TYPE (SymGenDensityHF), INTENT(INOUT) :: gendenhf

		INTEGER ta, a

		DO ta = 0, 1
			DO a = 0, 2 * N_0
				DEALLOCATE(gendenhf%rho(ta, a)%store)
			END DO
		END DO
		DEALLOCATE(gendenhf%rho)
		RETURN
	END SUBROUTINE SymGenDensityHF_del

END MODULE symgdhf
!------------------------------------------------------------------!
!								   !
!  CALCULATION OF THE KINETIC ENERGY TERM OF THE GOGNY FORCE       !
!								   !
!------------------------------------------------------------------!

 MODULE symke2b

	USE input
	USE global
	USE symd3t
	USE symfield

	IMPLICIT NONE

	TYPE SymKineticEnergy2Body
		TYPE (SymD3Tensor_SymD3Tensor) v11, v22
		!CHARACTER(64) filename
	END TYPE

	PRIVATE SymKineticEnergy2Body_nablaHO
	PRIVATE SymKineticEnergy2Body_nabla

 CONTAINS

	SUBROUTINE SymKineticEnergy2Body_new(vEkCMph)
		TYPE (SymKineticEnergy2Body), INTENT(INOUT) :: vEkCMph

		INTEGER la, lla, na, namax, nc, lb, llb, nb, nbmax, nd
		INTEGER IndexBraOne, IndexKetOne, IndexBraTwo, IndexKetTwo
		DOUBLE PRECISION cuad, d1
		CHARACTER(64) filename

		INTEGER, PARAMETER :: file_desc = 6
		INTEGER file_error

		!  Create and initializes the tensors
		
		CALL SymD3Tensor_SymD3Tensor_new(vEkCMph%v11)
		CALL SymD3Tensor_SymD3Tensor_new(vEkCMph%v22)

                SELECT CASE (Basis)
		
		CASE (1)
         
			IF (N_0 < 10) THEN
				WRITE(filename, "(A,I1,A)") "data/vEkCM", N_0, "ph_HO.txt"
			ELSE
				WRITE(filename, "(A,I2,A)") "data/vEkCM", N_0, "ph_HO.txt"
			END IF

		CASE (2)
		
			IF (N_0 < 10) THEN
				WRITE(filename, "(A,I1,A)") "data/vEkCM", N_0, "ph_WS.txt"
			ELSE
				WRITE(filename, "(A,I2,A)") "data/vEkCM", N_0, "ph_WS.txt"
			END IF

		END SELECT
         
		IF (N_0 .LE. 16) THEN
			OPEN(file_desc, FILE=filename, ACTION="WRITE", IOSTAT=file_error)
			IF (file_error .NE. 0) THEN
				PRINT *, "*** Attention: Impossible to write the results in ", filename
			END IF
		END IF

        	!---------------------------------------------------------------------------------------!
                !											!
		!  Sum over na, nb, nc, nd and la, lb to calculate the matrix elements of the type:	!
                !											!
		!                   < na la, nb lb | T | nd lb, nc la >					!
                !											!
		!  where T is the kinetic energy. Since T is a one-body operator, this can actually	!
		!  be separated into:									!
		!                        < na la | T | nd lb >< nb lb | T | nc la >			!
		!											!
		!  WARNING: FOR L, THE SUMMATION IS NOT DONE UP TO A GIVEN L_MAX, BUT OVER N_0		!
		!           FOR N, N_MAX IS EXPRESSED AS FUNCTION OF N_0 TOO				!
                !											!
        	!---------------------------------------------------------------------------------------!

                SELECT CASE (Basis)
		
		CASE (1)
         
		      DO la = 0, N_0
		
			 lla = (2 * la) + 1 ! Degeneracy of a shell with l_a
			 namax = ((N_0 - la) / 2) + 1 ! Maximum n value for the "bra"
			
			 DO na = 1, namax
			    DO nc = 1, na
!TODO			DO nc = 1, namax
! Debe haber sido un error del autor, puesto que estamos trabajando con
! matrices simetricas. Nota: el operador "()" corrige el error

			        DO lb = 0, la
					
				   llb = (2 * lb) + 1 ! Degeneracy of a shell with l_b
				   nbmax = ((N_0 - lb) / 2) + 1 ! Maximum n value for the "ket"
						
				   cuad = CUAD2(la, lb, 1) ! Defined in Module math.f90
						
				   DO nb = 1, nbmax
				      DO nd = 1, nb
							
					  ! Product: < na la || NABLA || nd la >< nb lb || NABLA || nc lb >
							
					  d1 = SymKineticEnergy2Body_nablaHO(na - 1, la, nd - 1, lb) * &
					       SymKineticEnergy2Body_nablaHO(nb - 1, lb, nc - 1, la)
								     
					  ! Anti-symmetrization of the matrix elements by permutation:
					  !          < na la || NABLA || nb la >< nd lb || NABLA || nc lb >
							
					  IF (nb .NE. nd) THEN
					      d1 = d1 + (SymKineticEnergy2Body_nablaHO(na - 1, la, nb - 1, lb) * &
							 SymKineticEnergy2Body_nablaHO(nd - 1, lb, nc - 1, la))
					      d1 = d1 / 2.0
					  END IF
								
					  ! Application of the Wigner-Eckart theorem and multiplication by the mass factor
					  ! to get the proper energy
							
					  !d1 = d1 / (m(1) * DBLE(lla * llb)) / b_0**4
					  d1 = d1 / (m(1) * DBLE(lla * llb))

					  ! Filling in the required pointers
							
					  CALL SymD3Tensor_SymD3Tensor_assign(vEkCMph%v11, la, na, nc, lb, nb, nd, 0.5 * d1)
					  CALL SymD3Tensor_SymD3Tensor_assign(vEkCMph%v11, lb, nb, nd, la, na, nc, 0.5 * d1)
					  CALL SymD3Tensor_SymD3Tensor_assign(vEkCMph%v22, la, na, nc, lb, nb, nd, cuad * d1)
					  CALL SymD3Tensor_SymD3Tensor_assign(vEkCMph%v22, lb, nb, nd, la, na, nc, cuad * d1)

					  ! Writing the results on disk
							
					  IF ((N_0 .LE. 16) .AND. (file_error .EQ. 0)) THEN
					       WRITE (file_desc, "(I3,I3,I3,I3,I3,I3,E,E)", IOSTAT=file_error) &
								   la, na, nc, lb, nb, nd, 0.5 * d1, cuad * d1
					  END IF
								
				      END DO
				   END DO
						
				END DO
					
			    END DO
			 END DO
			
		      END DO

		CASE (2)
		
		     ! To begin with something, we set N0 (fake number of shells) to the maximum L-value of the neutrons
		     !N_0 = LmaxiIso(NEUTRON)
		     write(0,'("In Kinetic - N_0 = ",I4)') N_0
		
		      DO la = 0, N_0
		
			 lla = (2 * la) + 1 ! Degeneracy of a shell with l_a
			 namax = ((N_0 - la) / 2) + 1 ! Maximum n value for the "bra"
			
			 DO na = 1, namax
			    DO nc = 1, na

			        DO lb = 0, la
					
				   llb = (2 * lb) + 1 ! Degeneracy of a shell with l_b
				   nbmax = ((N_0 - lb) / 2) + 1 ! Maximum n value for the "ket"
						
				   cuad = CUAD2(la, lb, 1) ! Defined in Module math.f90
						
				   DO nb = 1, nbmax
				      DO nd = 1, nb
							
					  ! Product: < na la || NABLA || nd la >< nb lb || NABLA || nc lb >
					  
					  d1 = SymKineticEnergy2Body_nabla(na, la, nd, lb) * &
					       SymKineticEnergy2Body_nabla(nb, lb, nc, la)
					       
					  ! Anti-symmetrization of the matrix elements by permutation:
					  !          < na la || NABLA || nb la >< nd lb || NABLA || nc lb >
							
					  IF (nb .NE. nd) THEN
					      d1 = d1 + (SymKineticEnergy2Body_nabla(na, la, nb, lb) * &
							 SymKineticEnergy2Body_nabla(nd, lb, nc, la))
					      d1 = d1 / 2.0
					  END IF
								
					  ! Application of the Wigner-Eckart theorem and multiplication by the mass factor
					  ! to get the proper energy
							
					  d1 = d1 / (m(1) * DBLE(lla * llb))

					  ! Filling in the required pointers
							
					  CALL SymD3Tensor_SymD3Tensor_assign(vEkCMph%v11, la, na, nc, lb, nb, nd, 0.5 * d1)
					  CALL SymD3Tensor_SymD3Tensor_assign(vEkCMph%v11, lb, nb, nd, la, na, nc, 0.5 * d1)
					  CALL SymD3Tensor_SymD3Tensor_assign(vEkCMph%v22, la, na, nc, lb, nb, nd, cuad * d1)
					  CALL SymD3Tensor_SymD3Tensor_assign(vEkCMph%v22, lb, nb, nd, la, na, nc, cuad * d1)

					  ! Writing the results on disk
							
					  IF ((N_0 .LE. 16) .AND. (file_error .EQ. 0)) THEN
					       WRITE (file_desc, "(I3,I3,I3,I3,I3,I3,E,E)", IOSTAT=file_error) &
								   la, na, nc, lb, nb, nd, 0.5 * d1, cuad * d1
					  END IF
								
				      END DO
				   END DO
						
				END DO
					
			    END DO
			 END DO
			
		      END DO
		
				      
		END SELECT
		
		CLOSE(file_desc)
		RETURN
		
	END SUBROUTINE SymKineticEnergy2Body_new

        !---------------------------------------------------------------------------------!
	!		                       		  			          !
	! Function giving the reduced matrix elements < n_a, l_a || NABLA || n_b, l_b >   !
	! for the special case of the harmonic oscillator basis                           !
	!		                       		  			          !
	! BEWARE: Here the HO length b is implicitely assumed equal to 1, otherwise,	  !
	!         there should be a factor 1/b						  !
	!		                       		  			          !
	! Refs: Appendix C, Page 115, Appendix D, Page 127, D24				  !
	!		                       		  			          !
        !---------------------------------------------------------------------------------!

	FUNCTION SymKineticEnergy2Body_nablaHO(na, la, nb, lb)
		DOUBLE PRECISION SymKineticEnergy2Body_nablaHO
		INTEGER, INTENT(IN) :: na, la, nb, lb

		IF (la .EQ. (lb + 1)) THEN
			IF (nb .EQ. (na + 1)) THEN
				SymKineticEnergy2Body_nablaHO = - sq(la) * sq(nb)
			ELSE IF (nb .EQ. na) THEN
				SymKineticEnergy2Body_nablaHO = - sq(la) * sq2(na + la)
			ELSE
				SymKineticEnergy2Body_nablaHO = 0.0
			END IF
		ELSE IF (lb .EQ. (la + 1)) THEN
			IF (na .EQ. (nb + 1)) THEN
				SymKineticEnergy2Body_nablaHO = - sq(lb) * sq(na)
			ELSE IF (na .EQ. nb) THEN
				SymKineticEnergy2Body_nablaHO = - sq(lb) * sq2(nb + lb)
			ELSE
				SymKineticEnergy2Body_nablaHO = 0.0
			END IF
		ELSE
			SymKineticEnergy2Body_nablaHO = 0.0
		END IF
		
		RETURN
	END FUNCTION SymKineticEnergy2Body_nablaHO

        !---------------------------------------------------------------------------------!
	!		                       		  			          !
	! Function giving the reduced matrix elements < na la || NABLA || nb lb > 	  !
	! for an arbitrary spherical basis (not necessarily the Harmonic Oscillator)      !
	!		                       		  			          !
        !---------------------------------------------------------------------------------!

	FUNCTION SymKineticEnergy2Body_nabla(na, la, nb, lb)
		DOUBLE PRECISION SymKineticEnergy2Body_nabla
		INTEGER, INTENT(IN) :: na, nb, la, lb
		INTEGER :: IndexBra, IndexKet

		IndexBra = IndexVecNL(na,la)
		IndexKet = IndexVecNL(nb,lb)
							
		IF (IndexBra .EQ. 0 .OR. IndexKet .EQ. 0) THEN
		    SymKineticEnergy2Body_nabla = 0.0
		    RETURN
		END IF
		
		IF (la .EQ. (lb + 1)) THEN
		    SymKineticEnergy2Body_nabla = + IntegralA(IndexBra, IndexKet, lb)*sq(la)/b_0
		ELSE IF (lb .EQ. (la + 1)) THEN
		    SymKineticEnergy2Body_nabla = - IntegralB(IndexBra, IndexKet, lb)*sq(lb)/b_0
		ELSE
		    SymKineticEnergy2Body_nabla = 0.0
		END IF
		
		RETURN
	END FUNCTION SymKineticEnergy2Body_nabla

        !---------------------------------------------------------!
	!		                       		          !
	! Function giving the A-integral of Notes, Sec. 3.2.3     !
	!		                       		  	  !
        !---------------------------------------------------------!

	FUNCTION IntegralA(IndexBra, IndexKet, lb)
		DOUBLE PRECISION :: IntegralA, Result
		DOUBLE PRECISION, ALLOCATABLE :: Integrand(:)
		INTEGER, INTENT(IN) :: IndexBra, IndexKet, lb
		INTEGER :: Ipoint
	
	        ALLOCATE(Integrand(0:Npoint))
		
		Integrand(0) = 0.0		
		DO Ipoint = 1, Npoint
		   Integrand(Ipoint) = WaveFun(Ipoint,IndexBra,Isospin)*WaveDeri(Ipoint,IndexKet,Isospin) - &
		           (lb + 1.0)* WaveFun(Ipoint,IndexBra,Isospin)*WaveFun(Ipoint,IndexKet,Isospin)/RadMesh(Ipoint)
		END DO
		
		CALL simps(Integrand,Npoint+1,MeshStep,Result)
		
		DEALLOCATE(Integrand)
		
		IntegralA = Result
		
		RETURN
	END FUNCTION IntegralA

        !---------------------------------------------------------!
	!		                       		          !
	! Function giving the B-integral of Notes, Sec. 3.2.3     !
	!		                       		  	  !
        !---------------------------------------------------------!

	FUNCTION IntegralB(IndexBra, IndexKet, lb)
		DOUBLE PRECISION :: IntegralB, Result
		DOUBLE PRECISION, ALLOCATABLE :: Integrand(:)
		INTEGER, INTENT(IN) :: IndexBra, IndexKet, lb
		INTEGER :: Ipoint
	
	        ALLOCATE(Integrand(0:Npoint))
		
		Integrand(0) = 0.0
		DO Ipoint = 1, Npoint
		   Integrand(Ipoint) = WaveFun(Ipoint,IndexBra,Isospin)*WaveDeri(Ipoint,IndexKet,Isospin) + &
		                   lb* WaveFun(Ipoint,IndexBra,Isospin)*WaveFun(Ipoint,IndexKet,Isospin)/RadMesh(Ipoint)
		END DO
		
		CALL simps(Integrand,Npoint+1,MeshStep,Result)
		
		DEALLOCATE(Integrand)
		
		IntegralB = Result
		
		RETURN
	END FUNCTION IntegralB

         !
	 ! STILL UNDEFINED FOR THE MOMENT 
	 !

	SUBROUTINE SymKineticEnergy2Body_product(HF_out, vEkCMph, HF_in)
		TYPE (SymHartreeFockField), INTENT(INOUT) :: HF_out
		TYPE (SymKineticEnergy2Body), INTENT(IN) :: vEkCMph
		TYPE (SymHartreeFockField), INTENT(IN) :: HF_in

		CALL SymKineticEnergy2Body_get_Gamma(HF_out, vEkCMph, HF_in)
		RETURN
	END SUBROUTINE SymKineticEnergy2Body_product

	SUBROUTINE SymKineticEnergy2Body_get_Gamma(HF_out, vEkCMph, HF_in)
		TYPE (SymHartreeFockField), INTENT(INOUT) :: HF_out
		TYPE (SymKineticEnergy2Body), INTENT(IN) :: vEkCMph
		TYPE (SymHartreeFockField), INTENT(IN) :: HF_in

		CALL SymD3Tensor_SymD3Tensor_product(HF_out%p(0), vEkCMph%v11, HF_in%p(0))
		CALL SymD3Tensor_SymD3Tensor_product(HF_out%p(1), vEkCMph%v11, HF_in%p(1))
		CALL SymD3Tensor_SymD3Tensor_product(HF_out%a(0), vEkCMph%v22, HF_in%a(0))
		CALL SymD3Tensor_SymD3Tensor_product(HF_out%a(1), vEkCMph%v22, HF_in%a(1))
		RETURN
	END SUBROUTINE SymKineticEnergy2Body_get_Gamma

	SUBROUTINE SymKineticEnergy2Body_del(vEkCMph)
		TYPE (SymKineticEnergy2Body), INTENT(INOUT) :: vEkCMph

		CALL SymD3Tensor_SymD3Tensor_del(vEkCMph%v11)
		CALL SymD3Tensor_SymD3Tensor_del(vEkCMph%v22)
		
		RETURN
	END SUBROUTINE SymKineticEnergy2Body_del

END MODULE symke2b
! TALMAN

MODULE symtalm

	USE input
	USE lgfactor
	USE math

	IMPLICIT NONE

	TYPE SymCoefficientB5
		REAL(KIND = 16), DIMENSION(:), POINTER :: p
	END TYPE

	TYPE SymCoefficientB4
		TYPE (SymCoefficientB5), DIMENSION(:), POINTER :: l2
	END TYPE

	TYPE SymCoefficientB3
		TYPE (SymCoefficientB4), DIMENSION(:), POINTER :: n2
	END TYPE

	TYPE SymCoefficientB2
		TYPE (SymCoefficientB3), DIMENSION(:), POINTER :: l1
	END TYPE

	TYPE SymCoefficientB
		TYPE (SymCoefficientB2), DIMENSION(:), POINTER :: n1
	END TYPE

	TYPE (SymCoefficientB) CoeB

	TYPE SymKumar6
		REAL(KIND = 16), DIMENSION(:), POINTER :: L
	END TYPE

	TYPE SymKumar5
		TYPE (SymKumar6), DIMENSION(:), POINTER :: N
	END TYPE

	TYPE SymKumar4
		TYPE (SymKumar5), DIMENSION(:), POINTER :: l2
	END TYPE

	TYPE SymKumar3
		TYPE (SymKumar4), DIMENSION(:), POINTER :: n2
	END TYPE

	TYPE SymKumar2
		TYPE (SymKumar3), DIMENSION(:), POINTER :: l1
	END TYPE

	TYPE SymKumar
		TYPE (SymKumar2), DIMENSION(:), POINTER :: n1
	END TYPE

	TYPE (SymKumar) Kumar

	DOUBLE PRECISION, PARAMETER :: PI_B = 124.0251067211992807 !  = 4pi

 CONTAINS

	! ATENCION: Este modulo ha de reprogramarse al final del desarrollo
	! En dicho momento, se comprobara cuales son las llamadas mas solicitadas
	! para la evaluacion de "CoefficientB" y "Kumar", preparando asi
	! un registro automatico de las solicitudes con el fin de optimizar
	! el calculo
	
	!
	!  This subroutine creates and allocates memory for the object of the type SymCoefficientB
	!  which corresponds to the integral B(n1, l1, b1; n2, l2, b2; p, b) whose definition can
	!  be found in the Scary PhD, Appendix D2, page 118, D8.
	! 
	SUBROUTINE SymCoefficientB_new

		INTEGER la, na, namax, lc, nc, ncmax, p, pmax

		ALLOCATE(CoeB%n1(0:N_0))
		DO la = 0, N_0
			namax = (N_0 - la) / 2
			ALLOCATE(CoeB%n1(la)%l1(0:namax))
			DO na = 0, namax
				ALLOCATE(CoeB%n1(la)%l1(na)%n2(0:la))
				DO lc = 0, la
					ncmax = (N_0 - lc) / 2
					ALLOCATE(CoeB%n1(la)%l1(na)%n2(lc)%l2(0:ncmax))
					DO nc = 0, ncmax
						pmax = na + nc
						ALLOCATE(CoeB%n1(la)%l1(na)%n2(lc)%l2(nc)%p(0:pmax))
						DO p = 0, pmax
							CoeB%n1(la)%l1(na)%n2(lc)%l2(nc)%p(p) = 0.0
						END DO
					END DO
				END DO
			END DO
		END DO
		RETURN
	END SUBROUTINE SymCoefficientB_new

	!-------------------------------------------------------------------------------------!
	!										      !
	!  This function is used to evaluate the integral B(n1, l1, b1; n2, l2, b2; p, b).    !
	!  Here, b = b1 = b2 is assumed for some reason and the resulting coefficient is      !
	!  multiplied by the normalization coefficients of the wave-functions c(n1,l1) x      !
	!  c(n2,l2).				   					      !
	!                                                         FORMULA CHECKED AND OK      !
	!										      !
	!  Inputs.  n1, l1, n2, l2, p							      !
	!										      !
	!  Output:  B(n1,l1,n2,l2,p) * c(n1,l1)c(n2,l2)					      !
	!										      !
	!  Ref.: Appendix D2, page 118, D8						      !
	!										      !
	!-------------------------------------------------------------------------------------!
	
	FUNCTION SymCoefficientB_eval(n1, l1, n2, l2, p)
		REAL(KIND = 16) SymCoefficientB_eval
		INTEGER, INTENT(IN) :: n1, l1, n2, l2, p

		INTEGER k, kmin, kmax
		REAL(KIND = 16) sumk

		kmin = MAX(p - n2, 0)
		kmax = MIN(p, n1)

		sumk = 0.0
		DO k = kmin, kmax
			sumk = sumk + EXP(- DDLogFactorials(k) - DDLogFactorials(n1 - k) &
				          - DDLogSemiFactorials(k + l1) - DDLogFactorials(p - k) &
				          - DDLogFactorials(n2 + k - p) - DDLogSemiFactorials(p + l2 - k))
		END DO
		
		SymCoefficientB_eval = PI_B * PAR(p + n1 + n2) * sumk * c(n1, l1) * c(n2, l2)
		
		RETURN
	END FUNCTION SymCoefficientB_eval

	!-------------------------------------------------------------------------------------!
	!										      !
	!  This function is used to:							      !
	!    1) fill in the typed object with the result of the evaluation		      !
	!    2) access the content of the typed object					      !
	!  										      !
	!  Inputs.  na, la, nb, lb, p							      !
	!										      !
	!  Output:  B(n1,l1,n2,l2,p) * c(n1,l1)c(n2,l2)					      !
	!										      !
	!  Ref.: Appendix D2, page 118, D8						      !
	!										      !
	!-------------------------------------------------------------------------------------!
	
	FUNCTION SymCoefficientB_get(na, la, nb, lb, p)
		REAL(KIND = 16) SymCoefficientB_get
		INTEGER, INTENT(IN) :: na, la, nb, lb, p

		INTEGER n1, l1, n2, l2

		IF (lb .GT. la) THEN
			n1 = nb
			l1 = lb
			n2 = na
			l2 = la
		ELSE
			n1 = na
			l1 = la
			n2 = nb
			l2 = lb
		END IF

		! Comprobamos si los parametros se salen del rango de valores registrados
		IF ((((2 * n1) + l1) .GT. N_0) .OR. (((2 * n2) + l2) .GT. N_0)) THEN
			! Si los parametros estan fuera de rango, calculamos el valor
			SymCoefficientB_get = SymCoefficientB_eval(n1, l1, n2, l2, p)
		ELSE
			! Si los parametros estan dentro del rango almacenado,
			! comprobamos si el valor ha sido previamente calculado
			IF (CoeB%n1(l1)%l1(n1)%n2(l2)%l2(n2)%p(p) .EQ. 0.0) THEN
				CoeB%n1(l1)%l1(n1)%n2(l2)%l2(n2)%p(p) = SymCoefficientB_eval(n1, l1, n2, l2, p)
			END IF
			SymCoefficientB_get = CoeB%n1(l1)%l1(n1)%n2(l2)%l2(n2)%p(p)
		END IF
		RETURN
	END FUNCTION SymCoefficientB_get

	!
	!  This subroutine creates an object of the type SymKumar, which definition can be found 
	!  at the top of this module: it is a pointer to a pointer.... to a pointer equivalent to
	!  a 6D array with indexes referring to the quantum numbers n1, l1, n2, l2, N, L.
	!  This subroutine allocates the memory for the newly-created object
	!
	SUBROUTINE SymKumar_new

		INTEGER la, na, lc, nc, k
		INTEGER namax, ncmax, kmin, kmax, N1min, N1max, N1
		INTEGER Na2, Nc2
		INTEGER i2, i6, i7

		ALLOCATE(Kumar%n1(0:N_0))
		DO la = 0, N_0
			namax = (N_0 - la) / 2
			ALLOCATE(Kumar%n1(la)%l1(0:namax))
			DO na = 0, namax
				ALLOCATE(Kumar%n1(la)%l1(na)%n2(0:la))
				Na2 = (2 * na) + la
				DO lc = 0, la
					ncmax = (N_0 - lc) / 2
					ALLOCATE(Kumar%n1(la)%l1(na)%n2(lc)%l2(0:ncmax))
					kmin = ABS(la - lc)
					kmax = la + lc
					i2 = ((kmax - kmin) / 2) ! + 1
					DO nc = 0, ncmax
						Nc2 = 2 * nc + lc
						ALLOCATE(Kumar%n1(la)%l1(na)%n2(lc)%l2(nc)%N(0:i2))
						DO k = kmin, kmax, +2
							N1min = MIN_3N(Na2, Nc2, k)
							N1max = na + nc + ((la + lc - k) / 2)
							i6 = (k - kmin) / 2
							i7 = N1max - N1min ! + 1 ! Ojo!
							ALLOCATE(Kumar%n1(la)%l1(na)%n2(lc)%l2(nc)%N(i6)%L(0:i7))
							DO N1 = N1min, N1max
								Kumar%n1(la)%l1(na)%n2(lc)%l2(nc)%N(i6)%L(N1 - N1min) = 0.0
							END DO
						END DO
					END DO
				END DO
			END DO
		END DO
		RETURN
	END SUBROUTINE SymKumar_new

	! ojo: es c(N,L) * Kumar(n1,l1,n2,l2,N,L)
	
	!
	!  This function evaluates the so-called Kumar coefficient times the coefficient C(N,L).
	!  Definitions can be found in the Horrible PhD, Appendix F, Page 142.
	!                                                         !!! FORMULA not CHECKED !!!
	!  
	!  Inputs.  n1, l1, n2, l2, N, L
	!
	!  Output:  c(N,L) * TK(n1,l1,n2,l2,N,L)
	!
	!  Ref.: Appendix F, page 142
	!
	FUNCTION SymKumar_eval(n1, l1, n2, l2, N, L)
		REAL(KIND = 16) SymKumar_eval
		INTEGER, INTENT(IN) :: n1, l1, n2, l2, N, L

		INTEGER i1, i2, p, pmin, pmax
		REAL(KIND = 16) sump

		i1 = (l1 + l2 + L) / 2
		i2 = (l1 + l2 - L) / 2
          
		pmin = MAX(N - i2, 0)
		pmax = n1 + n2 ! Upper limit of the summation

		sump = SymCoefficientB_get(n1, l1, n2, l2, pmax)
		
		DO p = pmax - 1, pmin, -1
			sump = SymCoefficientB_get(n1, l1, n2, l2, p) &
				+ ((sump * (p + i1 + 1.5) * (p + i2 + 1.0)) / (p + i2 + 1.0 - N))
		END DO

                                !  1/ 2PI^(3/4)
		SymKumar_eval = 0.2118886040618787984 * EXP(DDLogSemiFactorials(i1 + pmin) + DDLogFactorials(i2 + pmin)) * sump
		
		IF ((i2 - N) .GT. 0) THEN
			SymKumar_eval = SymKumar_eval / EXP(DDLogFactorials(i2 - N))
		END IF
		
		RETURN
	END FUNCTION SymKumar_eval

	! Atencion: es c(N,L) * Kumar(n1, l1, n2, l2, N, L)
	
	!
	!  This function is used to:
	!    1) fill in the typed object Kumar with the result of the evaluation
	!    2) access the content of the typed object
	!  	
	!  Inputs.  na, la, nb, lb, N, L
	!
	!  Output:  c(N,L) * TK(na,la,nb,lb,N,L)
	!
	!  Ref.: Appendix F, page 142
	! 
	FUNCTION SymKumar_get(na, la, nb, lb, N, L)
		REAL(KIND = 16) SymKumar_get
		INTEGER, INTENT(IN) :: na, la, nb, lb, N, L

		INTEGER n1, l1, n2, l2
		INTEGER M1, M2
		INTEGER i2, i8, i9, Lmin, Lmax, Nmin, Nmax

		M1 = (na * 2) + la
		M2 = (nb * 2) + lb

		! Formula antigua
		i2 = (la + lb - L) / 2
		Lmin = ABS(la - lb)
		Lmax = la + lb
		i8 = (L - Lmin) / 2

		Nmax = na + nb + i2
		Nmin = MIN_3N(M1, M2, L)
		i9 = N - Nmin

		IF ((M1 .GT. N_0) .OR. (M2 .GT. N_0)) THEN
			SymKumar_get = SymKumar_eval(na, la, nb, lb, N, L)
			RETURN
		END IF

		IF ((L .LT. Lmin) .OR. (L .GT. Lmax) .OR. &
		    (N .LT. Nmin) .OR. (N .GT. Nmax)) THEN
			SymKumar_get = 0.0
			RETURN
		END IF

		IF (lb .GT. la) THEN
			n1 = nb
			l1 = lb
			n2 = na
			l2 = la
		ELSE
			n1 = na
			l1 = la
			n2 = nb
			l2 = lb
		END IF

		IF (Kumar%n1(l1)%l1(n1)%n2(l2)%l2(n2)%N(i8)%L(i9) .EQ. 0.0) THEN
			Kumar%n1(l1)%l1(n1)%n2(l2)%l2(n2)%N(i8)%L(i9) = SymKumar_eval(n1, l1, n2, l2, N, L)
		END IF
		
		SymKumar_get = Kumar%n1(l1)%l1(n1)%n2(l2)%l2(n2)%N(i8)%L(i9)
		
		RETURN
	END FUNCTION SymKumar_get

END MODULE symtalm
!----------------------------------------------------------------!
!								 !
!  CALCULATION OF THE BRINK-BOEKER TERM OF THE GOGNY FORCE       !
!								 !
!----------------------------------------------------------------!

 MODULE symvbb

	USE input
	USE angmom
	USE symd3t
	USE symfield
	USE ibb

	IMPLICIT NONE

	TYPE SymVBBph
		DOUBLE PRECISION b1
		TYPE (SymD3Tensor_SymD3Tensor) &
			v_local_same_part, v_local_diff_part, &
			v1_exch_same_part, v1_exch_diff_part, &
			v2_exch_same_part, v2_exch_diff_part
		TYPE (SymD3Tensor_SymD3Tensor) &
			v1_same_part, v1_diff_part, &
			v2_same_part, v2_diff_part
		CHARACTER(LEN = 64) filename
	END TYPE

	TYPE SymVBBpp
		DOUBLE PRECISION b1
		TYPE (SymD3Tensor_SymD3Tensor) v1_pair, v2_pair
		CHARACTER(LEN = 64) filename
	END TYPE

	! Range of the Brink-Boker term
	
	DOUBLE PRECISION, DIMENSION(0:1) :: mu
	DATA mu /0.7, 1.2/

 CONTAINS

        !---------------------------------------------------------------------------------------!
	!											!
        !   Creates a new object of the type SymVBBph, that is in fact a collection of 		!
	!   "3D tensors" arrays SymD3Tensor_SymD3Tensor, as defined in module symd3t.f90	!
	!   Here we create each of the corresponding parts of the type SymVBBph and allocate 	!
	!   the appropriate amount of memory							!
	!   											!
	!   This tensor is for the Brink-Boker matrix elements in the particle-hole channel	!
	!											!
        !---------------------------------------------------------------------------------------!
	
	SUBROUTINE SymVBBph_new(vBBph, b)
		TYPE (SymVBBph), INTENT(INOUT) :: vBBph
		DOUBLE PRECISION, INTENT(IN) :: b

		! Create the tensors

		CALL SymD3Tensor_SymD3Tensor_new(vBBph%v_local_same_part)
		CALL SymD3Tensor_SymD3Tensor_new(vBBph%v_local_diff_part)
		CALL SymD3Tensor_SymD3Tensor_new(vBBph%v1_exch_same_part)
		CALL SymD3Tensor_SymD3Tensor_new(vBBph%v1_exch_diff_part)
		CALL SymD3Tensor_SymD3Tensor_new(vBBph%v2_exch_same_part)
		CALL SymD3Tensor_SymD3Tensor_new(vBBph%v2_exch_diff_part)
		CALL SymD3Tensor_SymD3Tensor_new(vBBph%v1_same_part)
		CALL SymD3Tensor_SymD3Tensor_new(vBBph%v1_diff_part)
		CALL SymD3Tensor_SymD3Tensor_new(vBBph%v2_same_part)
		CALL SymD3Tensor_SymD3Tensor_new(vBBph%v2_diff_part)
		
		vBBph%b1 = b
		
                SELECT CASE (Basis)
		
		CASE (1)
         
			IF (N_0 < 10) THEN
				WRITE(vBBph%filename, "(A,I1,A)") "data/vBB", N_0, "ph_HO.txt"
			ELSE
				WRITE(vBBph%filename, "(A,I2,A)") "data/vBB", N_0, "ph_HO.txt"
			END IF

		CASE (2)
         
			IF (N_0 < 10) THEN
				WRITE(vBBph%filename, "(A,I1,A)") "data/vBB", N_0, "ph_WS.txt"
			ELSE
				WRITE(vBBph%filename, "(A,I2,A)") "data/vBB", N_0, "ph_WS.txt"
			END IF

		END SELECT
		
		RETURN		
	END SUBROUTINE SymVBBph_new

        !---------------------------------------------------------------------------------------!
	!											!
	!   Subroutine calculating the matrix elements of the Brink-Boker term. We distinguish	!
	!   2 special cases, either the calculation is done in the harmonicoscillator basis 	!
	!   (basis = 1) or in a general spherical basis (basis = 2)				!
	!											!
	!   BEWARE: Here the HO length b is implicitely assumed equal to 1, otherwise,there 	!
	!           should be a factor 1/b							!
	!											!
	!   Refs: Appendix F									!
	!											!
        !---------------------------------------------------------------------------------------!

	SUBROUTINE SymVBBph_calculate(vBBph)
		TYPE (SymVBBph), INTENT(INOUT) :: vBBph

		INTEGER i
		INTEGER la, namax, na, nc, lb, nbmax, nb, nd
		DOUBLE PRECISION sumi_sp, sumi_dp, total_ibb
		INTEGER k, kmin, kmax
		DOUBLE PRECISION sum1_sp, sum1_dp, sum2_sp, sum2_dp
		DOUBLE PRECISION tres_j_cuad, cuad

		DOUBLE PRECISION, DIMENSION(0:1) :: x, &
			coef_local_same_part, coef_local_diff_part, &
			coef_exch1_same_part, coef_exch1_diff_part, &
			coef_exch2_same_part, coef_exch2_diff_part

		INTEGER, PARAMETER :: file_desc = 6
		INTEGER file_error

		! If the matrix elements were already calculated, we read them and avoid thereby recalculating them
		! The tensors are then updated with the values read from tape

		IF (N_0 .LE. 16) THEN
		
			IF (SymVBBph_read(vBBph)) THEN
				CALL SymVBBph_update(vBBph)
				RETURN
			END IF

			OPEN(file_desc, FILE=vBBph%filename, ACTION="WRITE", IOSTAT=file_error)
			IF (file_error .NE. 0) THEN
				PRINT *, "*** Attention: Impossible to write in ", vBBph%filename
			ELSE
				WRITE (file_desc, FMT="(E)", IOSTAT=file_error) vBBph%b1
			END IF
			
		END IF

		! For each isospin, we calculate the constant numerical factors in front of the matrix elements 
		! names with the suffix "_same_part" refer to the terms with the delta_(ta,tb), names with the
		! suffix "_diff_part" refer to the terms with the other terms:
		!
		! Refs.: Page 130-131, Definition of v1eBB and v2eBB

		DO i = 0, 1
			x(i) = mu(i) / vBBph%b1
			coef_local_diff_part(i) = I_4PI * (Gogny_W(i, Gogny) + (0.5 * Gogny_B(i, Gogny)))
			coef_local_same_part(i) = coef_local_diff_part(i) - (I_4PI * (Gogny_H(i, Gogny) + (0.5 * Gogny_M(i, Gogny))))
			coef_exch1_diff_part(i) = - I_4PI * ((0.5 * Gogny_H(i, Gogny)) + Gogny_M(i, Gogny))
			coef_exch1_same_part(i) = coef_exch1_diff_part(i) + (I_4PI * ((0.5 * Gogny_W(i, Gogny)) + Gogny_B(i, Gogny)))
			coef_exch2_diff_part(i) = - I_4PI * Gogny_H(i, Gogny)
			coef_exch2_same_part(i) = coef_exch2_diff_part(i) + (I_4PI * Gogny_W(i, Gogny))
		END DO

                SELECT CASE (Basis)
		
		CASE (1)
         
			! Calculation of the matrix elements v1eBB and v2eBB as defined in Page 131  ---  CHECKED AND OK

			PRINT *, "Brink-Boker terms: Particle-Hole Channel - Harmonic Oscillator Basis"
			! Los mas altos son los mas problematicos
			! DO la = N_0, 0, -1
			DO la = 0, N_0
				namax = ((N_0 - la) / 2) + 1
				DO na = 1, namax
					DO nc = 1, na
				
						DO lb = 0, la
							nbmax = ((N_0 - lb) / 2) + 1
							DO nb = 1, nbmax
								DO nd = 1, nb
							
									! Calculation of the term k=0 in the multipole expansion over Wk(r1,r2). This actually 
									! corresponds to the local term

									sumi_sp = 0.0
									sumi_dp = 0.0
								
									DO i = 0, 1
										total_ibb = IBrinkBookerHO(na - 1, la, nb - 1, lb, nc - 1, la, nd - 1, lb, 0, x(i))
										IF (nb .NE. nd) THEN
											total_ibb = total_ibb + IBrinkBookerHO(na - 1, la, nd - 1, lb, nc - 1, la, nb - 1, lb, 0, x(i))
											total_ibb = total_ibb / 2.0
										END IF
										sumi_sp = sumi_sp + (coef_local_same_part(i) * total_ibb)
										sumi_dp = sumi_dp + (coef_local_diff_part(i) * total_ibb)
									END DO
								
									CALL SymD3Tensor_SymD3Tensor_assign(vBBph%v_local_same_part, la, na, nc, lb, nb, nd, sumi_sp)
									CALL SymD3Tensor_SymD3Tensor_assign(vBBph%v_local_same_part, lb, nb, nd, la, na, nc, sumi_sp)
									CALL SymD3Tensor_SymD3Tensor_assign(vBBph%v_local_diff_part, la, na, nc, lb, nb, nd, sumi_dp)
									CALL SymD3Tensor_SymD3Tensor_assign(vBBph%v_local_diff_part, lb, nb, nd, la, na, nc, sumi_dp)

									! Summations over the multipole Wk(r1, r2) (Appendix B, formula above B2, page 113) are restricted 
									! by the angular part. Only the terms with ABS(la - lb) <= k <= la + lb give non-zero terms
		
									kmin = ABS(la - lb)
									kmax = la + lb
									
									sum1_sp = 0.0
									sum1_dp = 0.0
									sum2_sp = 0.0
									sum2_dp = 0.0
								
									DO k = kmin, kmax, 2
										tres_j_cuad = (2*k + 1) * (ThreeJSymbols_get(2*la, 2*k, 2*lb) ** 2)
										cuad = CUAD2(la, lb, k)
										DO i = 0, 1
											total_ibb = IBrinkBookerHO(na - 1, la, nb - 1, lb, nd - 1, lb, nc - 1, la, k, x(i))
											IF(nb .NE. nd) THEN
												total_ibb = total_ibb + IBrinkBookerHO(na - 1, la, nd - 1, lb, nb - 1, lb, nc - 1, la, k, x(i))
												total_ibb = total_ibb / 2.0
											END IF
											sum1_sp = sum1_sp + (coef_exch1_same_part(i) * tres_j_cuad * total_ibb)
											sum1_dp = sum1_dp + (coef_exch1_diff_part(i) * tres_j_cuad * total_ibb)
											sum2_sp = sum2_sp + (coef_exch2_same_part(i) * cuad * tres_j_cuad * total_ibb)
											sum2_dp = sum2_dp + (coef_exch2_diff_part(i) * cuad * tres_j_cuad * total_ibb)
										END DO     
									END DO
								
									sum1_sp = -sum1_sp
									sum1_dp = -sum1_dp
									sum2_sp = -sum2_sp
									sum2_dp = -sum2_dp
								
									CALL SymD3Tensor_SymD3Tensor_assign(vBBph%v1_exch_same_part, la, na, nc, lb, nb, nd, sum1_sp)
									CALL SymD3Tensor_SymD3Tensor_assign(vBBph%v1_exch_same_part, lb, nb, nd, la, na, nc, sum1_sp)
									CALL SymD3Tensor_SymD3Tensor_assign(vBBph%v1_exch_diff_part, la, na, nc, lb, nb, nd, sum1_dp)
									CALL SymD3Tensor_SymD3Tensor_assign(vBBph%v1_exch_diff_part, lb, nb, nd, la, na, nc, sum1_dp)
									CALL SymD3Tensor_SymD3Tensor_assign(vBBph%v2_exch_same_part, la, na, nc, lb, nb, nd, sum2_sp)
									CALL SymD3Tensor_SymD3Tensor_assign(vBBph%v2_exch_same_part, lb, nb, nd, la, na, nc, sum2_sp)
									CALL SymD3Tensor_SymD3Tensor_assign(vBBph%v2_exch_diff_part, la, na, nc, lb, nb, nd, sum2_dp)
									CALL SymD3Tensor_SymD3Tensor_assign(vBBph%v2_exch_diff_part, lb, nb, nd, la, na, nc, sum2_dp)
								
									IF ((N_0 .LE. 16) .AND. (file_error .EQ. 0)) THEN
										WRITE (file_desc, FMT="(I3,I3,I3,I3,I3,I3,E,E,E,E,E,E)", IOSTAT=file_error) &
											la, na, nc, lb, nb, nd, sumi_sp, sumi_dp, sum1_sp, sum1_dp, sum2_sp, sum2_dp
									END IF
								END DO
							END DO
						END DO
					END DO
				END DO
				PRINT "(I3,A)", INT(100 * (la + 1) / (N_0 + 1)), "% calculado"
			END DO

		CASE(2)
		
			PRINT *, "Brink-Boker terms: Particle-Hole Channel - General Basis"
			! Los mas altos son los mas problematicos
			! DO la = N_0, 0, -1
			DO la = 0, N_0
				namax = ((N_0 - la) / 2) + 1
				DO na = 1, namax
					DO nc = 1, na
				
						DO lb = 0, la
							nbmax = ((N_0 - lb) / 2) + 1
							DO nb = 1, nbmax
								DO nd = 1, nb
							
									sumi_sp = 0.0
									sumi_dp = 0.0
								
									DO i = 0, 1
										total_ibb = IBrinkBooker(na, la, nb, lb, nc, la, nd, lb, 0, mu(i))
										IF (nb .NE. nd) THEN
											total_ibb = total_ibb + IBrinkBooker(na, la, nd, lb, nc, la, nb, lb, 0, mu(i))
											total_ibb = total_ibb / 2.0
										END IF
										sumi_sp = sumi_sp + (coef_local_same_part(i) * total_ibb)
										sumi_dp = sumi_dp + (coef_local_diff_part(i) * total_ibb)
									END DO
								
									CALL SymD3Tensor_SymD3Tensor_assign(vBBph%v_local_same_part, la, na, nc, lb, nb, nd, sumi_sp)
									CALL SymD3Tensor_SymD3Tensor_assign(vBBph%v_local_same_part, lb, nb, nd, la, na, nc, sumi_sp)
									CALL SymD3Tensor_SymD3Tensor_assign(vBBph%v_local_diff_part, la, na, nc, lb, nb, nd, sumi_dp)
									CALL SymD3Tensor_SymD3Tensor_assign(vBBph%v_local_diff_part, lb, nb, nd, la, na, nc, sumi_dp)

									kmin = ABS(la - lb)
									kmax = la + lb
									sum1_sp = 0.0
									sum1_dp = 0.0
									sum2_sp = 0.0
									sum2_dp = 0.0
								
									DO k = kmin, kmax, 2
										tres_j_cuad = (2 * k + 1) * (ThreeJSymbols_get(2 * la, 2 * k, 2 * lb) ** 2)
										cuad = CUAD2(la, lb, k)
										DO i = 0, 1
											total_ibb = IBrinkBooker(na, la, nb, lb, nd, lb, nc, la, k, mu(i))
											IF(nb .NE. nd) THEN
												total_ibb = total_ibb + IBrinkBooker(na, la, nd, lb, nb, lb, nc, la, k, mu(i))
												total_ibb = total_ibb / 2.0
											END IF
											sum1_sp = sum1_sp + (coef_exch1_same_part(i) * tres_j_cuad * total_ibb)
											sum1_dp = sum1_dp + (coef_exch1_diff_part(i) * tres_j_cuad * total_ibb)
											sum2_sp = sum2_sp + (coef_exch2_same_part(i) * cuad * tres_j_cuad * total_ibb)
											sum2_dp = sum2_dp + (coef_exch2_diff_part(i) * cuad * tres_j_cuad * total_ibb)
										END DO     
									END DO
								
									sum1_sp = -sum1_sp
									sum1_dp = -sum1_dp
									sum2_sp = -sum2_sp
									sum2_dp = -sum2_dp
								
									CALL SymD3Tensor_SymD3Tensor_assign(vBBph%v1_exch_same_part, la, na, nc, lb, nb, nd, sum1_sp)
									CALL SymD3Tensor_SymD3Tensor_assign(vBBph%v1_exch_same_part, lb, nb, nd, la, na, nc, sum1_sp)
									CALL SymD3Tensor_SymD3Tensor_assign(vBBph%v1_exch_diff_part, la, na, nc, lb, nb, nd, sum1_dp)
									CALL SymD3Tensor_SymD3Tensor_assign(vBBph%v1_exch_diff_part, lb, nb, nd, la, na, nc, sum1_dp)
									CALL SymD3Tensor_SymD3Tensor_assign(vBBph%v2_exch_same_part, la, na, nc, lb, nb, nd, sum2_sp)
									CALL SymD3Tensor_SymD3Tensor_assign(vBBph%v2_exch_same_part, lb, nb, nd, la, na, nc, sum2_sp)
									CALL SymD3Tensor_SymD3Tensor_assign(vBBph%v2_exch_diff_part, la, na, nc, lb, nb, nd, sum2_dp)
									CALL SymD3Tensor_SymD3Tensor_assign(vBBph%v2_exch_diff_part, lb, nb, nd, la, na, nc, sum2_dp)
								
									IF ((N_0 .LE. 16) .AND. (file_error .EQ. 0)) THEN
										WRITE (file_desc, FMT="(I3,I3,I3,I3,I3,I3,E,E,E,E,E,E)", IOSTAT=file_error) &
											la, na, nc, lb, nb, nd, sumi_sp, sumi_dp, sum1_sp, sum1_dp, sum2_sp, sum2_dp
									END IF
								END DO
							END DO
						END DO
					END DO
				END DO
				PRINT "(I3,A)", INT(100 * (la + 1) / (N_0 + 1)), "% calculado"
			END DO
		
		END SELECT
			
		CALL SymVBBph_update(vBBph)
		IF (N_0 .LE. 16) CLOSE(file_desc)

		RETURN

	CONTAINS

		!---------------------------------------------------------------------------------------!
		!   Subroutine updating the tensor fields of the Brink-Boeker term in the particle-	!
		!   hole channel after reading the matrix elements from tape				!
        	!---------------------------------------------------------------------------------------!

		SUBROUTINE SymVBBph_update(vBBph)
			TYPE (SymVBBph), INTENT(INOUT) :: vBBph

			CALL SymD3Tensor_SymD3Tensor_add(vBBph%v1_same_part, vBBph%v_local_same_part, vBBph%v1_exch_same_part)
			CALL SymD3Tensor_SymD3Tensor_add(vBBph%v1_diff_part, vBBph%v_local_diff_part, vBBph%v1_exch_diff_part)
			CALL SymD3Tensor_SymD3Tensor_add(vBBph%v2_same_part, vBBph%v_local_same_part, vBBph%v2_exch_same_part)
			CALL SymD3Tensor_SymD3Tensor_add(vBBph%v2_diff_part, vBBph%v_local_diff_part, vBBph%v2_exch_diff_part)
			
			RETURN
		END SUBROUTINE SymVBBph_update

	END SUBROUTINE SymVBBph_calculate

	SUBROUTINE SymVBBph_product(HF_out, vBBph, HF_in)
		TYPE (SymHartreeFockField), INTENT(INOUT) :: HF_out
		TYPE (SymVBBph), INTENT(IN) :: vBBph
		TYPE (SymHartreeFockField), INTENT(IN) :: HF_in

		CALL SymVBBph_get_Gamma(HF_out, vBBph, HF_in)
		RETURN
	END SUBROUTINE SymVBBph_product

	SUBROUTINE SymVBBph_get_Gamma(HF_out, vBBph, HF_in)
		TYPE (SymHartreeFockField), INTENT(INOUT) :: HF_out
		TYPE (SymVBBph), INTENT(IN) :: vBBph
		TYPE (SymHartreeFockField), INTENT(IN) :: HF_in

		TYPE (SymD3Tensor) same, diff

		CALL SymD3Tensor_new(same)
		CALL SymD3Tensor_new(diff)

		CALL SymD3Tensor_SymD3Tensor_product(same, vBBph%v1_same_part, HF_in%p(0))
		CALL SymD3Tensor_SymD3Tensor_product(diff, vBBph%v1_diff_part, HF_in%p(1))
		CALL SymD3Tensor_add(HF_out%p(0), same, diff)

		CALL SymD3Tensor_SymD3Tensor_product(same, vBBph%v1_same_part, HF_in%p(1))
		CALL SymD3Tensor_SymD3Tensor_product(diff, vBBph%v1_diff_part, HF_in%p(0))
		CALL SymD3Tensor_add(HF_out%p(1), same, diff)

		CALL SymD3Tensor_SymD3Tensor_product(same, vBBph%v2_exch_same_part, HF_in%a(0))
		CALL SymD3Tensor_SymD3Tensor_product(diff, vBBph%v2_exch_diff_part, HF_in%a(1))
		CALL SymD3Tensor_add(HF_out%a(0), same, diff)

		CALL SymD3Tensor_SymD3Tensor_product(same, vBBph%v2_exch_same_part, HF_in%a(1))
		CALL SymD3Tensor_SymD3Tensor_product(diff, vBBph%v2_exch_diff_part, HF_in%a(0))
		CALL SymD3Tensor_add(HF_out%a(1), same, diff)

		CALL SymD3Tensor_del(same)
		CALL SymD3Tensor_del(diff)
		RETURN
	END SUBROUTINE SymVBBph_get_Gamma

	SUBROUTINE SymVBBph_get_LocalGamma(HF_out, vBBph, HF_in)
		TYPE (SymHartreeFockField), INTENT(INOUT) :: HF_out
		TYPE (SymVBBph), INTENT(IN) :: vBBph
		TYPE (SymHartreeFockField), INTENT(IN) :: HF_in

		TYPE (SymD3Tensor) same, diff

		CALL SymD3Tensor_new(same)
		CALL SymD3Tensor_new(diff)

		CALL SymD3Tensor_SymD3Tensor_product(same, vBBph%v_local_same_part, HF_in%p(0))
		CALL SymD3Tensor_SymD3Tensor_product(diff, vBBph%v_local_diff_part, HF_in%p(1))
		CALL SymD3Tensor_add(HF_out%p(0), same, diff)

		CALL SymD3Tensor_SymD3Tensor_product(same, vBBph%v_local_same_part, HF_in%p(1))
		CALL SymD3Tensor_SymD3Tensor_product(diff, vBBph%v_local_diff_part, HF_in%p(0))
		CALL SymD3Tensor_add(HF_out%p(1), same, diff)

		HF_out%a(0) = DBLE(0.0)
		HF_out%a(1) = DBLE(0.0)

		CALL SymD3Tensor_del(same)
		CALL SymD3Tensor_del(diff)
		RETURN
	END SUBROUTINE SymVBBph_get_LocalGamma

	SUBROUTINE SymVBBph_get_ExchangeGamma(HF_out, vBBph, HF_in)
		TYPE (SymHartreeFockField), INTENT(INOUT) :: HF_out
		TYPE (SymVBBph), INTENT(IN) :: vBBph
		TYPE (SymHartreeFockField), INTENT(IN) :: HF_in

		TYPE (SymD3Tensor) same, diff

		CALL SymD3Tensor_new(same)
		CALL SymD3Tensor_new(diff)

		CALL SymD3Tensor_SymD3Tensor_product(same, vBBph%v1_exch_same_part, HF_in%p(0))
		CALL SymD3Tensor_SymD3Tensor_product(diff, vBBph%v1_exch_diff_part, HF_in%p(1))
		CALL SymD3Tensor_add(HF_out%p(0), same, diff)

		CALL SymD3Tensor_SymD3Tensor_product(same, vBBph%v1_exch_same_part, HF_in%p(1))
		CALL SymD3Tensor_SymD3Tensor_product(diff, vBBph%v1_exch_diff_part, HF_in%p(0))
		CALL SymD3Tensor_add(HF_out%p(1), same, diff)

		CALL SymD3Tensor_SymD3Tensor_product(same, vBBph%v2_exch_same_part, HF_in%a(0))
		CALL SymD3Tensor_SymD3Tensor_product(diff, vBBph%v2_exch_diff_part, HF_in%a(1))
		CALL SymD3Tensor_add(HF_out%a(0), same, diff)

		CALL SymD3Tensor_SymD3Tensor_product(same, vBBph%v2_exch_same_part, HF_in%a(1))
		CALL SymD3Tensor_SymD3Tensor_product(diff, vBBph%v2_exch_diff_part, HF_in%a(0))
		CALL SymD3Tensor_add(HF_out%a(1), same, diff)

		CALL SymD3Tensor_del(same)
		CALL SymD3Tensor_del(diff)
		RETURN
	END SUBROUTINE SymVBBph_get_ExchangeGamma

        !---------------------------------------------------------------------------------------!
	!											!
	!   Subroutine reading the matrix elements of the Brink-Boker term in the particle-hole	!
	!   channel. This subroutine attempts reading a file containing previously calculated	!
	!   matrix elements. It is used to decide whether or not to recalculate eveything	!
	!											!
        !---------------------------------------------------------------------------------------!

	FUNCTION SymVBBph_read(vBBph)
		LOGICAL SymVBBph_read
		TYPE (SymVBBph), INTENT(INOUT) :: vBBph

		DOUBLE PRECISION b1
		INTEGER la, namax, na, nc, lb, nbmax, nb, nd
		INTEGER i1, i2, i3, i4, i5, i6
		INTEGER, PARAMETER :: file_desc = 6
		INTEGER file_error
		DOUBLE PRECISION sumi_sp, sumi_dp, sum1_sp, sum1_dp, sum2_sp, sum2_dp

		OPEN(file_desc, FILE=vBBph%filename, ACTION="READ", IOSTAT=file_error)
		IF (file_error .NE. 0) THEN
			PRINT *, "Impossible to read file: ", vBBph%filename
			SymVBBph_read = .FALSE.
			RETURN
		END IF

		READ (file_desc, FMT="(E)", IOSTAT=file_error) b1
		IF ((file_error .NE. 0) .OR. (b1 .NE. vBBph%b1)) THEN
			CLOSE(file_desc)
			SymVBBph_read = .FALSE.
			RETURN
		END IF

!		PRINT *, "Leyendo:", vBBph%filename
		DO la = 0, N_0
			namax = ((N_0 - la) / 2) + 1
			DO na = 1, namax
				DO nc = 1, na
					DO lb = 0, la
						nbmax = ((N_0 - lb) / 2) + 1
						DO nb = 1, nbmax
							DO nd = 1, nb
							
								READ (file_desc, FMT="(I3,I3,I3,I3,I3,I3,E,E,E,E,E,E)", IOSTAT=file_error) &
									i1, i2, i3, i4, i5, i6, sumi_sp, sumi_dp, sum1_sp, sum1_dp, sum2_sp, sum2_dp
									
								IF ((file_error .NE. 0) .OR. &
									(la .NE. i1) .OR. (na .NE. i2) .OR. (nc .NE. i3) .OR. &
									(lb .NE. i4) .OR. (nb .NE. i5) .OR. (nd .NE. i6)) THEN
									PRINT *, "Invalid information in file: ", vBBph%filename
									CLOSE(file_desc)
									SymVBBph_read = .FALSE.
									RETURN
								END IF
								
								CALL SymD3Tensor_SymD3Tensor_assign(vBBph%v_local_same_part, la, na, nc, lb, nb, nd, sumi_sp)
								CALL SymD3Tensor_SymD3Tensor_assign(vBBph%v_local_same_part, lb, nb, nd, la, na, nc, sumi_sp)
								CALL SymD3Tensor_SymD3Tensor_assign(vBBph%v_local_diff_part, la, na, nc, lb, nb, nd, sumi_dp)
								CALL SymD3Tensor_SymD3Tensor_assign(vBBph%v_local_diff_part, lb, nb, nd, la, na, nc, sumi_dp)
								CALL SymD3Tensor_SymD3Tensor_assign(vBBph%v1_exch_same_part, la, na, nc, lb, nb, nd, sum1_sp)
								CALL SymD3Tensor_SymD3Tensor_assign(vBBph%v1_exch_same_part, lb, nb, nd, la, na, nc, sum1_sp)
								CALL SymD3Tensor_SymD3Tensor_assign(vBBph%v1_exch_diff_part, la, na, nc, lb, nb, nd, sum1_dp)
								CALL SymD3Tensor_SymD3Tensor_assign(vBBph%v1_exch_diff_part, lb, nb, nd, la, na, nc, sum1_dp)
								CALL SymD3Tensor_SymD3Tensor_assign(vBBph%v2_exch_same_part, la, na, nc, lb, nb, nd, sum2_sp)
								CALL SymD3Tensor_SymD3Tensor_assign(vBBph%v2_exch_same_part, lb, nb, nd, la, na, nc, sum2_sp)
								CALL SymD3Tensor_SymD3Tensor_assign(vBBph%v2_exch_diff_part, la, na, nc, lb, nb, nd, sum2_dp)
								CALL SymD3Tensor_SymD3Tensor_assign(vBBph%v2_exch_diff_part, lb, nb, nd, la, na, nc, sum2_dp)
								
							END DO
						END DO
					END DO
				END DO
			END DO
		END DO
		CLOSE(file_desc)
		SymVBBph_read = .TRUE.
		RETURN
	END FUNCTION SymVBBph_read

        !---------------------------------------------------------------------------------------!
	!											!
	!   Subroutine deleting the tensors corresponding to the matrix elements of the Brink-	!
	!   Boker in the particle-hole channel.							!
	!											!
        !---------------------------------------------------------------------------------------!

	SUBROUTINE SymVBBph_del(vBBph)
		TYPE (SymVBBph), INTENT(INOUT) :: vBBph

		CALL SymD3Tensor_SymD3Tensor_del(vBBph%v_local_same_part)
		CALL SymD3Tensor_SymD3Tensor_del(vBBph%v_local_diff_part)
		CALL SymD3Tensor_SymD3Tensor_del(vBBph%v1_exch_same_part)
		CALL SymD3Tensor_SymD3Tensor_del(vBBph%v1_exch_diff_part)
		CALL SymD3Tensor_SymD3Tensor_del(vBBph%v2_exch_same_part)
		CALL SymD3Tensor_SymD3Tensor_del(vBBph%v2_exch_diff_part)
		CALL SymD3Tensor_SymD3Tensor_del(vBBph%v1_same_part)
		CALL SymD3Tensor_SymD3Tensor_del(vBBph%v1_diff_part)
		CALL SymD3Tensor_SymD3Tensor_del(vBBph%v2_same_part)
		CALL SymD3Tensor_SymD3Tensor_del(vBBph%v2_diff_part)
		
		RETURN
	END SUBROUTINE SymVBBph_del

        !---------------------------------------------------------------------------------------!
	!											!
        !   Creates a new object of the type SymVBBph, that is in fact a collection of 		!
	!   "3D tensors" arrays SymD3Tensor_SymD3Tensor, as defined in module symd3t.f90	!
	!   Here we create each of the corresponding parts of the type SymVBBph and allocate 	!
	!   the appropriate amount of memory							!
	!   											!
	!   This tensor is for the Brink-Boker matrix elements in the particle-particle channel	!
	!											!
        !---------------------------------------------------------------------------------------!
	
	SUBROUTINE SymVBBpp_new(vBBpp, b)
		TYPE (SymVBBpp), INTENT(INOUT) :: vBBpp
		DOUBLE PRECISION, INTENT(IN) :: b

		CALL SymD3Tensor_SymD3Tensor_new(vBBpp%v1_pair)
		CALL SymD3Tensor_SymD3Tensor_new(vBBpp%v2_pair)

		vBBpp%b1 = b
		
                SELECT CASE (Basis)
		
		CASE (1)
         
			IF (N_0 < 10) THEN
				WRITE(vBBpp%filename, "(A,I1,A)") "data/vBB", N_0, "pp_HO.txt"
			ELSE
				WRITE(vBBpp%filename, "(A,I2,A)") "data/vBB", N_0, "pp_HO.txt"
			END IF
			
		CASE(2)
		
			IF (N_0 < 10) THEN
				WRITE(vBBpp%filename, "(A,I1,A)") "data/vBB", N_0, "pp_WS.txt"
			ELSE
				WRITE(vBBpp%filename, "(A,I2,A)") "data/vBB", N_0, "pp_WS.txt"
			END IF
		
		END SELECT
			
		RETURN
	END SUBROUTINE SymVBBpp_new

        !---------------------------------------------------------------------------------------!
	!											!
	!   Subroutine calculating the matrix elements of the Brink-Boker term in the particle-	!
	!   particle channel. We distinguish 2 special cases, either the calculation is done 	!
	!   in the harmonic oscillator basis (basis = 1) or in a general spherical basis 	!
	!   (basis = 2)										!	
	!											!
	!   BEWARE: Here the HO length b is implicitely assumed equal to 1, otherwise,there 	!
	!           should be a factor 1/b							!
	!											!
	!   Refs: Appendix F, Page 138								!
	!											!
        !---------------------------------------------------------------------------------------!

	SUBROUTINE SymVBBpp_calculate(vBBpp)
		TYPE (SymVBBpp), INTENT(INOUT) :: vBBpp

		INTEGER i
		INTEGER la, namax, na, nc, lb, nbmax, nb, nd
		INTEGER k, kmin, kmax
		DOUBLE PRECISION sum1, sum2
		DOUBLE PRECISION tres_j_cuad, cuad, total_ibb

		DOUBLE PRECISION, DIMENSION(0:1) :: x, coef_pair1, coef_pair2

		INTEGER, PARAMETER :: file_desc = 6
		INTEGER file_error

		! If the matrix elements were already calculated, we read them and avoid thereby recalculating them
		! The tensors are then updated with the values read from tape

		IF (N_0 .LE. 16) THEN
			IF (SymVBBpp_read(vBBpp)) RETURN

			OPEN(file_desc, FILE=vBBpp%filename, ACTION="WRITE", IOSTAT=file_error)
			IF (file_error .NE. 0) THEN
				PRINT *, "*** Attention: Impossible to write in ", vBBpp%filename
			ELSE
				WRITE (file_desc, FMT="(E)", IOSTAT=file_error) vBBpp%b1
			END IF
		END IF

		! For each isospin, we calculate the constant numerical factors in front of the matrix elements 
		! names with the suffix "_same_part" refer to the terms with the delta_(ta,tb), names with the
		! suffix "_diff_part" refer to the terms with the other terms:
		!
		! Refs.: Page 132, top of th page, definition of v1pBB and v2pBB  	---  CHECKED AND OK
		!

		DO i = 0, 1
			x(i) = mu(i) / vBBpp%b1
			coef_pair1(i) = 0.5 * I_4PI * (Gogny_W(i, Gogny) - Gogny_B(i, Gogny) - Gogny_H(i, Gogny) + Gogny_M(i, Gogny))
			coef_pair2(i) =       I_4PI * (Gogny_W(i, Gogny) + Gogny_B(i, Gogny) - Gogny_H(i, Gogny) - Gogny_M(i, Gogny))
		END DO

                SELECT CASE (Basis)
		
		CASE (1)
         
			! Calculation of the matrix elements v1pBB and v2pBB as defined in Page 132  ---  CHECKED AND OK

			PRINT *, "Brink-Boker terms: Particle-Particle Channel - Harmonic Oscillator Basis"
			DO la = 0, N_0
				namax = ((N_0 - la) / 2) + 1
				DO na = 1, namax
					DO nc = 1, na
						DO lb = 0, la
							nbmax = ((N_0 - lb) / 2) + 1
							DO nb = 1, nbmax
								DO nd = 1, nb
								
									kmin = ABS(la - lb)
									kmax = la + lb
									
									sum1 = 0.0
									sum2 = 0.0
									
									DO k = kmin, kmax, 2
										tres_j_cuad = (2*k + 1) * (ThreeJSymbols_get(2*la, 2*k, 2*lb) ** 2)
										cuad = CUAD2(la, lb, k)
										DO i = 0, 1
											total_ibb = IBrinkBookerHO(na - 1, la, nc - 1, la, nb - 1, lb, nd - 1, lb, k, x(i))
											IF(nb .NE. nd) THEN
												total_ibb = total_ibb + IBrinkBookerHO(na - 1, la, nc - 1, la, nd - 1, lb, nb - 1, lb, k, x(i))
												total_ibb = total_ibb / 2.0
											END IF
											sum1 = sum1 + (coef_pair1(i) * tres_j_cuad * total_ibb)
											sum2 = sum2 + (coef_pair2(i) * cuad * tres_j_cuad * total_ibb)
										END DO     
									END DO
									
									sum1 = sum1 * PAR(la + lb)
									sum2 = sum2 * PAR(la + lb)
									
									CALL SymD3Tensor_SymD3Tensor_assign(vBBpp%v1_pair, la, na, nc, lb, nb, nd, sum1)
									CALL SymD3Tensor_SymD3Tensor_assign(vBBpp%v1_pair, lb, nb, nd, la, na, nc, sum1)
									CALL SymD3Tensor_SymD3Tensor_assign(vBBpp%v2_pair, la, na, nc, lb, nb, nd, sum2)
									CALL SymD3Tensor_SymD3Tensor_assign(vBBpp%v2_pair, lb, nb, nd, la, na, nc, sum2)
									
									IF ((N_0 .LE. 16) .AND. (file_error .EQ. 0)) THEN
										WRITE (file_desc, FMT="(I3,I3,I3,I3,I3,I3,E,E)", IOSTAT=file_error) &
											la, na, nc, lb, nb, nd, sum1, sum2
									END IF
									
								END DO
							END DO
						END DO
					END DO
				END DO
				PRINT "(I3,A)", INT(100 * (la + 1) / (N_0 + 1)), "% calculado"
			END DO
			
		CASE(2)
		
			PRINT *, "Brink-Boker terms: Particle-Particle Channel - General Basis"
			DO la = 0, N_0
				namax = ((N_0 - la) / 2) + 1
				DO na = 1, namax
					DO nc = 1, na
						DO lb = 0, la
							nbmax = ((N_0 - lb) / 2) + 1
							DO nb = 1, nbmax
								DO nd = 1, nb
									kmin = ABS(la - lb)
									kmax = la + lb
									sum1 = 0.0
									sum2 = 0.0
									DO k = kmin, kmax, 2
										tres_j_cuad = (2 * k + 1) * (ThreeJSymbols_get(2 * la, 2 * k, 2 * lb) ** 2)
										cuad = CUAD2(la, lb, k)
										DO i = 0, 1
											total_ibb = IBrinkBooker(na, la, nc, la, nb, lb, nd, lb, k, mu(i))
											IF(nb .NE. nd) THEN
												total_ibb = total_ibb + IBrinkBooker(na, la, nc, la, nd, lb, nb, lb, k, mu(i))
												total_ibb = total_ibb / 2.0
											END IF
											sum1 = sum1 + (coef_pair1(i) * tres_j_cuad * total_ibb)
											sum2 = sum2 + (coef_pair2(i) * cuad * tres_j_cuad * total_ibb)
										END DO     
									END DO
									sum1 = sum1 * PAR(la + lb)
									sum2 = sum2 * PAR(la + lb)
									CALL SymD3Tensor_SymD3Tensor_assign(vBBpp%v1_pair, la, na, nc, lb, nb, nd, sum1)
									CALL SymD3Tensor_SymD3Tensor_assign(vBBpp%v1_pair, lb, nb, nd, la, na, nc, sum1)
									CALL SymD3Tensor_SymD3Tensor_assign(vBBpp%v2_pair, la, na, nc, lb, nb, nd, sum2)
									CALL SymD3Tensor_SymD3Tensor_assign(vBBpp%v2_pair, lb, nb, nd, la, na, nc, sum2)
									IF ((N_0 .LE. 16) .AND. (file_error .EQ. 0)) THEN
										WRITE (file_desc, FMT="(I3,I3,I3,I3,I3,I3,E,E)", IOSTAT=file_error) &
											la, na, nc, lb, nb, nd, sum1, sum2
									END IF
								END DO
							END DO
						END DO
					END DO
				END DO
				PRINT "(I3,A)", INT(100 * (la + 1) / (N_0 + 1)), "% calculado"
			END DO
			
		END SELECT
			
		IF (N_0 .LE. 16) CLOSE(file_desc)
		RETURN
	END SUBROUTINE SymVBBpp_calculate

	SUBROUTINE SymVBBpp_product(HF_out, vBBpp, HF_in)
		TYPE (SymHartreeFockField), INTENT(INOUT) :: HF_out
		TYPE (SymVBBpp), INTENT(IN) :: vBBpp
		TYPE (SymHartreeFockField), INTENT(IN) :: HF_in

		CALL SymVBBpp_get_Delta(HF_out, vBBpp, HF_in)
		RETURN
	END SUBROUTINE SymVBBpp_product

	SUBROUTINE SymVBBpp_get_Delta(HF_out, vBBpp, P_in)
		TYPE (SymHartreeFockField), INTENT(INOUT) :: HF_out
		TYPE (SymVBBpp), INTENT(IN) :: vBBpp
		TYPE (SymHartreeFockField), INTENT(IN) :: P_in

		CALL SymD3Tensor_SymD3Tensor_product(HF_out%p(0), vBBpp%v1_pair, P_in%p(0))
		CALL SymD3Tensor_SymD3Tensor_product(HF_out%p(1), vBBpp%v1_pair, P_in%p(1))
		CALL SymD3Tensor_SymD3Tensor_product(HF_out%a(0), vBBpp%v2_pair, P_in%a(0))
		CALL SymD3Tensor_SymD3Tensor_product(HF_out%a(1), vBBpp%v2_pair, P_in%a(1))
		RETURN
	END SUBROUTINE SymVBBpp_get_Delta

        !---------------------------------------------------------------------------------------!
	!											!
	!   Subroutine reading the matrix elements of the Brink-Boker term in the particle-	!
	!   particle channel. This subroutine attempts reading a file containing previously 	!
	!   calculated matrix elements. It is used to decide whether or not to recalculate 	!
	!   everything										!
	!											!
        !---------------------------------------------------------------------------------------!

	FUNCTION SymVBBpp_read(vBBpp)
		LOGICAL SymVBBpp_read
		TYPE (SymVBBpp), INTENT(INOUT) :: vBBpp

		DOUBLE PRECISION b1
		INTEGER la, namax, na, nc, lb, nbmax, nb, nd
		INTEGER i1, i2, i3, i4, i5, i6
		INTEGER, PARAMETER :: file_desc = 6
		INTEGER file_error
		DOUBLE PRECISION sum1, sum2

		OPEN(file_desc, FILE=vBBpp%filename, ACTION="READ", IOSTAT=file_error)
		IF (file_error .NE. 0) THEN
			PRINT *, "No se pudo leer el archivo: ", vBBpp%filename
			SymVBBpp_read = .FALSE.
			RETURN
		END IF

		READ (file_desc, FMT="(E)", IOSTAT=file_error) b1
		IF ((file_error .NE. 0) .OR. (b1 .NE. vBBpp%b1)) THEN
			CLOSE(file_desc)
			SymVBBpp_read = .FALSE.
			RETURN
		END IF

!		PRINT *, "Leyendo:", vBBpp%filename
		DO la = 0, N_0
			namax = ((N_0 - la) / 2) + 1
			DO na = 1, namax
				DO nc = 1, na
					DO lb = 0, la
						nbmax = ((N_0 - lb) / 2) + 1
						DO nb = 1, nbmax
							DO nd = 1, nb
								READ (file_desc, FMT="(I3,I3,I3,I3,I3,I3,E,E)", IOSTAT=file_error) &
									i1, i2, i3, i4, i5, i6, sum1, sum2
								IF ((file_error .NE. 0) .OR. &
									(la .NE. i1) .OR. (na .NE. i2) .OR. (nc .NE. i3) .OR. &
									(lb .NE. i4) .OR. (nb .NE. i5) .OR. (nd .NE. i6)) THEN
									PRINT *, "Informacion no validad en el archivo: ", vBBpp%filename
									CLOSE(file_desc)
									SymVBBpp_read = .FALSE.
									RETURN
								END IF
								CALL SymD3Tensor_SymD3Tensor_assign(vBBpp%v1_pair, la, na, nc, lb, nb, nd, sum1)
								CALL SymD3Tensor_SymD3Tensor_assign(vBBpp%v1_pair, lb, nb, nd, la, na, nc, sum1)
								CALL SymD3Tensor_SymD3Tensor_assign(vBBpp%v2_pair, la, na, nc, lb, nb, nd, sum2)
								CALL SymD3Tensor_SymD3Tensor_assign(vBBpp%v2_pair, lb, nb, nd, la, na, nc, sum2)
							END DO
						END DO
					END DO
				END DO
			END DO
		END DO
		CLOSE(file_desc)

		SymVBBpp_read = .TRUE.
		RETURN
	END FUNCTION SymVBBpp_read

        !---------------------------------------------------------------------------------------!
	!											!
	!   Subroutine deleting the tensors corresponding to the matrix elements of the Brink-	!
	!   Boker in the particle-particle channel.						!
	!											!
        !---------------------------------------------------------------------------------------!

	SUBROUTINE SymVBBpp_del(vBBpp)
		TYPE (SymVBBpp), INTENT(INOUT) :: vBBpp

		CALL SymD3Tensor_SymD3Tensor_del(vBBpp%v1_pair)
		CALL SymD3Tensor_SymD3Tensor_del(vBBpp%v2_pair)
		
		RETURN
	END SUBROUTINE SymVBBpp_del

END MODULE symvbb
 MODULE symvc

	USE input
	USE angmom
	USE symd3t
	USE symfield
	USE ic

	IMPLICIT NONE

	TYPE SymVCph
		TYPE (SymD3Tensor_SymD3Tensor) v_local, v1_exch, v2_exch, v1
		CHARACTER(64) filename
	END TYPE

	TYPE SymVCpp
		TYPE (SymD3Tensor_SymD3Tensor) v1_pair, v2_pair
		CHARACTER(64) filename
	END TYPE

 CONTAINS

	SUBROUTINE SymVCph_new(vCph)
		TYPE (SymVCph), INTENT(INOUT) :: vCph

		CALL SymD3Tensor_SymD3Tensor_new(vCph%v_local)
		CALL SymD3Tensor_SymD3Tensor_new(vCph%v1_exch)
		CALL SymD3Tensor_SymD3Tensor_new(vCph%v2_exch)
		CALL SymD3Tensor_SymD3Tensor_new(vCph%v1)

		IF (N_0 < 10) THEN
			WRITE(vCph%filename, "(A,I1,A)") "data/vC", N_0, "ph.txt"
		ELSE
			WRITE(vCph%filename, "(A,I2,A)") "data/vC", N_0, "ph.txt"
		END IF
		RETURN
	END SUBROUTINE SymVCph_new

	SUBROUTINE SymVCph_calculate(vCph)
		TYPE (SymVCph), INTENT(INOUT) :: vCph

		INTEGER la, namax, na, nc, lb, nbmax, nb, nd
		DOUBLE PRECISION sumi, total_iC
		INTEGER k, kmin, kmax
		DOUBLE PRECISION tres_j_cuad, cuad
		DOUBLE PRECISION sum1, sum2

		INTEGER, PARAMETER :: file_desc = 6
		INTEGER file_error

		IF (N_0 .LE. 16) THEN
			IF (SymVCph_read(vCph)) THEN
				CALL SymD3Tensor_SymD3Tensor_add(vCph%v1, vCph%v_local, vCph%v1_exch)
				RETURN
			END IF

			OPEN(file_desc, FILE=vCph%filename, ACTION="WRITE", IOSTAT=file_error)
			IF (file_error .NE. 0) THEN
				PRINT *, "*** AVISO: No se pueden escribir los resultados en ", vCph%filename
			END IF
		END IF

		PRINT *
		PRINT *, "Se van a calcular los elementos de matriz ph de C:"
		DO la = 0, N_0
			namax = ((N_0 - la) / 2) + 1
			DO na = 1, namax
				DO nc = 1, na
					DO lb = 0, la
						nbmax = ((N_0 - lb) / 2) + 1
						DO nb = 1, nbmax
							DO nd = 1, nb
								total_iC = ICoulomb(na - 1, la, nb - 1, lb, nc - 1, la, nd - 1, lb, 0)
								IF (nb .NE. nd) THEN
									total_iC = total_iC + ICoulomb(na - 1, la, nd - 1, lb, nc - 1, la, nb - 1, lb, 0)
									total_iC = total_iC / 2.0
								END IF
								sumi = (VC * I_4PI) * total_iC
								CALL SymD3Tensor_SymD3Tensor_assign(vCph%v_local, la, na, nc, lb, nb, nd, sumi)
								CALL SymD3Tensor_SymD3Tensor_assign(vCph%v_local, lb, nb, nd, la, na, nc, sumi)

								kmin = ABS(la - lb)
								kmax = la + lb
								sum1 = 0.0
								sum2 = 0.0
								DO k = kmin, kmax, 2
									tres_j_cuad = (2 * k + 1) * (ThreeJSymbols_get(2 * la, 2 * k, 2 * lb) ** 2)
									cuad = CUAD2(la, lb, k)
									total_iC = ICoulomb(na - 1, la, nb - 1, lb, nd - 1, lb, nc - 1, la, k)
									IF(nb .NE. nd) THEN
										total_iC = total_iC + ICoulomb(na - 1, la, nd - 1, lb, nb - 1, lb, nc - 1, la, k)
										total_iC = total_iC / 2.0
									END IF
									total_iC = total_iC * (VC * I_4PI)
									sum1 = sum1 + (tres_j_cuad * total_iC)
									sum2 = sum2 + (cuad * tres_j_cuad * total_iC)
								END DO

								sum1 = -0.5 * sum1
								sum2 = -sum2
								CALL SymD3Tensor_SymD3Tensor_assign(vCph%v1_exch, la, na, nc, lb, nb, nd, sum1)
								CALL SymD3Tensor_SymD3Tensor_assign(vCph%v1_exch, lb, nb, nd, la, na, nc, sum1)
								CALL SymD3Tensor_SymD3Tensor_assign(vCph%v2_exch, la, na, nc, lb, nb, nd, sum2)
								CALL SymD3Tensor_SymD3Tensor_assign(vCph%v2_exch, lb, nb, nd, la, na, nc, sum2)
								IF ((N_0 .LE. 16) .AND. (file_error .EQ. 0)) THEN
									WRITE (file_desc, FMT="(I3,I3,I3,I3,I3,I3,E,E,E)", IOSTAT=file_error) &
										la, na, nc, lb, nb, nd, sumi, sum1, sum2
								END IF
							END DO
						END DO
					END DO
				END DO
			END DO
			PRINT "(I3,A)", INT(100 * (la + 1) / (N_0 + 1)), "% calculado"
		END DO
		CALL SymD3Tensor_SymD3Tensor_add(vCph%v1, vCph%v_local, vCph%v1_exch)
		IF (N_0 .LE. 16) CLOSE(file_desc)
		PRINT "(A,A)", "Resultado almacenado en: ", vCph%filename
		RETURN
	END SUBROUTINE SymVCph_calculate

	SUBROUTINE SymVCph_product(HF_out, vCph, HF_in)
		TYPE (SymHartreeFockField), INTENT(INOUT) :: HF_out
		TYPE (SymVCph), INTENT(IN) :: vCph
		TYPE (SymHartreeFockField), INTENT(IN) :: HF_in

		CALL SymVCph_get_Gamma(HF_out, vCph, HF_in)
		RETURN
	END SUBROUTINE SymVCph_product

	SUBROUTINE SymVCph_get_Gamma(HF_out, vCph, HF_in)
		TYPE (SymHartreeFockField), INTENT(INOUT) :: HF_out
		TYPE (SymVCph), INTENT(IN) :: vCph
		TYPE (SymHartreeFockField), INTENT(IN) :: HF_in

		CALL SymD3Tensor_SymD3Tensor_product(HF_out%p(0), vCph%v1, HF_in%p(0))
		HF_out%p(1) = DBLE(0.0)
		CALL SymD3Tensor_SymD3Tensor_product(HF_out%a(0), vCph%v2_exch, HF_in%a(0))
		HF_out%a(1) = DBLE(0.0)
		RETURN
	END SUBROUTINE SymVCph_get_Gamma

	SUBROUTINE SymVCph_get_LocalGamma(HF_out, vCph, HF_in)
		TYPE (SymHartreeFockField), INTENT(INOUT) :: HF_out
		TYPE (SymVCph), INTENT(IN) :: vCph
		TYPE (SymHartreeFockField), INTENT(IN) :: HF_in

		CALL SymD3Tensor_SymD3Tensor_product(HF_out%p(0), vCph%v_local, HF_in%p(0))
		HF_out%p(1) = DBLE(0.0)
		HF_out%a(0) = DBLE(0.0)
		HF_out%a(1) = DBLE(0.0)
		RETURN
	END SUBROUTINE SymVCph_get_LocalGamma

	SUBROUTINE SymVCph_get_ExchangeGamma(HF_out, vCph, HF_in)
		TYPE (SymHartreeFockField), INTENT(INOUT) :: HF_out
		TYPE (SymVCph), INTENT(IN) :: vCph
		TYPE (SymHartreeFockField), INTENT(IN) :: HF_in

		CALL SymD3Tensor_SymD3Tensor_product(HF_out%p(0), vCph%v1_exch, HF_in%p(0))
		HF_out%p(1) = DBLE(0.0)
		CALL SymD3Tensor_SymD3Tensor_product(HF_out%a(0), vCph%v2_exch, HF_in%a(0))
		HF_out%a(1) = DBLE(0.0)
		RETURN
	END SUBROUTINE SymVCph_get_ExchangeGamma

	FUNCTION SymVCph_read(vCph)
		LOGICAL SymVCph_read
		TYPE (SymVCph), INTENT(INOUT) :: vCph

		INTEGER la, namax, na, nc, lb, nbmax, nb, nd
		INTEGER i1, i2, i3, i4, i5, i6
		INTEGER, PARAMETER :: file_desc = 6
		INTEGER file_error
		DOUBLE PRECISION sumi, sum1, sum2

		OPEN(file_desc, FILE=vCph%filename, ACTION="READ", IOSTAT=file_error)
		IF (file_error .NE. 0) THEN
			PRINT *, "No se pudo leer el archivo: ", vCph%filename
			SymVCph_read = .FALSE.
			RETURN
		END IF

!		PRINT *, "Leyendo:", vCph%filename
		DO la = 0, N_0
			namax = ((N_0 - la) / 2) + 1
			DO na = 1, namax
				DO nc = 1, na
					DO lb = 0, la
						nbmax = ((N_0 - lb) / 2) + 1
						DO nb = 1, nbmax
							DO nd = 1, nb
								READ (file_desc, FMT="(I3,I3,I3,I3,I3,I3,E,E,E)", IOSTAT=file_error) &
									i1, i2, i3, i4, i5, i6, sumi, sum1, sum2
								IF ((file_error .NE. 0) .OR. &
									(la .NE. i1) .OR. (na .NE. i2) .OR. (nc .NE. i3) .OR. &
									(lb .NE. i4) .OR. (nb .NE. i5) .OR. (nd .NE. i6)) THEN
									PRINT *, "Informacion no validad en el archivo: ", vCph%filename
									CLOSE(file_desc)
									SymVCph_read = .FALSE.
									RETURN
								END IF
								CALL SymD3Tensor_SymD3Tensor_assign(vCph%v_local, la, na, nc, lb, nb, nd, sumi)
								CALL SymD3Tensor_SymD3Tensor_assign(vCph%v_local, lb, nb, nd, la, na, nc, sumi)
								CALL SymD3Tensor_SymD3Tensor_assign(vCph%v1_exch, la, na, nc, lb, nb, nd, sum1)
								CALL SymD3Tensor_SymD3Tensor_assign(vCph%v1_exch, lb, nb, nd, la, na, nc, sum1)
								CALL SymD3Tensor_SymD3Tensor_assign(vCph%v2_exch, la, na, nc, lb, nb, nd, sum2)
								CALL SymD3Tensor_SymD3Tensor_assign(vCph%v2_exch, lb, nb, nd, la, na, nc, sum2)
							END DO
						END DO
					END DO
				END DO
			END DO
		END DO
		CLOSE(file_desc)
		SymVCph_read = .TRUE.
		RETURN
	END FUNCTION SymVCph_read

	SUBROUTINE SymVCph_del(vCph)
		TYPE (SymVCph), INTENT(INOUT) :: vCph

		CALL SymD3Tensor_SymD3Tensor_del(vCph%v_local)
		CALL SymD3Tensor_SymD3Tensor_del(vCph%v1_exch)
		CALL SymD3Tensor_SymD3Tensor_del(vCph%v2_exch)
		CALL SymD3Tensor_SymD3Tensor_del(vCph%v1)
		RETURN
	END SUBROUTINE SymVCph_del

	SUBROUTINE SymVCpp_new(vCpp)
		TYPE (SymVCpp), INTENT(INOUT) :: vCpp

		CALL SymD3Tensor_SymD3Tensor_new(vCpp%v1_pair)
		CALL SymD3Tensor_SymD3Tensor_new(vCpp%v2_pair)

		IF (N_0 < 10) THEN
			WRITE(vCpp%filename, "(A,I1,A)") "data/vC", N_0, "pp.txt"
		ELSE
			WRITE(vCpp%filename, "(A,I2,A)") "data/vC", N_0, "pp.txt"
		END IF
		RETURN
	END SUBROUTINE SymVCpp_new

	SUBROUTINE SymVCpp_calculate(vCpp)
		TYPE (SymVCpp), INTENT(INOUT) :: vCpp

		INTEGER la, namax, na, nc, lb, nbmax, nb, nd
		INTEGER k, kmin, kmax
		DOUBLE PRECISION sum1, sum2, total_iC
		DOUBLE PRECISION tres_j_cuad, cuad

		INTEGER, PARAMETER :: file_desc = 6
		INTEGER file_error

		IF (N_0 .LE. 16) THEN
			IF (SymVCpp_read(vCpp)) RETURN

			OPEN(file_desc, FILE=vCpp%filename, ACTION="WRITE", IOSTAT=file_error)
			IF (file_error .NE. 0) THEN
				PRINT *, "*** AVISO: No se pueden escribir los resultados en ", vCpp%filename
			END IF
		END IF

		PRINT *, "Se van a calcular los elementos de matriz pp de C:"
		DO la = 0, N_0
			namax = ((N_0 - la) / 2) + 1
			DO na = 1, namax
				DO nc = 1, na
					DO lb = 0, la
						nbmax = ((N_0 - lb) / 2) + 1
						DO nb = 1, nbmax
							DO nd = 1, nb
								kmin = ABS(la - lb)
								kmax = la + lb
								sum1 = 0.0
								sum2 = 0.0
								DO k = kmin, kmax, 2
									tres_j_cuad = (2 * k + 1) * (ThreeJSymbols_get(2 * la, 2 * k, 2 * lb) ** 2)
									cuad = CUAD2(la, lb, k)
									total_iC = (VC * I_4PI) * ICoulomb(na - 1, la, nc - 1, la, nb - 1, lb, nd - 1, lb, k)
									IF(nb .NE. nd) THEN
										total_iC = total_iC + (VC * I_4PI) * &
											ICoulomb(na - 1, la, nc - 1, la, nd - 1, la, nb - 1, lb, 0)
										total_iC = total_iC / 2.0
									END IF
									sum1 = sum1 + (       tres_j_cuad * total_iC)
									sum2 = sum2 + (cuad * tres_j_cuad * total_iC)
								END DO
								sum1 = 0.5 * PAR(la + lb) * sum1
								sum2 =       PAR(la + lb) * sum2
								CALL SymD3Tensor_SymD3Tensor_assign(vCpp%v1_pair, la, na, nc, lb, nb, nd, sum1)
								CALL SymD3Tensor_SymD3Tensor_assign(vCpp%v1_pair, lb, nb, nd, la, na, nc, sum1)
								CALL SymD3Tensor_SymD3Tensor_assign(vCpp%v2_pair, la, na, nc, lb, nb, nd, sum2)
								CALL SymD3Tensor_SymD3Tensor_assign(vCpp%v2_pair, lb, nb, nd, la, na, nc, sum2)
								IF ((N_0 .LE. 16) .AND. (file_error .EQ. 0)) THEN
									WRITE (file_desc, "(I3,I3,I3,I3,I3,I3,E,E)", IOSTAT=file_error) &
										la, na, nc, lb, nb, nd, sum1, sum2
								END IF
							END DO
						END DO
					END DO
				END DO
			END DO
			PRINT "(I3,A)", INT(100 * (la + 1) / (N_0 + 1)), "% calculado"
		END DO
		IF (N_0 .LE. 16) CLOSE(file_desc)
		RETURN
	END SUBROUTINE SymVCpp_calculate

	SUBROUTINE SymVCpp_product(HF_out, vCpp, HF_in)
		TYPE (SymHartreeFockField), INTENT(INOUT) :: HF_out
		TYPE (SymVCpp), INTENT(IN) :: vCpp
		TYPE (SymHartreeFockField), INTENT(IN) :: HF_in

		CALL SymVCpp_get_Delta(HF_out, vCpp, HF_in)
		RETURN
	END SUBROUTINE SymVCpp_product

	SUBROUTINE SymVCpp_get_Delta(HF_out, vCpp, P_in)
		TYPE (SymHartreeFockField), INTENT(INOUT) :: HF_out
		TYPE (SymVCpp), INTENT(IN) :: vCpp
		TYPE (SymHartreeFockField), INTENT(IN) :: P_in

		CALL SymD3Tensor_SymD3Tensor_product(HF_out%p(0), vCpp%v1_pair, P_in%p(0))
		HF_out%p(1) = DBLE(0.0)
		CALL SymD3Tensor_SymD3Tensor_product(HF_out%a(0), vCpp%v2_pair, P_in%a(0))
		HF_out%a(1) = DBLE(0.0)
		RETURN
	END SUBROUTINE SymVCpp_get_Delta

	FUNCTION SymVCpp_read(vCpp)
		LOGICAL SymVCpp_read
		TYPE (SymVCpp), INTENT(INOUT) :: vCpp

		INTEGER la, namax, na, nc, lb, nbmax, nb, nd
		INTEGER i1, i2, i3, i4, i5, i6
		INTEGER, PARAMETER :: file_desc = 6
		INTEGER file_error
		DOUBLE PRECISION sum1, sum2

		OPEN(file_desc, FILE=vCpp%filename, ACTION="READ", IOSTAT=file_error)
		IF (file_error .NE. 0) THEN
			PRINT *, "No se pudo leer el archivo: ", vCpp%filename
			SymVCpp_read = .FALSE.
			RETURN
		END IF

!		PRINT *, "Leyendo:", vCpp%filename
		DO la = 0, N_0
			namax = ((N_0 - la) / 2) + 1
			DO na = 1, namax
				DO nc = 1, na
					DO lb = 0, la
						nbmax = ((N_0 - lb) / 2) + 1
						DO nb = 1, nbmax
							DO nd = 1, nb
								READ (file_desc, FMT="(I3,I3,I3,I3,I3,I3,E,E)", IOSTAT=file_error) &
									i1, i2, i3, i4, i5, i6, sum1, sum2
								IF ((file_error .NE. 0) .OR. &
									(la .NE. i1) .OR. (na .NE. i2) .OR. (nc .NE. i3) .OR. &
									(lb .NE. i4) .OR. (nb .NE. i5) .OR. (nd .NE. i6)) THEN
									PRINT *, "Informacion no validad en el archivo: ", vCpp%filename
									CLOSE(file_desc)
									SymVCpp_read = .FALSE.
									RETURN
								END IF
								CALL SymD3Tensor_SymD3Tensor_assign(vCpp%v1_pair, la, na, nc, lb, nb, nd, sum1)
								CALL SymD3Tensor_SymD3Tensor_assign(vCpp%v1_pair, lb, nb, nd, la, na, nc, sum1)
								CALL SymD3Tensor_SymD3Tensor_assign(vCpp%v2_pair, la, na, nc, lb, nb, nd, sum2)
								CALL SymD3Tensor_SymD3Tensor_assign(vCpp%v2_pair, lb, nb, nd, la, na, nc, sum2)
							END DO
						END DO
					END DO
				END DO
			END DO
		END DO
		CLOSE(file_desc)

		SymVCpp_read = .TRUE.
		RETURN
	END FUNCTION SymVCpp_read

	SUBROUTINE SymVCpp_del(vCpp)
		TYPE (SymVCpp), INTENT(INOUT) :: vCpp

		CALL SymD3Tensor_SymD3Tensor_del(vCpp%v1_pair)
		CALL SymD3Tensor_SymD3Tensor_del(vCpp%v2_pair)
		RETURN
	END SUBROUTINE SymVCpp_del

END MODULE symvc
!----------------------------------------------------------------!
!								 !
!    CALCULATION OF THE SPIN-ORBIT TERM OF THE GOGNY FORCE       !
!								 !
!----------------------------------------------------------------!

 MODULE symvls

	USE input
	USE global
	USE symd3t
	USE symfield
	USE ils

	IMPLICIT NONE

	TYPE SymVLSph
		TYPE (SymD3Tensor_SymD3Tensor) v12, v21
		!CHARACTER(64) filename
	END TYPE

	TYPE SymVLSpp
		TYPE (SymD3Tensor_SymD3Tensor) v22
		!CHARACTER(64) filename
	END TYPE
	
	CHARACTER(64) :: FilePH,  FilePP

 CONTAINS

	!----------------------------------------------------------------!
	!								 !
	!    		PARTICLE-HOLE CHANNEL (MEAN-FIELD)  	         !
	!								 !
	!----------------------------------------------------------------!

	SUBROUTINE SymVLSph_new(vLSph)
		TYPE (SymVLSph), INTENT(INOUT) :: vLSph

		CALL SymD3Tensor_SymD3Tensor_new(vLSph%v12)
		CALL SymD3Tensor_SymD3Tensor_new(vLSph%v21)

                SELECT CASE (Basis)
		
		CASE (1)
         
			IF (N_0 < 10) THEN
				WRITE(FilePH, "(A,I1,A)") "data/vLS", N_0, "ph_HO.txt"
			ELSE
				WRITE(FilePH, "(A,I2,A)") "data/vLS", N_0, "ph_HO.txt"							
			END IF
			
		CASE (2)
         
			IF (N_0 < 10) THEN
				WRITE(FilePH, "(A,I1,A)") "data/vLS", N_0, "ph_WS.txt"
			ELSE
				WRITE(FilePH, "(A,I2,A)") "data/vLS", N_0, "ph_WS.txt"							
			END IF

		END SELECT
			
		RETURN
	END SUBROUTINE SymVLSph_new

	SUBROUTINE SymVLSph_calculate(vLSph)
		TYPE (SymVLSph), INTENT(INOUT) :: vLSph

		INTEGER la, na, namax, nc, lb, nb, nbmax, nd
		DOUBLE PRECISION sum1, sum2

		INTEGER, PARAMETER :: file_desc = 6
		INTEGER file_error

		IF (N_0 .LE. 16) THEN
			IF (SymVLSph_read(vLSph)) RETURN

			OPEN(file_desc, FILE=FilePH, ACTION="WRITE", IOSTAT=file_error)
			IF (file_error .NE. 0) THEN
				PRINT *, "*** AVISO: No se pueden escribir los resultados en ", FilePH
			END IF
		END IF


                SELECT CASE (Basis)
		
		CASE (1)
         
			PRINT *, "Calculation of the matrix elements of the spin-orbit term:"
			DO la = 0, N_0
				namax = ((N_0 - la) / 2) + 1
				DO na = 1, namax
					DO nc = 1, na
				
						DO lb = 0, la
							nbmax = ((N_0 - lb) / 2) + 1
							DO nb = 1, nbmax
								DO nd = 1, nb
							
									IF (lb .EQ. 0) THEN
										sum1 = DBLE(0.0)
									ELSE
										sum1 = DBLE(lb * (lb + 1)) * IHFLSHO(nb - 1, nd - 1, lb, na - 1, nc - 1, la)
									END IF
									IF (la .EQ. 0) THEN
										sum2 = DBLE(0.0)
									ELSE
										sum2 = DBLE(la * (la + 1)) * IHFLSHO(na - 1, nc - 1, la, nb - 1, nd - 1, lb)
									END IF
								
									CALL SymD3Tensor_SymD3Tensor_assign(vLSph%v12, la, na, nc, lb, nb, nd, sum1)
									CALL SymD3Tensor_SymD3Tensor_assign(vLSph%v21, la, na, nc, lb, nb, nd, sum2)
								
									IF (la .NE. lb) THEN
										! Ojo, estan invertidos los terminos
										CALL SymD3Tensor_SymD3Tensor_assign(vLSph%v12, lb, nb, nd, la, na, nc, sum2)
										CALL SymD3Tensor_SymD3Tensor_assign(vLSph%v21, lb, nb, nd, la, na, nc, sum1)
									END IF
									IF ((N_0 .LE. 16) .AND. (file_error .EQ. 0)) THEN
										WRITE (file_desc, FMT="(I3,I3,I3,I3,I3,I3,E,E)", IOSTAT=file_error) &
											la, na, nc, lb, nb, nd, sum1, sum2
									END IF
								
								END DO
							END DO
						END DO
					
					END DO
				END DO
				PRINT "(I3,A)", INT(100 * (la + 1) / (N_0 + 1)), "% calculated"
			END DO
			IF (N_0 .LE. 16) CLOSE(file_desc)
		
		CASE (2)
		
			PRINT *, "Calculation of the matrix elements of the spin-orbit term:"
			DO la = 0, N_0
				namax = ((N_0 - la) / 2) + 1
				DO na = 1, namax
					DO nc = 1, na
				
						DO lb = 0, la
							nbmax = ((N_0 - lb) / 2) + 1
							DO nb = 1, nbmax
								DO nd = 1, nb
							
									IF (lb .EQ. 0) THEN
										sum1 = DBLE(0.0)
									ELSE
										sum1 = DBLE(lb * (lb + 1)) * IHFLS(nb, nd, lb, na, nc, la)
									END IF
									IF (la .EQ. 0) THEN
										sum2 = DBLE(0.0)
									ELSE
										sum2 = DBLE(la * (la + 1)) * IHFLS(na, nc, la, nb, nd, lb)
									END IF
								
									CALL SymD3Tensor_SymD3Tensor_assign(vLSph%v12, la, na, nc, lb, nb, nd, sum1)
									CALL SymD3Tensor_SymD3Tensor_assign(vLSph%v21, la, na, nc, lb, nb, nd, sum2)
								
									IF (la .NE. lb) THEN
										! Ojo, estan invertidos los terminos
										CALL SymD3Tensor_SymD3Tensor_assign(vLSph%v12, lb, nb, nd, la, na, nc, sum2)
										CALL SymD3Tensor_SymD3Tensor_assign(vLSph%v21, lb, nb, nd, la, na, nc, sum1)
									END IF
									IF ((N_0 .LE. 16) .AND. (file_error .EQ. 0)) THEN
										WRITE (file_desc, FMT="(I3,I3,I3,I3,I3,I3,E,E)", IOSTAT=file_error) &
											la, na, nc, lb, nb, nd, sum1, sum2
									END IF
								
								END DO
							END DO
						END DO
					
					END DO
				END DO
				PRINT "(I3,A)", INT(100 * (la + 1) / (N_0 + 1)), "% calculated"
			END DO
			IF (N_0 .LE. 16) CLOSE(file_desc)
		
		END SELECT
		
		RETURN
	END SUBROUTINE SymVLSph_calculate

	! Nota: si y0 != 1 este factor cambia la fuerza
	! Se pretende que la fuerza de spin-orbita sea dependiente del isosoin
	SUBROUTINE SymVLSph_product(HF_out, vLSph, HF_in)
		TYPE (SymHartreeFockField), INTENT(INOUT) :: HF_out
		TYPE (SymVLSph), INTENT(IN) :: vLSph
		TYPE (SymHartreeFockField), INTENT(IN) :: HF_in

		CALL SymVLSph_get_Gamma(HF_out, vLSph, HF_in)
		RETURN
	END SUBROUTINE SymVLSph_product

	SUBROUTINE SymVLSph_get_Gamma(HF_out, vLSph, HF_in)
		TYPE (SymHartreeFockField), INTENT(INOUT) :: HF_out
		TYPE (SymVLSph), INTENT(IN) :: vLSph
		TYPE (SymHartreeFockField), INTENT(IN) :: HF_in

		DOUBLE PRECISION factor
		TYPE (SymD3Tensor) tmp1, tmp2, tmp3

		CALL SymD3Tensor_new(tmp1)
		CALL SymD3Tensor_new(tmp2)
		CALL SymD3Tensor_new(tmp3)

		! Atencin: si (y0 .NE. 1), este factor cambia la fuerza.
		! Se pretende que la fuerza de spin-orbita sea dependiente del isosoin.
		factor = Gogny_W0(Gogny) * I_4PI

		CALL SymD3Tensor_product(tmp1, 1.0 + x0, HF_in%a(0))
		CALL SymD3Tensor_product(tmp2, x0, HF_in%a(1))
		CALL SymD3Tensor_add(tmp3, tmp1, tmp2)
		CALL SymD3Tensor_SymD3Tensor_product(tmp1, vLSph%v12, tmp3)
		CALL SymD3Tensor_product(HF_out%p(0), factor, tmp1)

		CALL SymD3Tensor_product(tmp1, 1.0 + x0, HF_in%a(1))
		CALL SymD3Tensor_product(tmp2, x0, HF_in%a(0))
		CALL SymD3Tensor_add(tmp3, tmp1, tmp2)
		CALL SymD3Tensor_SymD3Tensor_product(tmp1, vLSph%v12, tmp3)
		CALL SymD3Tensor_product(HF_out%p(1), factor, tmp1)

		CALL SymD3Tensor_product(tmp1, 1.0 + x0, HF_in%p(0))
		CALL SymD3Tensor_product(tmp2, x0, HF_in%p(1))
		CALL SymD3Tensor_add(tmp3, tmp1, tmp2)
		CALL SymD3Tensor_SymD3Tensor_product(tmp1, vLSph%v21, tmp3)
		CALL SymD3Tensor_product(HF_out%a(0), factor, tmp1)

		CALL SymD3Tensor_product(tmp1, 1.0 + x0, HF_in%p(1))
		CALL SymD3Tensor_product(tmp2, x0, HF_in%p(0))
		CALL SymD3Tensor_add(tmp3, tmp1, tmp2)
		CALL SymD3Tensor_SymD3Tensor_product(tmp1, vLSph%v21, tmp3)
		CALL SymD3Tensor_product(HF_out%a(1), factor, tmp1)

		CALL SymD3Tensor_del(tmp1)
		CALL SymD3Tensor_del(tmp2)
		CALL SymD3Tensor_del(tmp3)
		RETURN
	END SUBROUTINE SymVLSph_get_Gamma

	FUNCTION SymVLSph_read(vLSph)
		LOGICAL SymVLSph_read
		TYPE (SymVLSph), INTENT(INOUT) :: vLSph

		INTEGER la, namax, na, nc, lb, nbmax, nb, nd
		INTEGER i1, i2, i3, i4, i5, i6
		DOUBLE PRECISION sum1, sum2

		INTEGER, PARAMETER :: file_desc = 6
		INTEGER file_error

		OPEN(file_desc, FILE=FilePH, ACTION="READ", IOSTAT=file_error)
		IF (file_error .NE. 0) THEN
			PRINT *, "No se pudo leer el archivo: ", FilePH
			SymVLSph_read = .FALSE.
			RETURN
		END IF

!		PRINT *, "Leyendo:", vLSph%filename
		DO la = 0, N_0
			namax = ((N_0 - la) / 2) + 1
			DO na = 1, namax
				DO nc = 1, na
				
					DO lb = 0, la
						nbmax = ((N_0 - lb) / 2) + 1
						DO nb = 1, nbmax
							DO nd = 1, nb
							
								READ (file_desc, FMT="(I3,I3,I3,I3,I3,I3,E,E)", IOSTAT=file_error) &
									i1, i2, i3, i4, i5, i6, sum1, sum2
								IF ((file_error .NE. 0) .OR. &
									(la .NE. i1) .OR. (na .NE. i2) .OR. (nc .NE. i3) .OR. &
									(lb .NE. i4) .OR. (nb .NE. i5) .OR. (nd .NE. i6)) THEN
									PRINT *, "Informacion no validad en el archivo: ", FilePH
									CLOSE(file_desc)
									SymVLSph_read = .FALSE.
									RETURN
								END IF
								
								CALL SymD3Tensor_SymD3Tensor_assign(vLSph%v12, la, na, nc, lb, nb, nd, sum1)
								CALL SymD3Tensor_SymD3Tensor_assign(vLSph%v21, la, na, nc, lb, nb, nd, sum2)
								
								IF (la .NE. lb) THEN
									! Ojo, estn invertidos los trminos
									CALL SymD3Tensor_SymD3Tensor_assign(vLSph%v12, lb, nb, nd, la, na, nc, sum2)
									CALL SymD3Tensor_SymD3Tensor_assign(vLSph%v21, lb, nb, nd, la, na, nc, sum1)
								END IF
								
							END DO
						END DO
					END DO
					
				END DO
			END DO
		END DO
		CLOSE(file_desc)

		SymVLSph_read = .TRUE.
		RETURN
	END FUNCTION SymVLSph_read

	SUBROUTINE SymVLSph_del(vLSph)
		TYPE (SymVLSph), INTENT(INOUT) :: vLSph

		CALL SymD3Tensor_SymD3Tensor_del(vLSph%v12)
		CALL SymD3Tensor_SymD3Tensor_del(vLSph%v21)
		RETURN
	END SUBROUTINE SymVLSph_del

	!----------------------------------------------------------------!
	!								 !
	!    		PARTICLE-PARTICLE CHANNEL (PAIRING)  	         !
	!								 !
	!----------------------------------------------------------------!

	SUBROUTINE SymVLSpp_new(vLSpp)
		TYPE (SymVLSpp), INTENT(INOUT) :: vLSpp

		CALL SymD3Tensor_SymD3Tensor_new(vLSpp%v22)

                SELECT CASE (Basis)
		
		CASE (1)
         
			IF (N_0 < 10) THEN
				WRITE(FilePP, "(A,I1,A)") "data/vLS", N_0, "pp_HO.txt"
			ELSE
				WRITE(FilePP, "(A,I2,A)") "data/vLS", N_0, "pp_HO.txt"
			END IF
		CASE (2)
         
			IF (N_0 < 10) THEN
				WRITE(FilePP, "(A,I1,A)") "data/vLS", N_0, "pp_WS.txt"
			ELSE
				WRITE(FilePP, "(A,I2,A)") "data/vLS", N_0, "pp_WS.txt"
			END IF
			
		END SELECT
			
		RETURN
	END SUBROUTINE SymVLSpp_new

	SUBROUTINE SymVLSpp_calculate(vLSpp)
		TYPE (SymVLSpp), INTENT(INOUT) :: vLSpp

		INTEGER la, na, namax, nc, lb, nb, nbmax, nd
		DOUBLE PRECISION sumi

		INTEGER, PARAMETER :: file_desc = 6
		INTEGER file_error

		IF (N_0 .LE. 16) THEN
			IF (SymVLSpp_read(vLSpp)) RETURN

			OPEN(file_desc, FILE=FilePP, ACTION="WRITE", IOSTAT=file_error)
			IF (file_error .NE. 0) THEN
				PRINT *, "*** AVISO: No se pueden escribir los resultados en ", FilePP
			END IF
		END IF

                SELECT CASE (Basis)
		
		CASE (1)
         
			PRINT *, "Se van a calcular los elementos de matriz de apar de LS"
			DO la = 0, N_0
				namax = ((N_0 - la) / 2) + 1
				DO na = 1, namax
					DO nc = 1, na
				
						DO lb = 0, la
							nbmax = ((N_0 - lb) / 2) + 1
							DO nb = 1, nbmax
								DO nd = 1, nb
							
									IF ((la .EQ. 0) .OR. (lb .EQ. 0)) THEN
										sumi = 0.0
									ELSE
										sumi = DBLE(PAR(la + lb) * 2.0 * la * (la + 1) * lb * (lb + 1)) * &
											IPLSHO(na - 1, nc - 1, la, nb - 1, nd - 1, lb)
									END IF
									
									CALL SymD3Tensor_SymD3Tensor_assign(vLSpp%v22, la, na, nc, lb, nb, nd, sumi)
									
									IF (la .NE. lb) THEN
										CALL SymD3Tensor_SymD3Tensor_assign(vLSpp%v22, lb, nb, nd, la, na, nc, sumi)
									END IF
									
									IF ((N_0 .LE. 16) .AND. (file_error .EQ. 0)) THEN
										WRITE (file_desc, FMT="(I3,I3,I3,I3,I3,I3,E)", IOSTAT=file_error) &
											la, na, nc, lb, nb, nd, sumi
									END IF
								
								END DO
							END DO
						END DO
					
					END DO
				END DO
				PRINT "(I3,A)", INT(100 * (la + 1) / (N_0 + 1)), "% calculado"
			END DO

		CASE(2)
		
			PRINT *, "Se van a calcular los elementos de matriz de apar de LS"
			DO la = 0, N_0
				namax = ((N_0 - la) / 2) + 1
				DO na = 1, namax
					DO nc = 1, na
				
						DO lb = 0, la
							nbmax = ((N_0 - lb) / 2) + 1
							DO nb = 1, nbmax
								DO nd = 1, nb
							
									IF ((la .EQ. 0) .OR. (lb .EQ. 0)) THEN
										sumi = 0.0
									ELSE
										sumi = DBLE(PAR(la + lb) * 2.0 * la * (la + 1) * lb * (lb + 1)) * &
											IPLS(na, nc, la, nb, nd, lb)
									END IF
									
									CALL SymD3Tensor_SymD3Tensor_assign(vLSpp%v22, la, na, nc, lb, nb, nd, sumi)
									
									IF (la .NE. lb) THEN
										CALL SymD3Tensor_SymD3Tensor_assign(vLSpp%v22, lb, nb, nd, la, na, nc, sumi)
									END IF
									
									IF ((N_0 .LE. 16) .AND. (file_error .EQ. 0)) THEN
										WRITE (file_desc, FMT="(I3,I3,I3,I3,I3,I3,E)", IOSTAT=file_error) &
											la, na, nc, lb, nb, nd, sumi
									END IF
								
								END DO
							END DO
						END DO
					
					END DO
				END DO
				PRINT "(I3,A)", INT(100 * (la + 1) / (N_0 + 1)), "% calculado"
			END DO

		END SELECT
			
		IF (N_0 .LE. 16) CLOSE(file_desc)
		RETURN
	END SUBROUTINE SymVLSpp_calculate

	SUBROUTINE SymVLSpp_product(HF_out, vLSpp, P_in)
		TYPE (SymHartreeFockField), INTENT(INOUT) :: HF_out
		TYPE (SymVLSpp), INTENT(IN) :: vLSpp
		TYPE (SymHartreeFockField), INTENT(IN) :: P_in

		CALL SymVLSpp_get_delta(HF_out, vLSpp, P_in)
		RETURN
	END SUBROUTINE SymVLSpp_product

	SUBROUTINE SymVLSpp_get_Delta(HF_out, vLSpp, P_in)
		TYPE (SymHartreeFockField), INTENT(INOUT) :: HF_out
		TYPE (SymVLSpp), INTENT(IN) :: vLSpp
		TYPE (SymHartreeFockField), INTENT(IN) :: P_in

		DOUBLE PRECISION factor
		TYPE (SymD3Tensor) tmp

		CALL SymD3Tensor_new(tmp)

		HF_out%p(0) = DBLE(0.0)
		HF_out%p(1) = DBLE(0.0)

		factor = Gogny_W0(Gogny) * I_4PI

		CALL SymD3Tensor_SymD3Tensor_product(tmp, vLSpp%v22, P_in%a(0))
		CALL SymD3Tensor_product(HF_out%a(0), factor, tmp)

		CALL SymD3Tensor_SymD3Tensor_product(tmp, vLSpp%v22, P_in%a(1))
		CALL SymD3Tensor_product(HF_out%a(1), factor, tmp)

		CALL SymD3Tensor_new(tmp)
		RETURN
	END SUBROUTINE SymVLSpp_get_Delta

	FUNCTION SymVLSpp_read(vLSpp)
		LOGICAL SymVLSpp_read
		TYPE (SymVLSpp), INTENT(INOUT) :: vLSpp

		INTEGER la, namax, na, nc, lb, nbmax, nb, nd
		INTEGER i1, i2, i3, i4, i5, i6
		DOUBLE PRECISION sumi

		INTEGER, PARAMETER :: file_desc = 6
		INTEGER file_error

		OPEN(file_desc, FILE=FilePP, ACTION="READ", IOSTAT=file_error)
		IF (file_error .NE. 0) THEN
			PRINT *, "No se pudo leer el archivo: ", FilePP
			SymVLSpp_read = .FALSE.
			RETURN
		END IF

!		PRINT *, "Leyendo:", vLSpp%filename
		DO la = 0, N_0
			namax = ((N_0 - la) / 2) + 1
			DO na = 1, namax
				DO nc = 1, na
				
					DO lb = 0, la
						nbmax = ((N_0 - lb) / 2) + 1
						DO nb = 1, nbmax
							DO nd = 1, nb
							
								READ (file_desc, FMT="(I3,I3,I3,I3,I3,I3,E)", IOSTAT=file_error) &
									i1, i2, i3, i4, i5, i6, sumi
								IF ((file_error .NE. 0) .OR. &
									(la .NE. i1) .OR. (na .NE. i2) .OR. (nc .NE. i3) .OR. &
									(lb .NE. i4) .OR. (nb .NE. i5) .OR. (nd .NE. i6)) THEN
									PRINT *, "Informacion no validad en el archivo: ", FilePP
									CLOSE(file_desc)
									SymVLSpp_read = .FALSE.
									RETURN
								END IF
								CALL SymD3Tensor_SymD3Tensor_assign(vLSpp%v22, la, na, nc, lb, nb, nd, sumi)
								IF (la .NE. lb) THEN
									CALL SymD3Tensor_SymD3Tensor_assign(vLSpp%v22, lb, nb, nd, la, na, nc, sumi)
								END IF
								
							END DO
						END DO
					END DO
					
				END DO
			END DO
		END DO
		CLOSE(file_desc)

		SymVLSpp_read = .TRUE.
		RETURN
	END FUNCTION SymVLSpp_read

	SUBROUTINE SymVLSpp_del(vLSpp)
		TYPE (SymVLSpp), INTENT(INOUT) :: vLSpp

		CALL SymD3Tensor_SymD3Tensor_del(vLSpp%v22)
		RETURN
	END SUBROUTINE SymVLSpp_del

END MODULE symvls
MODULE wave

	USE nucleus
	USE symfield
	USE genden

	IMPLICIT NONE

	TYPE WaveFunction
		TYPE (NucleusType) nucleus
		TYPE (GenDensity) genden
		INTEGER num
!		INTEGER dimensionUV
	END TYPE

CONTAINS

	SUBROUTINE WaveFunction_new(wave, N, Z)
		TYPE (WaveFunction), INTENT(INOUT) :: wave
		INTEGER, INTENT(IN) :: N, Z

		CALL Nucleus_new(wave%nucleus, N, Z)
		CALL GenDensity_new(wave%genden)
		wave%num = 0
		RETURN
	END SUBROUTINE WaveFunction_new

	SUBROUTINE WaveFunction_new_Nucleus(wave, nuc)
		TYPE (WaveFunction), INTENT(INOUT) :: wave
		TYPE (NucleusType), INTENT(IN) :: nuc

		CALL Nucleus_new_Nucleus(wave%nucleus, nuc)
		RETURN
	END SUBROUTINE WaveFunction_new_Nucleus

	SUBROUTINE WaveFunction_write(wave, n)
		TYPE (WaveFunction), INTENT(INOUT) :: wave
		INTEGER, INTENT(IN) :: n

		INTEGER file_error
		INTEGER, PARAMETER :: file_id = 6

		PRINT *
		PRINT *, "Escribiendo resultados en:", wave%nucleus%filename
! filename = filename + ".0"
!		OPEN(file_id, FILE=wave%nucleus%filename, ACTION="WRITE", IOSTAT=file_error)
!		IF (file_error .NE. 0) STOP "ERROR: Imposible escribir fichero"

!		CALL Nucleus_write(wave%nucleus, file_id)
!		CALL SymHartreeFockField_write(wave%genden%rho, file_id)
!		CALL SymHartreeFockField_write(wave%genden%kap, file_id)
!		CLOSE(file_id)
		RETURN
	END SUBROUTINE WaveFunction_write

END MODULE wave
