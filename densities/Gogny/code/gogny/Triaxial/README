A. BUILDING
   --------

1) Compile dimp.f to produce a executable named "dimp"

2) Run dimp.x to produce include files with dimensions

  ./dimp.x Q P N0 (for instance ./dimp.x 1. 1. 10.1 )

   Q and P are the ratios of the oscillator frequencies, N0 is the total 
   number of shells in the basis
  
3) Build the code

   make 
  
  (have a look to the makefile in case you want to change the default
  compiler -ifort- to gfortran, etc or you want to change the location
  of the Lapack and Blas libraries)
  
  The excutable is called  HFBtri

B. RUNNING
   -------

1) Create an input file using 36Ar.INP as template

NUCLEUS    036 Ar   Z= 018     >>> HFB OPT <<< CM1 1 CM2 1 COULECH 2
EPSG 0.000100 MAXITER 00150    >>> OUTPUT  <<< 0 **** TSTG 0
ETMAX 0.7500 ETMIN 0.0100 DMAX 0.90 DMIN 0.70 TSHH 999.0
GOGNY FORCE        0    *** 0=D1S 1=D1 2=D1' 3=D1N8 4=D1N6 5=D1M
INPUT W.F.         2    *** 0=WF OLD FORMAT 1=WF NEW FORMAT 2=WF FROM HO
OSCILLATOR LENGHT  0    *** 0               BX 2.1283 BY 2.0209 BZ 2.1531 
          >>>>>>>>>> C O N S T R A I N T S <<<<<<<<<<<
<Jx>    1 VALUE  0.00000000D+00 PREC  1.00D-05
Q20     1 VALUE  0.00394000D+05 PREC  1.00D-05
Q22     1 VALUE  0.00453000D+05 PREC  1.00D-05
Q40     0 VALUE  0.00000000D+00 PREC  1.00D-05

Line 1: CM1 0 or 1 controls the center of mass correction 1/m -> (1-1/A)1/m
        CM2 0 or 1 controls the two body kinetic energy correction
        COULECH 0, 1 or 2. 
                0 = no Coul Exchange 
                1 = Coul Exchange in Slater approximation
                2 = Exact Coul Exchange and Coul Antipairing 
                
Line 2: EPSG Stopping criterium for the iterative process, 10^-4 is
             reasonable but 10^-6 is much better
        MAXITER: Maximum number of iterations
        OUTPUT: 0=minimum output 9=maximum output
        TSTG: Gradient test
        
Line 3: Parameters controling the step size in the gradient

Line 4: Gogny Force (see gognyf.f for more details)

Line 5: INPUT WF
                 0= Wave function read from fort.10 (old format)
                 1= Wave function read from fort.10 (new format)
                 2= Wave function generated internally

The wave function structure depends upon the parameters passed to 
dimp.x (q, p and N0). The first time you run with a given set of
q, p and N0 use INPUT WF=2 to generate a wave function. Once the
iterative process finishes the wave function is writen in fort.11
You can use that w.f. as input with INPUT WF=1 (the 0 switch is for
compatibility ... )

Line 6: OSCILLATOR LENGHT 
        0 = read bx,by,bz from input file
        1 = read bx,by,bz from wave function file

CONSTRAINTS: The first constraint line is for Jx. The next integer
indicates if the constraint is on (1) or off (0). Next is the value
and the precision (this is never used ... )

The next three lines are for contraints on multipole moments QLM
with arbitraty L (EVEN) and M (compatible with positive signature).
See routine QLMME in ONEBODY.f for more information.

2) Run the code by using the input file as standard input, and 
   redirecting the standard output, e.g.,

   HFBtri < 36Ar.INP >& 36Ar.OUT

C. STRUCTURE
   =========

   
